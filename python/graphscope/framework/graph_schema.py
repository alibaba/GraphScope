#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
# Copyright 2020 Alibaba Group Holding Limited. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

import hashlib
import itertools
import json
from typing import List

from graphscope.framework.utils import unify_type
from graphscope.proto import types_pb2


class Entry:
    class PropertyDef:
        def __init__(self, prop_id: int, name: str, data_type: int) -> None:
            self.id = prop_id
            self.name = name
            self.type = data_type

        def __repr__(self) -> str:
            return f"Property({self.id}, {self.name})"

        def __str__(self) -> str:
            return self.__repr__()

    def __init__(self, label_id: int, label: str) -> None:
        self._id = label_id
        self._label = label
        self._props = []
        self._valid_props = []
        self._relations = []

        self._prop_index = {}

    @property
    def id(self) -> int:
        return self._id

    @property
    def label(self) -> str:
        return self._label

    @property
    def properties(self) -> List:
        return list(itertools.compress(self._props, self._valid_props))

    @property
    def relations(self) -> List:
        return self._relations

    def get_property_id(self, name):
        idx = self._prop_index[name]
        if not self._valid_props[idx]:
            raise ValueError(f"{name} not exist in properties")
        return idx

    def add_property(self, name, data_type):
        self._prop_index[name] = len(self._props)
        self._props.append(self.PropertyDef(len(self._props), name, data_type))
        self._valid_props.append(1)

    def add_relation(self, src, dst):
        self._relations.append((src, dst))

    def __repr__(self) -> str:
        s = f"Label: {self.label}\nProperties: {', '.join([str(p) for p in self.properties])}\n"
        if self._relations:
            s += f"Relations: {self.relations}"
        return s

    def __str__(self) -> str:
        return self.__repr__()


class GraphSchema:
    """Hold schema of a graph.

    Attributes:
        oid_type (str): Original ID type
        vid_type (str): Internal ID representation
        vdata_type (str): Type of the data that holding by vertex (simple graph only)
        edata_type (str): Type of the data that holding by edge (simple graph only)
        vertex_labels (list): Label names of vertex
        edge_labels (list): Label names of edge
        edge_relationships (list(list(tuple))): Source label and destination label of each edge label
    """

    def __init__(self):
        self._oid_type = None
        self._vid_type = None

        # simple graph only
        self._vdata_type = types_pb2.INVALID
        self._edata_type = types_pb2.INVALID

        # list of entries
        self._vertex_entries: List[Entry] = []
        self._edge_entries: List[Entry] = []

        # 1 indicate valid, 0 indicate invalid.
        self._valid_vertices = []
        self._valid_edges = []

        self._v_label_index = {}
        self._e_label_index = {}

    def get_schema_from_def(self, schema_def):
        """Decode informations from proto message, generated by engine.

        Args:
            schema_def (`GraphSchemaDef`): Proto message defined in `proto/graph_def.proto`.

        Raises:
            ValueError: If the schema is not valid.
        """
        self._oid_type = schema_def.oid_type
        self._vid_type = schema_def.vid_type

        # simple graph schema.
        if schema_def.vdata_type:
            self._vdata_type = unify_type(schema_def.vdata_type)
        if schema_def.edata_type:
            self._edata_type = unify_type(schema_def.edata_type)

        # property graph schema
        if schema_def.property_schema_json:
            try:
                schema = json.loads(schema_def.property_schema_json)
                if schema:
                    for item in schema["types"]:
                        entry = Entry(item["id"], item["label"])
                        for prop in item["propertyDefList"]:
                            entry.add_property(
                                prop["name"], unify_type(prop["data_type"])
                            )
                        entry._valid_props = item["valid_properties"]

                        if item["type"] == "VERTEX":
                            assert entry.id == len(self._vertex_entries)
                            self._vertex_entries.append(entry)
                            self._v_label_index[entry.label] = entry.id
                        elif item["type"] == "EDGE":
                            assert entry.id == len(self._edge_entries)
                            for rel in item["rawRelationShips"]:
                                entry.add_relation(
                                    rel["srcVertexLabel"], rel["dstVertexLabel"]
                                )
                            self._edge_entries.append(entry)
                            self._e_label_index[entry.label] = entry.id
                    self._valid_vertices = schema["valid_vertices"]
                    self._valid_edges = schema["valid_edges"]
            except Exception as e:
                raise ValueError("Invalid property graph schema") from e

    def init_nx_schema(self, gs_schema=None):
        """Schema for `nx.Graph`

        Args:
            gs_schema (`GraphSchema`, optional): schema of a graphscope `Graph`. Defaults to None.
        """
        if gs_schema is not None:
            for entry in gs_schema._valid_vertex_entries():
                for props in entry.properties:
                    if props.name not in self._vertex_entries[0]._prop_index:
                        self._vertex_entries[0].add_property(props.name, props.type)
            for entry in gs_schema._valid_edge_entries():
                for props in entry.properties:
                    if props.name not in self._edge_entries[0]._prop_index:
                        self._edge_entries[0].add_property(props.name, props.type)
        else:
            self._vertex_entries.append(Entry(0, "_"))
            self._v_label_index["_"] = 0
            self._edge_entries.append(Entry(0, "_"))
            self._e_label_index["_"] = 0
            self._edge_entries[0].add_relation("_", "_")
            self._valid_vertices = [1]
            self._valid_edges = [1]

    def __repr__(self):
        s = f"oid_type: {self._oid_type}\nvid_type: {self._vid_type}\n"
        if (
            self._vdata_type != types_pb2.INVALID
            and self._edata_type != types_pb2.INVALID
        ):
            s += f"vdata_type: {types_pb2.DataType.Name(self._vdata_type)}\n"
            s += f"edata_type: {types_pb2.DataType.Name(self._edata_type)}\n"
        for entry in self._valid_vertex_entries():
            s += f"type: VERTEX\n{str(entry)}\n"
        for entry in self._valid_edge_entries():
            s += f"type: EDGE\n{str(entry)}\n"
        return s

    def __str__(self):
        return self.__repr__()

    @property
    def oid_type(self):
        return self._oid_type

    @property
    def vid_type(self):
        return self._vid_type

    @property
    def vdata_type(self):
        # NB: simple graph only contain a single vertex property.
        return self._vdata_type

    @property
    def edata_type(self):
        # NB: simple graph only contain a single edge property.
        return self._edata_type

    def _valid_vertex_entries(self):
        return itertools.compress(self._vertex_entries, self._valid_vertices)

    def _valid_edge_entries(self):
        return itertools.compress(self._edge_entries, self._valid_edges)

    @property
    def vertex_labels(self):
        return [entry.label for entry in self._valid_vertex_entries()]

    @property
    def edge_labels(self):
        return [entry.label for entry in self._valid_edge_entries()]

    @property
    def edge_relationships(self):
        return [entry.relations for entry in self._valid_edge_entries()]

    def get_relationships(self, label):
        return self._edge_entries[self._e_label_index[label]].relations

    @property
    def vertex_label_num(self):
        return sum(self._valid_vertices)

    @property
    def edge_label_num(self):
        return sum(self._valid_edges)

    def get_vertex_properties(self, label):
        return self._vertex_entries[self.get_vertex_label_id(label)].properties

    def get_edge_properties(self, label):
        return self._edge_entries[self.get_edge_label_id(label)].properties

    def get_vertex_label_id(self, label):
        idx = self._v_label_index[label]
        if not self._valid_vertices[idx]:
            raise ValueError(f"Vertex {label} not exist in graph")
        return idx

    def get_edge_label_id(self, label):
        idx = self._e_label_index[label]
        if not self._valid_edges[idx]:
            raise ValueError(f"Edge {label} not exist in graph")
        return idx

    def get_vertex_property_id(self, label, prop):
        return self._vertex_entries[self.get_vertex_label_id(label)].get_property_id(
            prop
        )

    def get_edge_property_id(self, label, prop):
        return self._edge_entries[self.get_edge_label_id(label)].get_property_id(prop)

    def add_nx_vertex_properties(self, properties) -> bool:
        for key, value in properties.items():
            try:
                prop_type = unify_type(type(value))
                for prop in self._vertex_entries[0].properties:
                    if key == prop.name:
                        if prop_type != prop.type:
                            return False
                        break
                else:
                    self._vertex_entries[0].add_property(key, prop_type)
            except TypeError:
                return False
        return True

    def add_nx_edge_properties(self, properties) -> bool:
        for key, value in properties.items():
            try:
                prop_type = unify_type(type(value))
                for prop in self._edge_entries[0].properties:
                    if key == prop.name:
                        if prop_type != prop.type:
                            return False
                        break
                else:
                    self._edge_entries[0].add_property(key, prop_type)
            except TypeError:
                return False
        return True

    def clear(self):
        self._oid_type = None
        self._vid_type = None
        self._vdata_type = types_pb2.INVALID
        self._edata_type = types_pb2.INVALID

        self._vertex_entries.clear()
        self._edge_entries.clear()
        self._valid_vertices.clear()
        self._valid_edges.clear()
        self._v_label_index.clear()
        self._e_label_index.clear()

    def signature(self):
        return hashlib.sha256("{}".format(self.__repr__()).encode("utf-8")).hexdigest()
