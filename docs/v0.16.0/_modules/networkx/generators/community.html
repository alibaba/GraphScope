<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>networkx.generators.community &mdash; GraphScope  documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/custom.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />

 

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-4TMYCGJ0X2"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-4TMYCGJ0X2');
</script>

<script>
  var _hmt = _hmt || [];
  (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?da649ade2298891886e31922dfc8870f";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();
</script>


</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../index.html" class="icon icon-home"> GraphScope
          </a>
              <div class="version">
                v0.16.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div>
  <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
    
      
      
        
          
        
      
      
        <p class="caption"><span class="caption-text">Contents</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../getting_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../deployment.html">Deployment</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../loading_graph.html">Loading Graphs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../graph_transformation.html">Graph Transformations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../analytics_engine.html">GraphScope Analytical Engine</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../interactive_engine.html">GraphScope Interactive Engine</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../learning_engine.html">GraphScope Learning Engine</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../persistent_graph_store.html">Persistent Graph Store</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../frequently_asked_questions.html">Frequently Asked Questions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../developer_guide.html">Developer Guide</a></li>
</ul>
<p class="caption"><span class="caption-text">Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../reference/python_index.html">Python API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../reference/analytical_engine_index.html">Analytical Engine API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../reference/gae_java/index.html">Analytical Engine Java API Reference</a></li>
</ul>

      
    
  </div>

      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">GraphScope</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../../index.html">Module code</a> &raquo;</li>
      <li>networkx.generators.community</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for networkx.generators.community</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Generators for classes of graphs used in studying social networks.&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">from</span> <span class="nn">networkx.utils</span> <span class="kn">import</span> <span class="n">py_random_state</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;caveman_graph&quot;</span><span class="p">,</span>
    <span class="s2">&quot;connected_caveman_graph&quot;</span><span class="p">,</span>
    <span class="s2">&quot;relaxed_caveman_graph&quot;</span><span class="p">,</span>
    <span class="s2">&quot;random_partition_graph&quot;</span><span class="p">,</span>
    <span class="s2">&quot;planted_partition_graph&quot;</span><span class="p">,</span>
    <span class="s2">&quot;gaussian_random_partition_graph&quot;</span><span class="p">,</span>
    <span class="s2">&quot;ring_of_cliques&quot;</span><span class="p">,</span>
    <span class="s2">&quot;windmill_graph&quot;</span><span class="p">,</span>
    <span class="s2">&quot;stochastic_block_model&quot;</span><span class="p">,</span>
    <span class="s2">&quot;LFR_benchmark_graph&quot;</span><span class="p">,</span>
<span class="p">]</span>


<div class="viewcode-block" id="caveman_graph"><a class="viewcode-back" href="../../../reference/networkx/generated/graphscope.nx.generators.community.caveman_graph.html#graphscope.nx.generators.community.caveman_graph">[docs]</a><span class="k">def</span> <span class="nf">caveman_graph</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns a caveman graph of `l` cliques of size `k`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    l : int</span>
<span class="sd">      Number of cliques</span>
<span class="sd">    k : int</span>
<span class="sd">      Size of cliques</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    G : NetworkX Graph</span>
<span class="sd">      caveman graph</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This returns an undirected graph, it can be converted to a directed</span>
<span class="sd">    graph using :func:`nx.to_directed`, or a multigraph using</span>
<span class="sd">    ``nx.MultiGraph(nx.caveman_graph(l, k))``. Only the undirected version is</span>
<span class="sd">    described in [1]_ and it is unclear which of the directed</span>
<span class="sd">    generalizations is most useful.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; G = nx.caveman_graph(3, 3)</span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>

<span class="sd">    connected_caveman_graph</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Watts, D. J. &#39;Networks, Dynamics, and the Small-World Phenomenon.&#39;</span>
<span class="sd">       Amer. J. Soc. 105, 493-527, 1999.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># l disjoint cliques of size k</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">empty_graph</span><span class="p">(</span><span class="n">l</span> <span class="o">*</span> <span class="n">k</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">start</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">l</span> <span class="o">*</span> <span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
            <span class="n">edges</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">start</span> <span class="o">+</span> <span class="n">k</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">G</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">G</span></div>


<div class="viewcode-block" id="connected_caveman_graph"><a class="viewcode-back" href="../../../reference/networkx/generated/graphscope.nx.generators.community.connected_caveman_graph.html#graphscope.nx.generators.community.connected_caveman_graph">[docs]</a><span class="k">def</span> <span class="nf">connected_caveman_graph</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns a connected caveman graph of `l` cliques of size `k`.</span>

<span class="sd">    The connected caveman graph is formed by creating `n` cliques of size</span>
<span class="sd">    `k`, then a single edge in each clique is rewired to a node in an</span>
<span class="sd">    adjacent clique.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    l : int</span>
<span class="sd">      number of cliques</span>
<span class="sd">    k : int</span>
<span class="sd">      size of cliques (k at least 2 or NetworkXError is raised)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    G : NetworkX Graph</span>
<span class="sd">      connected caveman graph</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    NetworkXError</span>
<span class="sd">        If the size of cliques `k` is smaller than 2.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This returns an undirected graph, it can be converted to a directed</span>
<span class="sd">    graph using :func:`nx.to_directed`, or a multigraph using</span>
<span class="sd">    ``nx.MultiGraph(nx.caveman_graph(l, k))``. Only the undirected version is</span>
<span class="sd">    described in [1]_ and it is unclear which of the directed</span>
<span class="sd">    generalizations is most useful.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; G = nx.connected_caveman_graph(3, 3)</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Watts, D. J. &#39;Networks, Dynamics, and the Small-World Phenomenon.&#39;</span>
<span class="sd">       Amer. J. Soc. 105, 493-527, 1999.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">nx</span><span class="o">.</span><span class="n">NetworkXError</span><span class="p">(</span>
            <span class="s2">&quot;The size of cliques in a connected caveman graph &quot;</span> <span class="s2">&quot;must be at least 2.&quot;</span>
        <span class="p">)</span>

    <span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">caveman_graph</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">start</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">l</span> <span class="o">*</span> <span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
        <span class="n">G</span><span class="o">.</span><span class="n">remove_edge</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="p">(</span><span class="n">start</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="n">l</span> <span class="o">*</span> <span class="n">k</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">G</span></div>


<div class="viewcode-block" id="relaxed_caveman_graph"><a class="viewcode-back" href="../../../reference/networkx/generated/graphscope.nx.generators.community.relaxed_caveman_graph.html#graphscope.nx.generators.community.relaxed_caveman_graph">[docs]</a><span class="nd">@py_random_state</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">relaxed_caveman_graph</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns a relaxed caveman graph.</span>

<span class="sd">    A relaxed caveman graph starts with `l` cliques of size `k`.  Edges are</span>
<span class="sd">    then randomly rewired with probability `p` to link different cliques.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    l : int</span>
<span class="sd">      Number of groups</span>
<span class="sd">    k : int</span>
<span class="sd">      Size of cliques</span>
<span class="sd">    p : float</span>
<span class="sd">      Probabilty of rewiring each edge.</span>
<span class="sd">    seed : integer, random_state, or None (default)</span>
<span class="sd">        Indicator of random number generation state.</span>
<span class="sd">        See :ref:`Randomness&lt;randomness&gt;`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    G : NetworkX Graph</span>
<span class="sd">      Relaxed Caveman Graph</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    NetworkXError</span>
<span class="sd">     If p is not in [0,1]</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; G = nx.relaxed_caveman_graph(2, 3, 0.1, seed=42)</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Santo Fortunato, Community Detection in Graphs,</span>
<span class="sd">       Physics Reports Volume 486, Issues 3-5, February 2010, Pages 75-174.</span>
<span class="sd">       https://arxiv.org/abs/0906.0612</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">caveman_graph</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
    <span class="n">nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">seed</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">p</span><span class="p">:</span>  <span class="c1"># rewire the edge</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">seed</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">G</span><span class="o">.</span><span class="n">has_edge</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="n">G</span><span class="o">.</span><span class="n">remove_edge</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
            <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">G</span></div>


<div class="viewcode-block" id="random_partition_graph"><a class="viewcode-back" href="../../../reference/networkx/generated/graphscope.nx.generators.community.random_partition_graph.html#graphscope.nx.generators.community.random_partition_graph">[docs]</a><span class="nd">@py_random_state</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">random_partition_graph</span><span class="p">(</span><span class="n">sizes</span><span class="p">,</span> <span class="n">p_in</span><span class="p">,</span> <span class="n">p_out</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns the random partition graph with a partition of sizes.</span>

<span class="sd">    A partition graph is a graph of communities with sizes defined by</span>
<span class="sd">    s in sizes. Nodes in the same group are connected with probability</span>
<span class="sd">    p_in and nodes of different groups are connected with probability</span>
<span class="sd">    p_out.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    sizes : list of ints</span>
<span class="sd">      Sizes of groups</span>
<span class="sd">    p_in : float</span>
<span class="sd">      probability of edges with in groups</span>
<span class="sd">    p_out : float</span>
<span class="sd">      probability of edges between groups</span>
<span class="sd">    directed : boolean optional, default=False</span>
<span class="sd">      Whether to create a directed graph</span>
<span class="sd">    seed : integer, random_state, or None (default)</span>
<span class="sd">        Indicator of random number generation state.</span>
<span class="sd">        See :ref:`Randomness&lt;randomness&gt;`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    G : NetworkX Graph or DiGraph</span>
<span class="sd">      random partition graph of size sum(gs)</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    NetworkXError</span>
<span class="sd">      If p_in or p_out is not in [0,1]</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; G = nx.random_partition_graph([10, 10, 10], 0.25, 0.01)</span>
<span class="sd">    &gt;&gt;&gt; len(G)</span>
<span class="sd">    30</span>
<span class="sd">    &gt;&gt;&gt; partition = G.graph[&quot;partition&quot;]</span>
<span class="sd">    &gt;&gt;&gt; len(partition)</span>
<span class="sd">    3</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This is a generalization of the planted-l-partition described in</span>
<span class="sd">    [1]_.  It allows for the creation of groups of any size.</span>

<span class="sd">    The partition is store as a graph attribute &#39;partition&#39;.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Santo Fortunato &#39;Community Detection in Graphs&#39; Physical Reports</span>
<span class="sd">       Volume 486, Issue 3-5 p. 75-174. https://arxiv.org/abs/0906.0612</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Use geometric method for O(n+m) complexity algorithm</span>
    <span class="c1"># partition = nx.community_sets(nx.get_node_attributes(G, &#39;affiliation&#39;))</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="mf">0.0</span> <span class="o">&lt;=</span> <span class="n">p_in</span> <span class="o">&lt;=</span> <span class="mf">1.0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">nx</span><span class="o">.</span><span class="n">NetworkXError</span><span class="p">(</span><span class="s2">&quot;p_in must be in [0,1]&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="mf">0.0</span> <span class="o">&lt;=</span> <span class="n">p_out</span> <span class="o">&lt;=</span> <span class="mf">1.0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">nx</span><span class="o">.</span><span class="n">NetworkXError</span><span class="p">(</span><span class="s2">&quot;p_out must be in [0,1]&quot;</span><span class="p">)</span>

    <span class="c1"># create connection matrix</span>
    <span class="n">num_blocks</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sizes</span><span class="p">)</span>
    <span class="n">p</span> <span class="o">=</span> <span class="p">[[</span><span class="n">p_out</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_blocks</span><span class="p">)]</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_blocks</span><span class="p">)]</span>
    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_blocks</span><span class="p">):</span>
        <span class="n">p</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_in</span>

    <span class="k">return</span> <span class="n">stochastic_block_model</span><span class="p">(</span>
        <span class="n">sizes</span><span class="p">,</span>
        <span class="n">p</span><span class="p">,</span>
        <span class="n">nodelist</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">,</span>
        <span class="n">directed</span><span class="o">=</span><span class="n">directed</span><span class="p">,</span>
        <span class="n">selfloops</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="planted_partition_graph"><a class="viewcode-back" href="../../../reference/networkx/generated/graphscope.nx.generators.community.planted_partition_graph.html#graphscope.nx.generators.community.planted_partition_graph">[docs]</a><span class="nd">@py_random_state</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">planted_partition_graph</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">p_in</span><span class="p">,</span> <span class="n">p_out</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns the planted l-partition graph.</span>

<span class="sd">    This model partitions a graph with n=l*k vertices in</span>
<span class="sd">    l groups with k vertices each. Vertices of the same</span>
<span class="sd">    group are linked with a probability p_in, and vertices</span>
<span class="sd">    of different groups are linked with probability p_out.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    l : int</span>
<span class="sd">      Number of groups</span>
<span class="sd">    k : int</span>
<span class="sd">      Number of vertices in each group</span>
<span class="sd">    p_in : float</span>
<span class="sd">      probability of connecting vertices within a group</span>
<span class="sd">    p_out : float</span>
<span class="sd">      probability of connected vertices between groups</span>
<span class="sd">    seed : integer, random_state, or None (default)</span>
<span class="sd">        Indicator of random number generation state.</span>
<span class="sd">        See :ref:`Randomness&lt;randomness&gt;`.</span>
<span class="sd">    directed : bool,optional (default=False)</span>
<span class="sd">      If True return a directed graph</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    G : NetworkX Graph or DiGraph</span>
<span class="sd">      planted l-partition graph</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    NetworkXError</span>
<span class="sd">      If p_in,p_out are not in [0,1] or</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; G = nx.planted_partition_graph(4, 3, 0.5, 0.1, seed=42)</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    random_partition_model</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] A. Condon, R.M. Karp, Algorithms for graph partitioning</span>
<span class="sd">        on the planted partition model,</span>
<span class="sd">        Random Struct. Algor. 18 (2001) 116-140.</span>

<span class="sd">    .. [2] Santo Fortunato &#39;Community Detection in Graphs&#39; Physical Reports</span>
<span class="sd">       Volume 486, Issue 3-5 p. 75-174. https://arxiv.org/abs/0906.0612</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">random_partition_graph</span><span class="p">([</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">l</span><span class="p">,</span> <span class="n">p_in</span><span class="p">,</span> <span class="n">p_out</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="n">directed</span><span class="p">)</span></div>


<div class="viewcode-block" id="gaussian_random_partition_graph"><a class="viewcode-back" href="../../../reference/networkx/generated/graphscope.nx.generators.community.gaussian_random_partition_graph.html#graphscope.nx.generators.community.gaussian_random_partition_graph">[docs]</a><span class="nd">@py_random_state</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">gaussian_random_partition_graph</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">p_in</span><span class="p">,</span> <span class="n">p_out</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generate a Gaussian random partition graph.</span>

<span class="sd">    A Gaussian random partition graph is created by creating k partitions</span>
<span class="sd">    each with a size drawn from a normal distribution with mean s and variance</span>
<span class="sd">    s/v. Nodes are connected within clusters with probability p_in and</span>
<span class="sd">    between clusters with probability p_out[1]</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int</span>
<span class="sd">      Number of nodes in the graph</span>
<span class="sd">    s : float</span>
<span class="sd">      Mean cluster size</span>
<span class="sd">    v : float</span>
<span class="sd">      Shape parameter. The variance of cluster size distribution is s/v.</span>
<span class="sd">    p_in : float</span>
<span class="sd">      Probabilty of intra cluster connection.</span>
<span class="sd">    p_out : float</span>
<span class="sd">      Probability of inter cluster connection.</span>
<span class="sd">    directed : boolean, optional default=False</span>
<span class="sd">      Whether to create a directed graph or not</span>
<span class="sd">    seed : integer, random_state, or None (default)</span>
<span class="sd">        Indicator of random number generation state.</span>
<span class="sd">        See :ref:`Randomness&lt;randomness&gt;`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    G : NetworkX Graph or DiGraph</span>
<span class="sd">      gaussian random partition graph</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    NetworkXError</span>
<span class="sd">      If s is &gt; n</span>
<span class="sd">      If p_in or p_out is not in [0,1]</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Note the number of partitions is dependent on s,v and n, and that the</span>
<span class="sd">    last partition may be considerably smaller, as it is sized to simply</span>
<span class="sd">    fill out the nodes [1]</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    random_partition_graph</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; G = nx.gaussian_random_partition_graph(100, 10, 10, 0.25, 0.1)</span>
<span class="sd">    &gt;&gt;&gt; len(G)</span>
<span class="sd">    100</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Ulrik Brandes, Marco Gaertler, Dorothea Wagner,</span>
<span class="sd">       Experiments on Graph Clustering Algorithms,</span>
<span class="sd">       In the proceedings of the 11th Europ. Symp. Algorithms, 2003.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">s</span> <span class="o">&gt;</span> <span class="n">n</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">nx</span><span class="o">.</span><span class="n">NetworkXError</span><span class="p">(</span><span class="s2">&quot;s must be &lt;= n&quot;</span><span class="p">)</span>
    <span class="n">assigned</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">sizes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">seed</span><span class="o">.</span><span class="n">gauss</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">/</span> <span class="n">v</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">size</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># how to handle 0 or negative sizes?</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="n">assigned</span> <span class="o">+</span> <span class="n">size</span> <span class="o">&gt;=</span> <span class="n">n</span><span class="p">:</span>
            <span class="n">sizes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">assigned</span><span class="p">)</span>
            <span class="k">break</span>
        <span class="n">assigned</span> <span class="o">+=</span> <span class="n">size</span>
        <span class="n">sizes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">random_partition_graph</span><span class="p">(</span><span class="n">sizes</span><span class="p">,</span> <span class="n">p_in</span><span class="p">,</span> <span class="n">p_out</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="n">directed</span><span class="p">)</span></div>


<div class="viewcode-block" id="ring_of_cliques"><a class="viewcode-back" href="../../../reference/networkx/generated/graphscope.nx.generators.community.ring_of_cliques.html#graphscope.nx.generators.community.ring_of_cliques">[docs]</a><span class="k">def</span> <span class="nf">ring_of_cliques</span><span class="p">(</span><span class="n">num_cliques</span><span class="p">,</span> <span class="n">clique_size</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Defines a &quot;ring of cliques&quot; graph.</span>

<span class="sd">    A ring of cliques graph is consisting of cliques, connected through single</span>
<span class="sd">    links. Each clique is a complete graph.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    num_cliques : int</span>
<span class="sd">        Number of cliques</span>
<span class="sd">    clique_size : int</span>
<span class="sd">        Size of cliques</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    G : NetworkX Graph</span>
<span class="sd">        ring of cliques graph</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    NetworkXError</span>
<span class="sd">        If the number of cliques is lower than 2 or</span>
<span class="sd">        if the size of cliques is smaller than 2.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; G = nx.ring_of_cliques(8, 4)</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    connected_caveman_graph</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The `connected_caveman_graph` graph removes a link from each clique to</span>
<span class="sd">    connect it with the next clique. Instead, the `ring_of_cliques` graph</span>
<span class="sd">    simply adds the link without removing any link from the cliques.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">num_cliques</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">nx</span><span class="o">.</span><span class="n">NetworkXError</span><span class="p">(</span><span class="s2">&quot;A ring of cliques must have at least &quot;</span> <span class="s2">&quot;two cliques&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">clique_size</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">nx</span><span class="o">.</span><span class="n">NetworkXError</span><span class="p">(</span><span class="s2">&quot;The cliques must have at least two nodes&quot;</span><span class="p">)</span>

    <span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_cliques</span><span class="p">):</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span>
            <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="n">clique_size</span><span class="p">,</span> <span class="n">i</span> <span class="o">*</span> <span class="n">clique_size</span> <span class="o">+</span> <span class="n">clique_size</span><span class="p">),</span> <span class="mi">2</span>
        <span class="p">)</span>
        <span class="n">G</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span>
        <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span>
            <span class="n">i</span> <span class="o">*</span> <span class="n">clique_size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">clique_size</span> <span class="o">%</span> <span class="p">(</span><span class="n">num_cliques</span> <span class="o">*</span> <span class="n">clique_size</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">G</span></div>


<div class="viewcode-block" id="windmill_graph"><a class="viewcode-back" href="../../../reference/networkx/generated/graphscope.nx.generators.community.windmill_graph.html#graphscope.nx.generators.community.windmill_graph">[docs]</a><span class="k">def</span> <span class="nf">windmill_graph</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generate a windmill graph.</span>
<span class="sd">    A windmill graph is a graph of `n` cliques each of size `k` that are all</span>
<span class="sd">    joined at one node.</span>
<span class="sd">    It can be thought of as taking a disjoint union of `n` cliques of size `k`,</span>
<span class="sd">    selecting one point from each, and contracting all of the selected points.</span>
<span class="sd">    Alternatively, one could generate `n` cliques of size `k-1` and one node</span>
<span class="sd">    that is connected to all other nodes in the graph.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int</span>
<span class="sd">        Number of cliques</span>
<span class="sd">    k : int</span>
<span class="sd">        Size of cliques</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    G : NetworkX Graph</span>
<span class="sd">        windmill graph with n cliques of size k</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    NetworkXError</span>
<span class="sd">        If the number of cliques is less than two</span>
<span class="sd">        If the size of the cliques are less than two</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; G = nx.windmill_graph(4, 5)</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The node labeled `0` will be the node connected to all other nodes.</span>
<span class="sd">    Note that windmill graphs are usually denoted `Wd(k,n)`, so the parameters</span>
<span class="sd">    are in the opposite order as the parameters of this method.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;A windmill graph must have at least two cliques&quot;</span>
        <span class="k">raise</span> <span class="n">nx</span><span class="o">.</span><span class="n">NetworkXError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">nx</span><span class="o">.</span><span class="n">NetworkXError</span><span class="p">(</span><span class="s2">&quot;The cliques must have at least two nodes&quot;</span><span class="p">)</span>

    <span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">disjoint_union_all</span><span class="p">(</span>
        <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span>
            <span class="p">[</span><span class="n">nx</span><span class="o">.</span><span class="n">complete_graph</span><span class="p">(</span><span class="n">k</span><span class="p">)],</span> <span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">complete_graph</span><span class="p">(</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
        <span class="p">)</span>
    <span class="p">)</span>
    <span class="n">G</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">G</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">()))</span>
    <span class="k">return</span> <span class="n">G</span></div>


<div class="viewcode-block" id="stochastic_block_model"><a class="viewcode-back" href="../../../reference/networkx/generated/graphscope.nx.generators.community.stochastic_block_model.html#graphscope.nx.generators.community.stochastic_block_model">[docs]</a><span class="nd">@py_random_state</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">stochastic_block_model</span><span class="p">(</span>
    <span class="n">sizes</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">nodelist</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">selfloops</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">True</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns a stochastic block model graph.</span>

<span class="sd">    This model partitions the nodes in blocks of arbitrary sizes, and places</span>
<span class="sd">    edges between pairs of nodes independently, with a probability that depends</span>
<span class="sd">    on the blocks.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    sizes : list of ints</span>
<span class="sd">        Sizes of blocks</span>
<span class="sd">    p : list of list of floats</span>
<span class="sd">        Element (r,s) gives the density of edges going from the nodes</span>
<span class="sd">        of group r to nodes of group s.</span>
<span class="sd">        p must match the number of groups (len(sizes) == len(p)),</span>
<span class="sd">        and it must be symmetric if the graph is undirected.</span>
<span class="sd">    nodelist : list, optional</span>
<span class="sd">        The block tags are assigned according to the node identifiers</span>
<span class="sd">        in nodelist. If nodelist is None, then the ordering is the</span>
<span class="sd">        range [0,sum(sizes)-1].</span>
<span class="sd">    seed : integer, random_state, or None (default)</span>
<span class="sd">        Indicator of random number generation state.</span>
<span class="sd">        See :ref:`Randomness&lt;randomness&gt;`.</span>
<span class="sd">    directed : boolean optional, default=False</span>
<span class="sd">        Whether to create a directed graph or not.</span>
<span class="sd">    selfloops : boolean optional, default=False</span>
<span class="sd">        Whether to include self-loops or not.</span>
<span class="sd">    sparse: boolean optional, default=True</span>
<span class="sd">        Use the sparse heuristic to speed up the generator.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    g : NetworkX Graph or DiGraph</span>
<span class="sd">        Stochastic block model graph of size sum(sizes)</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    NetworkXError</span>
<span class="sd">      If probabilities are not in [0,1].</span>
<span class="sd">      If the probability matrix is not square (directed case).</span>
<span class="sd">      If the probability matrix is not symmetric (undirected case).</span>
<span class="sd">      If the sizes list does not match nodelist or the probability matrix.</span>
<span class="sd">      If nodelist contains duplicate.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; sizes = [75, 75, 300]</span>
<span class="sd">    &gt;&gt;&gt; probs = [[0.25, 0.05, 0.02], [0.05, 0.35, 0.07], [0.02, 0.07, 0.40]]</span>
<span class="sd">    &gt;&gt;&gt; g = nx.stochastic_block_model(sizes, probs, seed=0)</span>
<span class="sd">    &gt;&gt;&gt; len(g)</span>
<span class="sd">    450</span>
<span class="sd">    &gt;&gt;&gt; H = nx.quotient_graph(g, g.graph[&quot;partition&quot;], relabel=True)</span>
<span class="sd">    &gt;&gt;&gt; for v in H.nodes(data=True):</span>
<span class="sd">    ...     print(round(v[1][&quot;density&quot;], 3))</span>
<span class="sd">    ...</span>
<span class="sd">    0.245</span>
<span class="sd">    0.348</span>
<span class="sd">    0.405</span>
<span class="sd">    &gt;&gt;&gt; for v in H.edges(data=True):</span>
<span class="sd">    ...     print(round(1.0 * v[2][&quot;weight&quot;] / (sizes[v[0]] * sizes[v[1]]), 3))</span>
<span class="sd">    ...</span>
<span class="sd">    0.051</span>
<span class="sd">    0.022</span>
<span class="sd">    0.07</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    random_partition_graph</span>
<span class="sd">    planted_partition_graph</span>
<span class="sd">    gaussian_random_partition_graph</span>
<span class="sd">    gnp_random_graph</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Holland, P. W., Laskey, K. B., &amp; Leinhardt, S.,</span>
<span class="sd">           &quot;Stochastic blockmodels: First steps&quot;,</span>
<span class="sd">           Social networks, 5(2), 109-137, 1983.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Check if dimensions match</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sizes</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">nx</span><span class="o">.</span><span class="n">NetworkXException</span><span class="p">(</span><span class="s2">&quot;&#39;sizes&#39; and &#39;p&#39; do not match.&quot;</span><span class="p">)</span>
    <span class="c1"># Check for probability symmetry (undirected) and shape (directed)</span>
    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">p</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">row</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">nx</span><span class="o">.</span><span class="n">NetworkXException</span><span class="p">(</span><span class="s2">&quot;&#39;p&#39; must be a square matrix.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">directed</span><span class="p">:</span>
        <span class="n">p_transpose</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">p_transpose</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">j</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">j</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mf">1e-08</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">nx</span><span class="o">.</span><span class="n">NetworkXException</span><span class="p">(</span><span class="s2">&quot;&#39;p&#39; must be symmetric.&quot;</span><span class="p">)</span>
    <span class="c1"># Check for probability range</span>
    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">p</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">prob</span> <span class="ow">in</span> <span class="n">row</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">prob</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">prob</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">nx</span><span class="o">.</span><span class="n">NetworkXException</span><span class="p">(</span><span class="s2">&quot;Entries of &#39;p&#39; not in [0,1].&quot;</span><span class="p">)</span>
    <span class="c1"># Check for nodelist consistency</span>
    <span class="k">if</span> <span class="n">nodelist</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodelist</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">sizes</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">nx</span><span class="o">.</span><span class="n">NetworkXException</span><span class="p">(</span><span class="s2">&quot;&#39;nodelist&#39; and &#39;sizes&#39; do not match.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodelist</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">nodelist</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="n">nx</span><span class="o">.</span><span class="n">NetworkXException</span><span class="p">(</span><span class="s2">&quot;nodelist contains duplicate.&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">nodelist</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">sum</span><span class="p">(</span><span class="n">sizes</span><span class="p">))</span>

    <span class="c1"># Setup the graph conditionally to the directed switch.</span>
    <span class="n">block_range</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sizes</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">directed</span><span class="p">:</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">()</span>
        <span class="n">block_iter</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">block_range</span><span class="p">,</span> <span class="n">block_range</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
        <span class="n">block_iter</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">combinations_with_replacement</span><span class="p">(</span><span class="n">block_range</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="c1"># Split nodelist in a partition (list of sets).</span>
    <span class="n">size_cumsum</span> <span class="o">=</span> <span class="p">[</span><span class="nb">sum</span><span class="p">(</span><span class="n">sizes</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">x</span><span class="p">])</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">sizes</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
    <span class="n">g</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="s2">&quot;partition&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
        <span class="nb">set</span><span class="p">(</span><span class="n">nodelist</span><span class="p">[</span><span class="n">size_cumsum</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="p">:</span> <span class="n">size_cumsum</span><span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]])</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">size_cumsum</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="p">]</span>
    <span class="c1"># Setup nodes and graph name</span>
    <span class="k">for</span> <span class="n">block_id</span><span class="p">,</span> <span class="n">nodes</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="s2">&quot;partition&quot;</span><span class="p">]):</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
            <span class="n">g</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="n">block_id</span><span class="p">)</span>

    <span class="n">g</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;stochastic_block_model&quot;</span>

    <span class="c1"># Test for edge existence</span>
    <span class="n">parts</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="s2">&quot;partition&quot;</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">block_iter</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">directed</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">selfloops</span><span class="p">:</span>
                    <span class="n">edges</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">parts</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">edges</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">permutations</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">edges</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">selfloops</span><span class="p">:</span>
                    <span class="n">edges</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span> <span class="nb">zip</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">parts</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">seed</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]:</span>
                    <span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="o">*</span><span class="n">e</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">edges</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">parts</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">sparse</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># Test edges cases p_ij = 0 or 1</span>
                <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
                    <span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="o">*</span><span class="n">e</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">logrand</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">seed</span><span class="o">.</span><span class="n">random</span><span class="p">())</span>
                        <span class="n">skip</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">logrand</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]))</span>
                        <span class="c1"># consume &quot;skip&quot; edges</span>
                        <span class="nb">next</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">islice</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span> <span class="n">skip</span><span class="p">,</span> <span class="n">skip</span><span class="p">),</span> <span class="kc">None</span><span class="p">)</span>
                        <span class="n">e</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span>
                        <span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="o">*</span><span class="n">e</span><span class="p">)</span>  <span class="c1"># __safe</span>
                    <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
                        <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">seed</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]:</span>
                    <span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="o">*</span><span class="n">e</span><span class="p">)</span>  <span class="c1"># __safe</span>
    <span class="k">return</span> <span class="n">g</span></div>


<span class="k">def</span> <span class="nf">_zipf_rv_below</span><span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">seed</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns a random value chosen from the bounded Zipf distribution.</span>

<span class="sd">    Repeatedly draws values from the Zipf distribution until the</span>
<span class="sd">    threshold is met, then returns that value.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">zipf_rv</span><span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">seed</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">result</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">zipf_rv</span><span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">seed</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">_powerlaw_sequence</span><span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">,</span> <span class="n">condition</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">max_iters</span><span class="p">,</span> <span class="n">seed</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns a list of numbers obeying a constrained power law distribution.</span>

<span class="sd">    ``gamma`` and ``low`` are the parameters for the Zipf distribution.</span>

<span class="sd">    ``high`` is the maximum allowed value for values draw from the Zipf</span>
<span class="sd">    distribution. For more information, see :func:`_zipf_rv_below`.</span>

<span class="sd">    ``condition`` and ``length`` are Boolean-valued functions on</span>
<span class="sd">    lists. While generating the list, random values are drawn and</span>
<span class="sd">    appended to the list until ``length`` is satisfied by the created</span>
<span class="sd">    list. Once ``condition`` is satisfied, the sequence generated in</span>
<span class="sd">    this way is returned.</span>

<span class="sd">    ``max_iters`` indicates the number of times to generate a list</span>
<span class="sd">    satisfying ``length``. If the number of iterations exceeds this</span>
<span class="sd">    value, :exc:`~networkx.exception.ExceededMaxIterations` is raised.</span>

<span class="sd">    seed : integer, random_state, or None (default)</span>
<span class="sd">        Indicator of random number generation state.</span>
<span class="sd">        See :ref:`Randomness&lt;randomness&gt;`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_iters</span><span class="p">):</span>
        <span class="n">seq</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="n">length</span><span class="p">(</span><span class="n">seq</span><span class="p">):</span>
            <span class="n">seq</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_zipf_rv_below</span><span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">,</span> <span class="n">seed</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">condition</span><span class="p">(</span><span class="n">seq</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">seq</span>
    <span class="k">raise</span> <span class="n">nx</span><span class="o">.</span><span class="n">ExceededMaxIterations</span><span class="p">(</span><span class="s2">&quot;Could not create power law sequence&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_hurwitz_zeta</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;The Hurwitz zeta function, or the Riemann zeta function of two arguments.</span>

<span class="sd">    ``x`` must be greater than one and ``q`` must be positive.</span>

<span class="sd">    This function repeatedly computes subsequent partial sums until</span>
<span class="sd">    convergence, as decided by ``tolerance``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">z</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">z_prev</span> <span class="o">=</span> <span class="o">-</span><span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">)</span>
    <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="nb">abs</span><span class="p">(</span><span class="n">z</span> <span class="o">-</span> <span class="n">z_prev</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">tolerance</span><span class="p">:</span>
        <span class="n">z_prev</span> <span class="o">=</span> <span class="n">z</span>
        <span class="n">z</span> <span class="o">+=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">((</span><span class="n">k</span> <span class="o">+</span> <span class="n">q</span><span class="p">)</span> <span class="o">**</span> <span class="n">x</span><span class="p">)</span>
        <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">z</span>


<span class="k">def</span> <span class="nf">_generate_min_degree</span><span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="n">average_degree</span><span class="p">,</span> <span class="n">max_degree</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">,</span> <span class="n">max_iters</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns a minimum degree from the given average degree.&quot;&quot;&quot;</span>
    <span class="c1"># Defines zeta function whether or not Scipy is available</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">scipy.special</span> <span class="kn">import</span> <span class="n">zeta</span>
    <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>

        <span class="k">def</span> <span class="nf">zeta</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">q</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">_hurwitz_zeta</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>

    <span class="n">min_deg_top</span> <span class="o">=</span> <span class="n">max_degree</span>
    <span class="n">min_deg_bot</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">min_deg_mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">min_deg_top</span> <span class="o">-</span> <span class="n">min_deg_bot</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">min_deg_bot</span>
    <span class="n">itrs</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">mid_avg_deg</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="nb">abs</span><span class="p">(</span><span class="n">mid_avg_deg</span> <span class="o">-</span> <span class="n">average_degree</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">tolerance</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">itrs</span> <span class="o">&gt;</span> <span class="n">max_iters</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">nx</span><span class="o">.</span><span class="n">ExceededMaxIterations</span><span class="p">(</span><span class="s2">&quot;Could not match average_degree&quot;</span><span class="p">)</span>
        <span class="n">mid_avg_deg</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">min_deg_mid</span><span class="p">),</span> <span class="n">max_degree</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">mid_avg_deg</span> <span class="o">+=</span> <span class="p">(</span><span class="n">x</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="n">gamma</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">/</span> <span class="n">zeta</span><span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="n">min_deg_mid</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mid_avg_deg</span> <span class="o">&gt;</span> <span class="n">average_degree</span><span class="p">:</span>
            <span class="n">min_deg_top</span> <span class="o">=</span> <span class="n">min_deg_mid</span>
            <span class="n">min_deg_mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">min_deg_top</span> <span class="o">-</span> <span class="n">min_deg_bot</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">min_deg_bot</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">min_deg_bot</span> <span class="o">=</span> <span class="n">min_deg_mid</span>
            <span class="n">min_deg_mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">min_deg_top</span> <span class="o">-</span> <span class="n">min_deg_bot</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">min_deg_bot</span>
        <span class="n">itrs</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="c1"># return int(min_deg_mid + 0.5)</span>
    <span class="k">return</span> <span class="nb">round</span><span class="p">(</span><span class="n">min_deg_mid</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_generate_communities</span><span class="p">(</span><span class="n">degree_seq</span><span class="p">,</span> <span class="n">community_sizes</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">max_iters</span><span class="p">,</span> <span class="n">seed</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns a list of sets, each of which represents a community.</span>

<span class="sd">    ``degree_seq`` is the degree sequence that must be met by the</span>
<span class="sd">    graph.</span>

<span class="sd">    ``community_sizes`` is the community size distribution that must be</span>
<span class="sd">    met by the generated list of sets.</span>

<span class="sd">    ``mu`` is a float in the interval [0, 1] indicating the fraction of</span>
<span class="sd">    intra-community edges incident to each node.</span>

<span class="sd">    ``max_iters`` is the number of times to try to add a node to a</span>
<span class="sd">    community. This must be greater than the length of</span>
<span class="sd">    ``degree_seq``, otherwise this function will always fail. If</span>
<span class="sd">    the number of iterations exceeds this value,</span>
<span class="sd">    :exc:`~networkx.exception.ExceededMaxIterations` is raised.</span>

<span class="sd">    seed : integer, random_state, or None (default)</span>
<span class="sd">        Indicator of random number generation state.</span>
<span class="sd">        See :ref:`Randomness&lt;randomness&gt;`.</span>

<span class="sd">    The communities returned by this are sets of integers in the set {0,</span>
<span class="sd">    ..., *n* - 1}, where *n* is the length of ``degree_seq``.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># This assumes the nodes in the graph will be natural numbers.</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="nb">set</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">community_sizes</span><span class="p">]</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">degree_seq</span><span class="p">)</span>
    <span class="n">free</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_iters</span><span class="p">):</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">free</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">seed</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">community_sizes</span><span class="p">)))</span>
        <span class="c1"># s = int(degree_seq[v] * (1 - mu) + 0.5)</span>
        <span class="n">s</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">degree_seq</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">mu</span><span class="p">))</span>
        <span class="c1"># If the community is large enough, add the node to the chosen</span>
        <span class="c1"># community. Otherwise, return it to the list of unaffiliated</span>
        <span class="c1"># nodes.</span>
        <span class="k">if</span> <span class="n">s</span> <span class="o">&lt;</span> <span class="n">community_sizes</span><span class="p">[</span><span class="n">c</span><span class="p">]:</span>
            <span class="n">result</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">free</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="c1"># If the community is too big, remove a node from it.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="n">c</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">community_sizes</span><span class="p">[</span><span class="n">c</span><span class="p">]:</span>
            <span class="n">free</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">())</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">free</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Could not assign communities; try increasing min_community&quot;</span>
    <span class="k">raise</span> <span class="n">nx</span><span class="o">.</span><span class="n">ExceededMaxIterations</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>


<div class="viewcode-block" id="LFR_benchmark_graph"><a class="viewcode-back" href="../../../reference/networkx/generated/graphscope.nx.generators.community.LFR_benchmark_graph.html#graphscope.nx.generators.community.LFR_benchmark_graph">[docs]</a><span class="nd">@py_random_state</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">LFR_benchmark_graph</span><span class="p">(</span>
    <span class="n">n</span><span class="p">,</span>
    <span class="n">tau1</span><span class="p">,</span>
    <span class="n">tau2</span><span class="p">,</span>
    <span class="n">mu</span><span class="p">,</span>
    <span class="n">average_degree</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">min_degree</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">max_degree</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">min_community</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">max_community</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">tol</span><span class="o">=</span><span class="mf">1.0e-7</span><span class="p">,</span>
    <span class="n">max_iters</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span>
    <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Returns the LFR benchmark graph.</span>

<span class="sd">    This algorithm proceeds as follows:</span>

<span class="sd">    1) Find a degree sequence with a power law distribution, and minimum</span>
<span class="sd">       value ``min_degree``, which has approximate average degree</span>
<span class="sd">       ``average_degree``. This is accomplished by either</span>

<span class="sd">       a) specifying ``min_degree`` and not ``average_degree``,</span>
<span class="sd">       b) specifying ``average_degree`` and not ``min_degree``, in which</span>
<span class="sd">          case a suitable minimum degree will be found.</span>

<span class="sd">       ``max_degree`` can also be specified, otherwise it will be set to</span>
<span class="sd">       ``n``. Each node *u* will have `\mu \mathrm{deg}(u)` edges</span>
<span class="sd">       joining it to nodes in communities other than its own and `(1 -</span>
<span class="sd">       \mu) \mathrm{deg}(u)` edges joining it to nodes in its own</span>
<span class="sd">       community.</span>
<span class="sd">    2) Generate community sizes according to a power law distribution</span>
<span class="sd">       with exponent ``tau2``. If ``min_community`` and</span>
<span class="sd">       ``max_community`` are not specified they will be selected to be</span>
<span class="sd">       ``min_degree`` and ``max_degree``, respectively.  Community sizes</span>
<span class="sd">       are generated until the sum of their sizes equals ``n``.</span>
<span class="sd">    3) Each node will be randomly assigned a community with the</span>
<span class="sd">       condition that the community is large enough for the node&#39;s</span>
<span class="sd">       intra-community degree, `(1 - \mu) \mathrm{deg}(u)` as</span>
<span class="sd">       described in step 2. If a community grows too large, a random node</span>
<span class="sd">       will be selected for reassignment to a new community, until all</span>
<span class="sd">       nodes have been assigned a community.</span>
<span class="sd">    4) Each node *u* then adds `(1 - \mu) \mathrm{deg}(u)`</span>
<span class="sd">       intra-community edges and `\mu \mathrm{deg}(u)` inter-community</span>
<span class="sd">       edges.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int</span>
<span class="sd">        Number of nodes in the created graph.</span>

<span class="sd">    tau1 : float</span>
<span class="sd">        Power law exponent for the degree distribution of the created</span>
<span class="sd">        graph. This value must be strictly greater than one.</span>

<span class="sd">    tau2 : float</span>
<span class="sd">        Power law exponent for the community size distribution in the</span>
<span class="sd">        created graph. This value must be strictly greater than one.</span>

<span class="sd">    mu : float</span>
<span class="sd">        Fraction of inter-community edges incident to each node. This</span>
<span class="sd">        value must be in the interval [0, 1].</span>

<span class="sd">    average_degree : float</span>
<span class="sd">        Desired average degree of nodes in the created graph. This value</span>
<span class="sd">        must be in the interval [0, *n*]. Exactly one of this and</span>
<span class="sd">        ``min_degree`` must be specified, otherwise a</span>
<span class="sd">        :exc:`NetworkXError` is raised.</span>

<span class="sd">    min_degree : int</span>
<span class="sd">        Minimum degree of nodes in the created graph. This value must be</span>
<span class="sd">        in the interval [0, *n*]. Exactly one of this and</span>
<span class="sd">        ``average_degree`` must be specified, otherwise a</span>
<span class="sd">        :exc:`NetworkXError` is raised.</span>

<span class="sd">    max_degree : int</span>
<span class="sd">        Maximum degree of nodes in the created graph. If not specified,</span>
<span class="sd">        this is set to ``n``, the total number of nodes in the graph.</span>

<span class="sd">    min_community : int</span>
<span class="sd">        Minimum size of communities in the graph. If not specified, this</span>
<span class="sd">        is set to ``min_degree``.</span>

<span class="sd">    max_community : int</span>
<span class="sd">        Maximum size of communities in the graph. If not specified, this</span>
<span class="sd">        is set to ``n``, the total number of nodes in the graph.</span>

<span class="sd">    tol : float</span>
<span class="sd">        Tolerance when comparing floats, specifically when comparing</span>
<span class="sd">        average degree values.</span>

<span class="sd">    max_iters : int</span>
<span class="sd">        Maximum number of iterations to try to create the community sizes,</span>
<span class="sd">        degree distribution, and community affiliations.</span>

<span class="sd">    seed : integer, random_state, or None (default)</span>
<span class="sd">        Indicator of random number generation state.</span>
<span class="sd">        See :ref:`Randomness&lt;randomness&gt;`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    G : NetworkX graph</span>
<span class="sd">        The LFR benchmark graph generated according to the specified</span>
<span class="sd">        parameters.</span>

<span class="sd">        Each node in the graph has a node attribute ``&#39;community&#39;`` that</span>
<span class="sd">        stores the community (that is, the set of nodes) that includes</span>
<span class="sd">        it.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    NetworkXError</span>
<span class="sd">        If any of the parameters do not meet their upper and lower bounds:</span>

<span class="sd">        - ``tau1`` and ``tau2`` must be strictly greater than 1.</span>
<span class="sd">        - ``mu`` must be in [0, 1].</span>
<span class="sd">        - ``max_degree`` must be in {1, ..., *n*}.</span>
<span class="sd">        - ``min_community`` and ``max_community`` must be in {0, ...,</span>
<span class="sd">          *n*}.</span>

<span class="sd">        If not exactly one of ``average_degree`` and ``min_degree`` is</span>
<span class="sd">        specified.</span>

<span class="sd">        If ``min_degree`` is not specified and a suitable ``min_degree``</span>
<span class="sd">        cannot be found.</span>

<span class="sd">    ExceededMaxIterations</span>
<span class="sd">        If a valid degree sequence cannot be created within</span>
<span class="sd">        ``max_iters`` number of iterations.</span>

<span class="sd">        If a valid set of community sizes cannot be created within</span>
<span class="sd">        ``max_iters`` number of iterations.</span>

<span class="sd">        If a valid community assignment cannot be created within ``10 *</span>
<span class="sd">        n * max_iters`` number of iterations.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Basic usage::</span>

<span class="sd">        &gt;&gt;&gt; from networkx.generators.community import LFR_benchmark_graph</span>
<span class="sd">        &gt;&gt;&gt; n = 250</span>
<span class="sd">        &gt;&gt;&gt; tau1 = 3</span>
<span class="sd">        &gt;&gt;&gt; tau2 = 1.5</span>
<span class="sd">        &gt;&gt;&gt; mu = 0.1</span>
<span class="sd">        &gt;&gt;&gt; G = LFR_benchmark_graph(</span>
<span class="sd">        ...     n, tau1, tau2, mu, average_degree=5, min_community=20, seed=10</span>
<span class="sd">        ... )</span>

<span class="sd">    Continuing the example above, you can get the communities from the</span>
<span class="sd">    node attributes of the graph::</span>

<span class="sd">        &gt;&gt;&gt; communities = {frozenset(G.nodes[v][&quot;community&quot;]) for v in G}</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This algorithm differs slightly from the original way it was</span>
<span class="sd">    presented in [1].</span>

<span class="sd">    1) Rather than connecting the graph via a configuration model then</span>
<span class="sd">       rewiring to match the intra-community and inter-community</span>
<span class="sd">       degrees, we do this wiring explicitly at the end, which should be</span>
<span class="sd">       equivalent.</span>
<span class="sd">    2) The code posted on the author&#39;s website [2] calculates the random</span>
<span class="sd">       power law distributed variables and their average using</span>
<span class="sd">       continuous approximations, whereas we use the discrete</span>
<span class="sd">       distributions here as both degree and community size are</span>
<span class="sd">       discrete.</span>

<span class="sd">    Though the authors describe the algorithm as quite robust, testing</span>
<span class="sd">    during development indicates that a somewhat narrower parameter set</span>
<span class="sd">    is likely to successfully produce a graph. Some suggestions have</span>
<span class="sd">    been provided in the event of exceptions.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] &quot;Benchmark graphs for testing community detection algorithms&quot;,</span>
<span class="sd">           Andrea Lancichinetti, Santo Fortunato, and Filippo Radicchi,</span>
<span class="sd">           Phys. Rev. E 78, 046110 2008</span>
<span class="sd">    .. [2] https://www.santofortunato.net/resources</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Perform some basic parameter validation.</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">tau1</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">nx</span><span class="o">.</span><span class="n">NetworkXError</span><span class="p">(</span><span class="s2">&quot;tau1 must be greater than one&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">tau2</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">nx</span><span class="o">.</span><span class="n">NetworkXError</span><span class="p">(</span><span class="s2">&quot;tau2 must be greater than one&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">mu</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">nx</span><span class="o">.</span><span class="n">NetworkXError</span><span class="p">(</span><span class="s2">&quot;mu must be in the interval [0, 1]&quot;</span><span class="p">)</span>

    <span class="c1"># Validate parameters for generating the degree sequence.</span>
    <span class="k">if</span> <span class="n">max_degree</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">max_degree</span> <span class="o">=</span> <span class="n">n</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">max_degree</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">nx</span><span class="o">.</span><span class="n">NetworkXError</span><span class="p">(</span><span class="s2">&quot;max_degree must be in the interval (0, n]&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">((</span><span class="n">min_degree</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="o">^</span> <span class="p">(</span><span class="n">average_degree</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="n">nx</span><span class="o">.</span><span class="n">NetworkXError</span><span class="p">(</span>
            <span class="s2">&quot;Must assign exactly one of min_degree and&quot;</span> <span class="s2">&quot; average_degree&quot;</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="n">min_degree</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">min_degree</span> <span class="o">=</span> <span class="n">_generate_min_degree</span><span class="p">(</span>
            <span class="n">tau1</span><span class="p">,</span> <span class="n">average_degree</span><span class="p">,</span> <span class="n">max_degree</span><span class="p">,</span> <span class="n">tol</span><span class="p">,</span> <span class="n">max_iters</span>
        <span class="p">)</span>

    <span class="c1"># Generate a degree sequence with a power law distribution.</span>
    <span class="n">low</span><span class="p">,</span> <span class="n">high</span> <span class="o">=</span> <span class="n">min_degree</span><span class="p">,</span> <span class="n">max_degree</span>

    <span class="k">def</span> <span class="nf">condition</span><span class="p">(</span><span class="n">seq</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">length</span><span class="p">(</span><span class="n">seq</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">n</span>

    <span class="n">deg_seq</span> <span class="o">=</span> <span class="n">_powerlaw_sequence</span><span class="p">(</span><span class="n">tau1</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">,</span> <span class="n">condition</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">max_iters</span><span class="p">,</span> <span class="n">seed</span><span class="p">)</span>

    <span class="c1"># Validate parameters for generating the community size sequence.</span>
    <span class="k">if</span> <span class="n">min_community</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">min_community</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">deg_seq</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">max_community</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">max_community</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">deg_seq</span><span class="p">)</span>

    <span class="c1"># Generate a community size sequence with a power law distribution.</span>
    <span class="c1">#</span>
    <span class="c1"># TODO The original code incremented the number of iterations each</span>
    <span class="c1"># time a new Zipf random value was drawn from the distribution. This</span>
    <span class="c1"># differed from the way the number of iterations was incremented in</span>
    <span class="c1"># `_powerlaw_degree_sequence`, so this code was changed to match</span>
    <span class="c1"># that one. As a result, this code is allowed many more chances to</span>
    <span class="c1"># generate a valid community size sequence.</span>
    <span class="n">low</span><span class="p">,</span> <span class="n">high</span> <span class="o">=</span> <span class="n">min_community</span><span class="p">,</span> <span class="n">max_community</span>

    <span class="k">def</span> <span class="nf">condition</span><span class="p">(</span><span class="n">seq</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span> <span class="o">==</span> <span class="n">n</span>

    <span class="k">def</span> <span class="nf">length</span><span class="p">(</span><span class="n">seq</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">n</span>

    <span class="n">comms</span> <span class="o">=</span> <span class="n">_powerlaw_sequence</span><span class="p">(</span><span class="n">tau2</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">,</span> <span class="n">condition</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">max_iters</span><span class="p">,</span> <span class="n">seed</span><span class="p">)</span>

    <span class="c1"># Generate the communities based on the given degree sequence and</span>
    <span class="c1"># community sizes.</span>
    <span class="n">max_iters</span> <span class="o">*=</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">n</span>
    <span class="n">communities</span> <span class="o">=</span> <span class="n">_generate_communities</span><span class="p">(</span><span class="n">deg_seq</span><span class="p">,</span> <span class="n">comms</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">max_iters</span><span class="p">,</span> <span class="n">seed</span><span class="p">)</span>

    <span class="c1"># Finally, generate the benchmark graph based on the given</span>
    <span class="c1"># communities, joining nodes according to the intra- and</span>
    <span class="c1"># inter-community degrees.</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
    <span class="n">G</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">communities</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">c</span><span class="p">:</span>
            <span class="k">while</span> <span class="n">G</span><span class="o">.</span><span class="n">degree</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">round</span><span class="p">(</span><span class="n">deg_seq</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">mu</span><span class="p">)):</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">seed</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
                <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
            <span class="k">while</span> <span class="n">G</span><span class="o">.</span><span class="n">degree</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">deg_seq</span><span class="p">[</span><span class="n">u</span><span class="p">]:</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">seed</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">v</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">c</span><span class="p">:</span>
                    <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
            <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="s2">&quot;community&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span>
    <span class="k">return</span> <span class="n">G</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020-2023, DAMO Academy, Alibaba Inc..</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
  

  <div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      <span class="fa fa-book"> Read the Docs</span>
      v: v0.16.0
      <span class="fa fa-caret-down"></span>
    </span>
    <div class="rst-other-versions">
      <dl>
        <dt>Versions</dt>
        
          

            
              
                <dd><a href="../../../../latest/index.html">latest</a></dd>
              
            

          
        
          

            
              
                <dd><a href="../../../../index.html">stable</a></dd>
              
            

          
        
          

            
              
                <dd><a href="../../../../v0.16.0/index.html">v0.16.0</a></dd>
              
            

          
        
          

            
              
                <dd><a href="../../../../v0.15.0/index.html">v0.15.0</a></dd>
              
            

          
        
          

            
              
                <dd><a href="../../../../v0.14.0/index.html">v0.14.0</a></dd>
              
            

          
        
          

            
              
                <dd><a href="../../../../v0.13.0/index.html">v0.13.0</a></dd>
              
            

          
        
          

            
              
                <dd><a href="../../../../v0.12.0/index.html">v0.12.0</a></dd>
              
            

          
        
          

            
              
                <dd><a href="../../../../v0.11.0/index.html">v0.11.0</a></dd>
              
            

          
        
          

            
              
                <dd><a href="../../../../v0.10.1/index.html">v0.10.1</a></dd>
              
            

          
        
          

            
              
                <dd><a href="../../../../v0.10.0/index.html">v0.10.0</a></dd>
              
            

          
        
          

            
              
                <dd><a href="../../../../v0.9.1/index.html">v0.9.1</a></dd>
              
            

          
        
          

            
              
                <dd><a href="../../../../v0.9.0/index.html">v0.9.0</a></dd>
              
            

          
        
          

            
              
                <dd><a href="../../../../v0.8.0/index.html">v0.8.0</a></dd>
              
            

          
        
          

            
              
                <dd><a href="../../../../v0.7.0/index.html">v0.7.0</a></dd>
              
            

          
        
          

            
              
                <dd><a href="../../../../v0.6.1/index.html">v0.6.1</a></dd>
              
            

          
        
          

            
              
                <dd><a href="../../../../v0.6.0/index.html">v0.6.0</a></dd>
              
            

          
        
          

            
              
                <dd><a href="../../../../v0.5.0/index.html">v0.5.0</a></dd>
              
            

          
        
          

            
              
                <dd><a href="../../../../v0.4.1/index.html">v0.4.1</a></dd>
              
            

          
        
          

            
              
                <dd><a href="../../../../v0.4.0/index.html">v0.4.0</a></dd>
              
            

          
        
          

            
              
                <dd><a href="../../../../v0.3.0/index.html">v0.3.0</a></dd>
              
            

          
        
          

            
              
                <dd><a href="../../../../v0.2.1/index.html">v0.2.1</a></dd>
              
            

          
        
          

            
              
                <dd><a href="../../../../v0.2.0/index.html">v0.2.0</a></dd>
              
            

          
        
          

            
              
                <dd><a href="../../../../v0.1.3/index.html">v0.1.3</a></dd>
              
            

          
        
          

            
              
                <dd><a href="../../../../v0.1.2/index.html">v0.1.2</a></dd>
              
            

          
        
          

            
              
                <dd><a href="../../../../v0.1.1/index.html">v0.1.1</a></dd>
              
            

          
        
          

            
              
                <dd><a href="../../../../v0.1.0/index.html">v0.1.0</a></dd>
              
            

          
        
      </dl>
    </div>
  </div>

  <div class="rst-languages shift-up" role="note" aria-label="languages">
    <div class="rst-other-languages">
      <dl>
        <dt>Languages</dt>
        <dd><a href="../../../index.html">en</a></dd>
        <dd><a href="../../../zh/index.html">zh_CN</a></dd>
      </dl>

      <hr />
      <small>
        <span>Hosted by <a href="https://pages.github.com/">Github Pages</a>.</span>
      </small>
    </div>
  </div>


</body>
</html>