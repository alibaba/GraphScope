Graph Object
============

The Graph object is the data structure that organizes the raw data for
further graph operations such as sampling. The Graph object can support
different types of graph, such as isomorphic graphs, heterogeneous
graphs, and attribute graphs. The Graph’s detailed information could be
accessed through related the Graph APIs. The creation of a Graph object
includes **3 steps**:

-  **Declare Graph Object**
-  **Describe the Topology**
-  **Initialization Data**

# 1 Declare Graph Object It’s very simple to declare a Graph object
``g`` and all subsequent related operations are based on ``g``. The
detailed implementation is as follow:

.. code:: python

   import graphlearn as gl
   g = gl.Graph()

2 Describe the Topology
=======================

Topological structure describes the relationship between edges and
vertices in the graph. The topology here refers to the relationship of a
certain type of data. Topological relationships are directed, that is,
the Graph is a directed graph. For example, for a “commodity-commodity”
homogeneous graph, its topology is shown in Figure 1. In this figure,
there is only the item-to-item data relationship. The edge type is
“swing”, which means the item-to-item relationship is generated by the
swing algorithm. Both source and destination vertex types are “item”.

.. container::

   Figure 1: item-to-item homogeneous graph

For a “user-commodity-commodity” bipartite relationship graph, its
topology is shown in Figure 2. In this figure, there are two types of
edges: “click” and “swing”. The click edge represents the click
relationship between users and items. The source vertex type is “user”,
and the destination vertex type is “item”. The swing edge represents the
relationship between items, and the source and destination vertex types
are both “item”.

.. container::

   Figure 2: user-item-item heterogenous graph

The types of these vertices and edges are necessary information for
performing operations on heterogeneous graphs, and users need to provide
this information as input to the operator. Consider a query: “Sampling
the related products of some products clicked by the user”, the system
knows to sample related vertices along
“**user->click->item->swing->item**” after seeing this query instead of
other paths.

In practice, the number of edges in the graph is much greater than the
number of vertices, and vertices also have rich attribute information in
most cases. To save storage space, edges and vertices are often stored
separately. Graphlearn builds the topology by adding vertex data sources
and edge data sources separately to the Graph object.

## 2.1 Adding Vertices The Graph object provides the **node()**
interface for adding a vertex data source. **node()** returns the Graph
object, meaning that **node()** can be called multiple times in
succession. The interface and its parameters are as follow:

.. code:: python

   def node(source, node_type, decoder)
   ''' Describe the relationship between the vertex type and its data schema.

   source:    string type, vertex data source, see chapter "Data Source" for details.
   node_type: string type, vertex type.
   decoder:   Decoder object，describe the schema of data source;
   '''

Table 1 Vertex Data Source with attributes \| id \| attributes \| \| —
\| — \| \| 10001 \| 0:0.1:0 \| \| 10002 \| 1:0.2:3 \| \| 10003 \|
3:0.3:4 \|

Table 2 Vertex Data Source with weights \| id \| weight \| \| — \| — \|
\| 30001 \| 0.1 \| \| 30002 \| 0.2 \| \| 30003 \| 0.3 \|

The data source shown in the above tables can be added to the Graph
object through the following code. Please note that the node_type cannot
be the same at each time you call ``node()`` when there are multiple
types of vertices.

.. code:: python

   g.node(source="table_1", node_type="user", decoder=Decoder(attr_types=["int", "float", "int"])) \
    .node(source="table_2", node_type="movie", decoder=Decoder(weighted=True)

## 2.2 Adding Edges The Graph object provides the **edge()** interface
for adding an edge data source, and it supports the designation of
homogeneous or heterogeneous edges as undirected edges. **edge()**
returns the Graph object itself, meaning that **edge()** can be called
multiple times in succession. By adding the edge data source, we can
determine the corresponding relationship between the edge type and the
source/destination vertex type in the graph, and then the corresponding
vertex type data source can be combined to form a connected graph. The
interface and its parameters are as follows:

.. code:: python

   def edge(source, edge_type, decoder, directed=True)
   ''' Describe the relationship between the edge type and its source vertex and destination vertex type, and the relationship between the edge type and the data schema.

   source:    string type, edge data source, see chapter "Data Source" for details.
   edge_type: tuple, type is (src vertex type, dest vertex type, edge_type)
   decoder:   Decoder object, describe the data source. 
   directed:  boolean, whether the edge is undirected. The default value is True. sampling must use the GSL interface when directed=False.
   '''

Table 3: Edge Data Source with weights

====== ====== ======
src_id dst_id weight
====== ====== ======
10001  10002  0.1
10002  10001  0.2
10003  10002  0.3
10004  10003  0.4
====== ====== ======

Table 4: Edge Data Source with attributes

====== ====== ====== =================================================
src_id dst_id weight attributes
====== ====== ====== =================================================
20001  30001  0.1    0.10,0.11,0.12,0.13,0.14,0.15,0.16,0.17,0.18,0.19
20001  30003  0.2    0.20,0.21,0.22,0.23,0.24,0.25,0.26,0.27,0.28,0.29
20003  30001  0.3    0.30,0.31,0.32,0.33,0.34,0.35,0.36,0.37,0.38,0.39
20004  30002  0.4    0.40,0.41,0.42,0.43,0.44,0.45,0.46,0.47,0.48,0.49
====== ====== ====== =================================================

The data source shown in the above tables can be added to the Graph
object through the following code. Please note that for each edge_type,
``edge()`` can only be called once when there are multiple types of
edges.

.. code:: python

   ui_decoder = Decoder(weighted=True)
   uv_decoder = Decoder(weighted=True, attr_types=["float"] * 10, attr_delimiter=',')

   g.edge(source="table_3", edge_type=("user", "item", "click"), decoder=ui_decoder)
    .edge(source="table_4", edge_type=("user", "movie", "click_v"), decoder=uv_decoder)

# 3 Initialization The initialization interface needs to be called to
finish the construction from the original data to the memory index when
the vertices and edges are added. The graph data serving mode is also
determined in the initialization process, either stand-alone or
distributed. It is necessary to further distinguish Server Mode and
Client-Server Mode if distributed mode is set. After the initialization
is complete, the Graph object is ready to use.

3.1 Stand-alone Mode
--------------------

The stand-alone mode is relatively simple where the Graph object holds
all graph data.

.. code:: python

   g.init()

## 3.2 Distributed Mode – Server Mode In this mode, data is distributed
on each Server, and the Servers are interconnected, and each Server has
a Graph object. When performing graph operations such as sampling, the
Graph object submits the request to the local Server, and the Server
decides how to distribute it. There is no network communication between
the Graph object and the local Server.

.. code:: python

   g.init(task_index, task_count)

Server Mode is suitable for the situation where the graph scale is not
super large. For example, when combined with Tensorflow for distributed
training, each GL server needs to be in the same process as the
TensorFlow worker, which eliminates communication overhead between the
Tensorflow worker and the GL server. Since the distributed scale is not
very large (the number of workers is not very large), the
interconnection between Servers will not cause network burden. In
addition, the atypical worker-ps mode also needs to be deployed in
Server Mode for scenarios where models are trained in parallel.

In combination with Tensorflow, the code is as follows:

.. code:: python

   if FLAGS.job_name == "worker":
     g.init(task_index=FLAGS.task_index, task_count=len(FLAGS.worker_hosts.split(','))
     # Your model, use g to do some operation, such as sampling
     g.close()
   else:
     # ps.join()

3.2 Distributed Mode – Client/Server Mode
-----------------------------------------

In this mode, data is also distributed on each server and the servers
are interconnected which are similar to Server Mode. However, only the
clients have Graph objects, and each client is connected to one server
that responds to its request (similar to the local server in Server
Mode). The relationship between clients and servers is determined by the
load balancing algorithm. As the initiator, the client submits the
request to its corresponding server, and the server decides how to
process distributedly.

C/S Mode is suitable for large distributed scales. The reason is that
when the scale of workers is large, using Server Mode deployment will
greatly increase network overhead. In addition, the scale of graph data
is not necessarily the same as the scale of workers. For example, when
1000 workers are used for concurrent training, the same number of
servers are not necessarily required to store Graph data. If the data is
too scattered, it will seriously decrease the performance. Generally
speaking, the number of trained workers >= the number of graph servers.
The C/S Mode deployment code is as follows:

.. code:: python

   g.init(cluster, job_name, task_index)
   """
   cluster(dict): number of client and server，e.g. cluster={"server_count": 2, "client_count": 4}
   job_name(string): role type, possible values are {"client", "server"}
   task_index(int): The index of current role.
   """

In combination with TensorFlow, the client is located on the worker
side, and the server is located on the ps side or some other role in
TensorFlow. The code is as follows:

.. code:: python

   cluster={"server_count": 2, "client_count": 4}

   if FLAGS.job_name == "worker":
       g.init(cluster=cluster, job_name="client", task_index=FLAGS.task_index)
       # Your model, use g to do some operation, such as sampling
       g.close()
   else if FLAGS.job_name == "ps":
     g.init(cluster=cluster, job_name="server", task_index=FLAGS.task_index)
       g.wait_for_close()
       # ps.join()
   else:
       # others

\ **Please note that you need to explicitly call ``g.close()`` after
using the graph store no matter which deployment mode is used.**
