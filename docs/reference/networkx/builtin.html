

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Builtin algorithms &mdash; GraphScope  documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/css/custom.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Functions" href="functions.html" />
    <link rel="prev" title="graphscope.experimental.nx.DiGraph.project_to_simple" href="generated/graphscope.experimental.nx.DiGraph.project_to_simple.html" /> 

  
  <script src="../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../index.html" class="icon icon-home"> GraphScope
          

          
          </a>

          
            
            
              <div class="version">
                stable
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
      
      
        
          
        
      
      
        <p class="caption"><span class="caption-text">Contents</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../getting_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorials.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../deployment.html">Deployment</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../loading_graph.html">Loading Graphs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../graph_transformation.html">Graph Transformations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../interactive_engine.html">GraphScope Interactive Engine</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../analytics_engine.html">GraphScope Analytical Engine</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../learning_engine.html">GraphScope Learning Engine</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../developer_guide.html">Developer Guide</a></li>
</ul>
<p class="caption"><span class="caption-text">Reference</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../python_index.html">Python API Reference</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../session.html">Session</a></li>
<li class="toctree-l2"><a class="reference internal" href="../graph.html">Graph</a></li>
<li class="toctree-l2"><a class="reference internal" href="../app.html">Analytical App</a></li>
<li class="toctree-l2"><a class="reference internal" href="../context.html">Context</a></li>
<li class="toctree-l2"><a class="reference internal" href="../selector.html">Selector</a></li>
<li class="toctree-l2"><a class="reference internal" href="../operation.html">Operation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cython_sdk.html">Cython SDK API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../interactive.html">Interactive Query</a></li>
<li class="toctree-l2"><a class="reference internal" href="../learning.html">Graph Learning</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html">NetworkX-style API(Preview)</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="graphs.html">Graph types</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Builtin algorithms</a></li>
<li class="toctree-l3"><a class="reference internal" href="functions.html">Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="generators.html">Graph generators</a></li>
<li class="toctree-l3"><a class="reference internal" href="convert.html">Converting to and from other data formats</a></li>
<li class="toctree-l3"><a class="reference internal" href="relabel.html">Relabeling nodes</a></li>
<li class="toctree-l3"><a class="reference internal" href="io.html">Reading and writing graphs</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../analytical_engine_index.html">Analytical Engine API Reference</a></li>
</ul>

      
    
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">GraphScope</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../python_index.html">Python API Reference</a> &raquo;</li>
        
          <li><a href="index.html">NetworkX-style API(Preview)</a> &raquo;</li>
        
      <li>Builtin algorithms</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/reference/networkx/builtin.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="builtin-algorithms">
<span id="builtin"></span><h1>Builtin algorithms<a class="headerlink" href="#builtin-algorithms" title="Permalink to this headline">¶</a></h1>
<dl class="py function">
<dt id="graphscope.experimental.nx.Graph.project_to_simple">
<code class="sig-prename descclassname">graphscope.experimental.nx.Graph.</code><code class="sig-name descname">project_to_simple</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">v_prop</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">e_prop</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#graphscope.experimental.nx.Graph.project_to_simple" title="Permalink to this definition">¶</a></dt>
<dd><p>Project nx graph to a simple graph to run builtin alogorithms.</p>
<p>A simple graph is a accesser wrapper of property graph that only single edge
attribute and single node attribute are available.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>v_prop</strong> (<em>the node attribute key to project</em><em>, </em><em>(</em><em>optional</em><em>, </em><em>default None</em><em>)</em>) – </p></li>
<li><p><strong>e_prop</strong> (<em>the edge attribute key to project</em><em>, </em><em>(</em><em>optional</em><em>, </em><em>default None</em><em>)</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>simple_graph</strong> – A nx.Graph object that hold a simple graph projected by host property graph.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="graphs.html#graphscope.experimental.nx.Graph" title="graphscope.experimental.nx.Graph">nx.Graph</a> or <a class="reference internal" href="graphs.html#graphscope.experimental.nx.DiGraph" title="graphscope.experimental.nx.DiGraph">nx.DiGraph</a></p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>the method is implicit called in builtin apps.</p>
</dd></dl>

<dl class="py function">
<dt id="graphscope.experimental.nx.builtin.pagerank">
<code class="sig-prename descclassname">graphscope.experimental.nx.builtin.</code><code class="sig-name descname">pagerank</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">G</span></em>, <em class="sig-param"><span class="n">alpha</span><span class="o">=</span><span class="default_value">0.85</span></em>, <em class="sig-param"><span class="n">max_iter</span><span class="o">=</span><span class="default_value">100</span></em>, <em class="sig-param"><span class="n">tol</span><span class="o">=</span><span class="default_value">1e-06</span></em><span class="sig-paren">)</span><a class="headerlink" href="#graphscope.experimental.nx.builtin.pagerank" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="graphscope.experimental.nx.builtin.hits">
<code class="sig-prename descclassname">graphscope.experimental.nx.builtin.</code><code class="sig-name descname">hits</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">G</span></em>, <em class="sig-param"><span class="n">max_iter</span><span class="o">=</span><span class="default_value">100</span></em>, <em class="sig-param"><span class="n">tol</span><span class="o">=</span><span class="default_value">1e-08</span></em>, <em class="sig-param"><span class="n">normalized</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#graphscope.experimental.nx.builtin.hits" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns HITS hubs and authorities values for nodes.</p>
<p>The HITS algorithm computes two numbers for a node.
Authorities estimates the node value based on the incoming links.
Hubs estimates the node value based on outgoing links.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> (<em>graph</em>) – A NetworkX graph</p></li>
<li><p><strong>max_iter</strong> (<em>integer</em><em>, </em><em>optional</em>) – Maximum number of iterations in power method.</p></li>
<li><p><strong>tol</strong> (<em>float</em><em>, </em><em>optional</em>) – Error tolerance used to check convergence in power method iteration.</p></li>
<li><p><strong>nstart</strong> (<em>dictionary</em><em>, </em><em>optional</em>) – Starting value of each node for power method iteration.</p></li>
<li><p><strong>normalized</strong> (<em>bool</em><em> (</em><em>default=True</em><em>)</em>) – Normalize results by the sum of all of the values.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>(hubs,authorities)</strong> – Two dictionaries keyed by node containing the hub and authority
values.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>two-tuple of dictionaries</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>PowerIterationFailedConvergence</strong> – If the algorithm fails to converge to the specified tolerance
    within the specified number of iterations of the power iteration
    method.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">path_graph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">hits</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<p>The eigenvector calculation is done by the power iteration method
and has no guarantee of convergence.  The iteration will stop
after max_iter iterations or an error tolerance of
number_of_nodes(G)*tol has been reached.</p>
<p>The HITS algorithm was designed for directed graphs but this
algorithm does not check if the input graph is directed and will
execute on undirected graphs.</p>
<p class="rubric">References</p>
<dl class="footnote brackets">
<dt class="label" id="id1"><span class="brackets">1</span></dt>
<dd><p>A. Langville and C. Meyer,
“A survey of eigenvector methods of web information retrieval.”
<a class="reference external" href="http://citeseer.ist.psu.edu/713792.html">http://citeseer.ist.psu.edu/713792.html</a></p>
</dd>
<dt class="label" id="id2"><span class="brackets">2</span></dt>
<dd><p>Jon Kleinberg,
Authoritative sources in a hyperlinked environment
Journal of the ACM 46 (5): 604-32, 1999.
doi:10.1145/324133.324140.
http://www.cs.cornell.edu/home/kleinber/auth.pdf.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="graphscope.experimental.nx.builtin.degree_centrality">
<code class="sig-prename descclassname">graphscope.experimental.nx.builtin.</code><code class="sig-name descname">degree_centrality</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">G</span></em><span class="sig-paren">)</span><a class="headerlink" href="#graphscope.experimental.nx.builtin.degree_centrality" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the degree centrality for nodes.</p>
<p>The degree centrality for a node v is the fraction of nodes it
is connected to.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>G</strong> (<em>graph</em>) – A networkx graph</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>nodes</strong> – Dictionary of nodes with degree centrality as the value.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dictionary</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">betweenness_centrality</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">load_centrality</span></code>, <a class="reference internal" href="graphs.html#graphscope.experimental.nx.builtin.eigenvector_centrality" title="graphscope.experimental.nx.builtin.eigenvector_centrality"><code class="xref py py-obj docutils literal notranslate"><span class="pre">eigenvector_centrality</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>The degree centrality values are normalized by dividing by the maximum
possible degree in a simple graph n-1 where n is the number of nodes in G.</p>
<p>For multigraphs or graphs with self loops the maximum degree might
be higher than n-1 and values of degree centrality greater than 1
are possible.</p>
</dd></dl>

<dl class="py function">
<dt id="graphscope.experimental.nx.builtin.in_degree_centrality">
<code class="sig-prename descclassname">graphscope.experimental.nx.builtin.</code><code class="sig-name descname">in_degree_centrality</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">G</span></em><span class="sig-paren">)</span><a class="headerlink" href="#graphscope.experimental.nx.builtin.in_degree_centrality" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="graphscope.experimental.nx.builtin.out_degree_centrality">
<code class="sig-prename descclassname">graphscope.experimental.nx.builtin.</code><code class="sig-name descname">out_degree_centrality</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">G</span></em><span class="sig-paren">)</span><a class="headerlink" href="#graphscope.experimental.nx.builtin.out_degree_centrality" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="graphscope.experimental.nx.builtin.eigenvector_centrality">
<code class="sig-prename descclassname">graphscope.experimental.nx.builtin.</code><code class="sig-name descname">eigenvector_centrality</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">G</span></em>, <em class="sig-param"><span class="n">max_iter</span><span class="o">=</span><span class="default_value">100</span></em>, <em class="sig-param"><span class="n">tol</span><span class="o">=</span><span class="default_value">1e-06</span></em>, <em class="sig-param"><span class="n">weight</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#graphscope.experimental.nx.builtin.eigenvector_centrality" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="graphscope.experimental.nx.builtin.katz_centrality">
<code class="sig-prename descclassname">graphscope.experimental.nx.builtin.</code><code class="sig-name descname">katz_centrality</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">G</span></em>, <em class="sig-param"><span class="n">alpha</span><span class="o">=</span><span class="default_value">0.1</span></em>, <em class="sig-param"><span class="n">beta</span><span class="o">=</span><span class="default_value">1.0</span></em>, <em class="sig-param"><span class="n">max_iter</span><span class="o">=</span><span class="default_value">100</span></em>, <em class="sig-param"><span class="n">tol</span><span class="o">=</span><span class="default_value">1e-06</span></em>, <em class="sig-param"><span class="n">nstart</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">normalized</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">weight</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#graphscope.experimental.nx.builtin.katz_centrality" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="graphscope.experimental.nx.builtin.has_path">
<code class="sig-prename descclassname">graphscope.experimental.nx.builtin.</code><code class="sig-name descname">has_path</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">G</span></em>, <em class="sig-param"><span class="n">source</span></em>, <em class="sig-param"><span class="n">target</span></em><span class="sig-paren">)</span><a class="headerlink" href="#graphscope.experimental.nx.builtin.has_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <em>True</em> if <em>G</em> has a path from <em>source</em> to <em>target</em>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> (<em>NetworkX graph</em>) – </p></li>
<li><p><strong>source</strong> (<em>node</em>) – Starting node for path</p></li>
<li><p><strong>target</strong> (<em>node</em>) – Ending node for path</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="graphscope.experimental.nx.builtin.shortest_path">
<code class="sig-prename descclassname">graphscope.experimental.nx.builtin.</code><code class="sig-name descname">shortest_path</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">G</span></em>, <em class="sig-param"><span class="n">source</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">target</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">weight</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#graphscope.experimental.nx.builtin.shortest_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute shortest paths in the graph.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> (<em>NetworkX graph</em>) – </p></li>
<li><p><strong>source</strong> (<em>node</em><em>, </em><em>optional</em>) – Starting node for path. If not specified, compute shortest
paths for each possible starting node.</p></li>
<li><p><strong>target</strong> (<em>node</em><em>, </em><em>optional</em>) – Ending node for path. If not specified, compute shortest
paths to all possible nodes.</p></li>
<li><p><strong>weight</strong> (<em>None</em><em> or </em><em>string</em><em>, </em><em>optional</em><em> (</em><em>default = None</em><em>)</em>) – If None, every edge has weight/distance/cost 1.
If a string, use this edge attribute as the edge weight.
Any edge attribute not present defaults to 1.</p></li>
<li><p><strong>method</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default = 'dijkstra'</em><em>)</em>) – The algorithm to use to compute the path.
Supported options: ‘dijkstra’, ‘bellman-ford’.
Other inputs produce a ValueError.
If <cite>weight</cite> is None, unweighted graph methods are used, and this
suggestion is ignored.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><p><strong>path</strong> – All returned paths include both the source and target in the path.</p>
<p>If the source and target are both specified, return a single list
of nodes in a shortest path from the source to the target.</p>
<p>If only the source is specified, return a dictionary keyed by
targets with a list of nodes in a shortest path from the source
to one of the targets.</p>
<p>If only the target is specified, return a dictionary keyed by
sources with a list of nodes in a shortest path from one of the
sources to the target.</p>
<p>If neither the source nor target are specified return a dictionary
of dictionaries with path[source][target]=[list of nodes in path].</p>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list or dictionary</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>NodeNotFound</strong> – If <cite>source</cite> is not in <cite>G</cite>.</p></li>
<li><p><strong>ValueError</strong> – If <cite>method</cite> is not among the supported options.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">path_graph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">shortest_path</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="mi">4</span><span class="p">))</span>
<span class="go">[0, 1, 2, 3, 4]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">shortest_path</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># target not specified</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
<span class="go">[0, 1, 2, 3, 4]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">shortest_path</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>  <span class="c1"># source not specified</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">[0, 1, 2, 3, 4]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">shortest_path</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>  <span class="c1"># source, target not specified</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">4</span><span class="p">]</span>
<span class="go">[0, 1, 2, 3, 4]</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<p>There may be more than one shortest path between a source and target.
This returns only one of them.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">all_pairs_shortest_path</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">all_pairs_dijkstra_path</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">all_pairs_bellman_ford_path</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">single_source_shortest_path</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">single_source_dijkstra_path</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">single_source_bellman_ford_path</span></code></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="graphscope.experimental.nx.builtin.average_shortest_path_length">
<code class="sig-prename descclassname">graphscope.experimental.nx.builtin.</code><code class="sig-name descname">average_shortest_path_length</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">G</span></em>, <em class="sig-param"><span class="n">weight</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#graphscope.experimental.nx.builtin.average_shortest_path_length" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the average shortest path length.</p>
<p>The average shortest path length is</p>
<div class="math notranslate nohighlight">
\[a =\sum_{s,t \in V} \frac{d(s, t)}{n(n-1)}\]</div>
<p>where <cite>V</cite> is the set of nodes in <cite>G</cite>,
<cite>d(s, t)</cite> is the shortest path from <cite>s</cite> to <cite>t</cite>,
and <cite>n</cite> is the number of nodes in <cite>G</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> (<em>NetworkX graph</em>) – </p></li>
<li><p><strong>weight</strong> (<em>None</em><em> or </em><em>string</em><em>, </em><em>optional</em><em> (</em><em>default = None</em><em>)</em>) – If None, every edge has weight/distance/cost 1.
If a string, use this edge attribute as the edge weight.
Any edge attribute not present defaults to 1.</p></li>
<li><p><strong>method</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default = 'unweighted'</em><em> or </em><em>'djikstra'</em><em>)</em>) – The algorithm to use to compute the path lengths.
Supported options are ‘unweighted’, ‘dijkstra’, ‘bellman-ford’,
‘floyd-warshall’ and ‘floyd-warshall-numpy’.
Other method values produce a ValueError.
The default method is ‘unweighted’ if <cite>weight</cite> is None,
otherwise the default method is ‘dijkstra’.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>NetworkXPointlessConcept</strong> – If <cite>G</cite> is the null graph (that is, the graph on zero nodes).</p></li>
<li><p><strong>NetworkXError</strong> – If <cite>G</cite> is not connected (or not weakly connected, in the case
    of a directed graph).</p></li>
<li><p><strong>ValueError</strong> – If <cite>method</cite> is not among the supported options.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">path_graph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nx</span><span class="o">.</span><span class="n">average_shortest_path_length</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="go">2.0</span>
</pre></div>
</div>
<p>For disconnected graphs, you can compute the average shortest path
length for each component</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">C</span> <span class="ow">in</span> <span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">nx</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">G</span><span class="p">)):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">average_shortest_path_length</span><span class="p">(</span><span class="n">C</span><span class="p">))</span>
<span class="go">1.0</span>
<span class="go">1.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="graphscope.experimental.nx.builtin.bfs_edges">
<code class="sig-prename descclassname">graphscope.experimental.nx.builtin.</code><code class="sig-name descname">bfs_edges</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">G</span></em>, <em class="sig-param"><span class="n">source</span></em>, <em class="sig-param"><span class="n">reverse</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">depth_limit</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#graphscope.experimental.nx.builtin.bfs_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over edges in a breadth-first-search starting at source.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> (<em>NetworkX graph</em>) – </p></li>
<li><p><strong>source</strong> (<em>node</em>) – Specify starting node for breadth-first search; this function
iterates over only those edges in the component reachable from
this node.</p></li>
<li><p><strong>reverse</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True traverse a directed graph in the reverse direction</p></li>
<li><p><strong>depth_limit</strong> (<em>int</em><em>, </em><em>optional</em><em>(</em><em>default=len</em><em>(</em><em>G</em><em>)</em><em>)</em>) – Specify the maximum search depth</p></li>
<li><p><strong>sort_neighbors</strong> (<em>function</em>) – A function that takes the list of neighbors of given node as input, and
returns an <em>iterator</em> over these neighbors but with custom ordering.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>edges</strong> – A generator of edges in the breadth-first-search.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>generator</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>To get the edges in a breadth-first search:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">path_graph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">bfs_edges</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="go">[(0, 1), (1, 2)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">bfs_edges</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">depth_limit</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
<span class="go">[(0, 1)]</span>
</pre></div>
</div>
<p>To get the nodes in a breadth-first search order:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">path_graph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">root</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">edges</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">bfs_edges</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">root</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">root</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">v</span> <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nodes</span>
<span class="go">[2, 1, 0]</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<p>The naming of this function is very similar to edge_bfs. The difference
is that ‘edge_bfs’ yields edges even if they extend back to an already
explored node while ‘bfs_edges’ yields the edges of the tree that results
from a breadth-first-search (BFS) so no edges are reported if they extend
to already explored nodes. That means ‘edge_bfs’ reports all edges while
‘bfs_edges’ only reports those traversed by a node-based BFS. Yet another
description is that ‘bfs_edges’ reports the edges traversed during BFS
while ‘edge_bfs’ reports all edges in the order they are explored.</p>
<p>Based on <a class="reference external" href="http://www.ics.uci.edu/~eppstein/PADS/BFS.py">http://www.ics.uci.edu/~eppstein/PADS/BFS.py</a>.
by D. Eppstein, July 2004. The modifications
to allow depth limits based on the Wikipedia article
“<a class="reference external" href="https://en.wikipedia.org/wiki/Depth-limited_search">Depth-limited-search</a>”.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">bfs_tree</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">dfs_edges</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">edge_bfs</span></code></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="graphscope.experimental.nx.builtin.bfs_predecessors">
<code class="sig-prename descclassname">graphscope.experimental.nx.builtin.</code><code class="sig-name descname">bfs_predecessors</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">G</span></em>, <em class="sig-param"><span class="n">source</span></em>, <em class="sig-param"><span class="n">depth_limit</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#graphscope.experimental.nx.builtin.bfs_predecessors" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an iterator of predecessors in breadth-first-search from source.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> (<em>NetworkX graph</em>) – </p></li>
<li><p><strong>source</strong> (<em>node</em>) – Specify starting node for breadth-first search</p></li>
<li><p><strong>depth_limit</strong> (<em>int</em><em>, </em><em>optional</em><em>(</em><em>default=len</em><em>(</em><em>G</em><em>)</em><em>)</em>) – Specify the maximum search depth</p></li>
<li><p><strong>sort_neighbors</strong> (<em>function</em>) – A function that takes the list of neighbors of given node as input, and
returns an <em>iterator</em> over these neighbors but with custom ordering.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>pred</strong> – (node, predecessors) iterator where predecessors is the list of
predecessors of the node.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>iterator</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">path_graph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">bfs_predecessors</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span>
<span class="go">{1: 0, 2: 1}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">bfs_predecessors</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span>
<span class="go">{1: 0, 2: 0, 3: 1, 4: 1, 5: 2, 6: 2}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nx</span><span class="o">.</span><span class="n">add_path</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nx</span><span class="o">.</span><span class="n">add_path</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">bfs_predecessors</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">depth_limit</span><span class="o">=</span><span class="mi">3</span><span class="p">)))</span>
<span class="go">[(0, 1), (2, 1), (3, 2), (4, 3), (7, 2), (8, 7)]</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<p>Based on <a class="reference external" href="http://www.ics.uci.edu/~eppstein/PADS/BFS.py">http://www.ics.uci.edu/~eppstein/PADS/BFS.py</a>
by D. Eppstein, July 2004. The modifications
to allow depth limits based on the Wikipedia article
“<a class="reference external" href="https://en.wikipedia.org/wiki/Depth-limited_search">Depth-limited-search</a>”.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">bfs_tree</span></code>, <a class="reference internal" href="graphs.html#graphscope.experimental.nx.builtin.bfs_edges" title="graphscope.experimental.nx.builtin.bfs_edges"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bfs_edges</span></code></a>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">edge_bfs</span></code></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="graphscope.experimental.nx.builtin.bfs_successors">
<code class="sig-prename descclassname">graphscope.experimental.nx.builtin.</code><code class="sig-name descname">bfs_successors</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">G</span></em>, <em class="sig-param"><span class="n">source</span></em>, <em class="sig-param"><span class="n">depth_limit</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#graphscope.experimental.nx.builtin.bfs_successors" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an iterator of successors in breadth-first-search from source.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> (<em>NetworkX graph</em>) – </p></li>
<li><p><strong>source</strong> (<em>node</em>) – Specify starting node for breadth-first search</p></li>
<li><p><strong>depth_limit</strong> (<em>int</em><em>, </em><em>optional</em><em>(</em><em>default=len</em><em>(</em><em>G</em><em>)</em><em>)</em>) – Specify the maximum search depth</p></li>
<li><p><strong>sort_neighbors</strong> (<em>function</em>) – A function that takes the list of neighbors of given node as input, and
returns an <em>iterator</em> over these neighbors but with custom ordering.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>succ</strong> – (node, successors) iterator where successors is the list of
successors of the node.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>iterator</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">path_graph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">bfs_successors</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span>
<span class="go">{0: [1], 1: [2]}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">bfs_successors</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span>
<span class="go">{0: [1, 2], 1: [3, 4], 2: [5, 6]}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nx</span><span class="o">.</span><span class="n">add_path</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nx</span><span class="o">.</span><span class="n">add_path</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">bfs_successors</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">depth_limit</span><span class="o">=</span><span class="mi">3</span><span class="p">)))</span>
<span class="go">{1: [0, 2], 2: [3, 7], 3: [4], 7: [8]}</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<p>Based on <a class="reference external" href="http://www.ics.uci.edu/~eppstein/PADS/BFS.py">http://www.ics.uci.edu/~eppstein/PADS/BFS.py</a>
by D. Eppstein, July 2004.The modifications
to allow depth limits based on the Wikipedia article
“<a class="reference external" href="https://en.wikipedia.org/wiki/Depth-limited_search">Depth-limited-search</a>”.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">bfs_tree</span></code>, <a class="reference internal" href="graphs.html#graphscope.experimental.nx.builtin.bfs_edges" title="graphscope.experimental.nx.builtin.bfs_edges"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bfs_edges</span></code></a>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">edge_bfs</span></code></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="graphscope.experimental.nx.builtin.k_core">
<code class="sig-prename descclassname">graphscope.experimental.nx.builtin.</code><code class="sig-name descname">k_core</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">G</span></em>, <em class="sig-param"><span class="n">k</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">core_number</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#graphscope.experimental.nx.builtin.k_core" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the k-core of G.</p>
<p>A k-core is a maximal subgraph that contains nodes of degree k or more.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> (<em>NetworkX graph</em>) – A graph or directed graph</p></li>
<li><p><strong>k</strong> (<em>int</em><em>, </em><em>optional</em>) – The order of the core.  If not specified return the main core.</p></li>
<li><p><strong>core_number</strong> (<em>dictionary</em><em>, </em><em>optional</em>) – Precomputed core numbers for the graph G.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>G</strong> – The k-core subgraph</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>NetworkX graph</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>NetworkXError</strong> – The k-core is not defined for graphs with self loops or parallel edges.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The main core is the core with the largest degree.</p>
<p>Not implemented for graphs with parallel edges or self loops.</p>
<p>For directed graphs the node degree is defined to be the
in-degree + out-degree.</p>
<p>Graph, node, and edge attributes are copied to the subgraph.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">core_number</span></code></p>
</div>
<p class="rubric">References</p>
<dl class="footnote brackets">
<dt class="label" id="id5"><span class="brackets">1</span></dt>
<dd><p>An O(m) Algorithm for Cores Decomposition of Networks
Vladimir Batagelj and Matjaz Zaversnik,  2003.
<a class="reference external" href="https://arxiv.org/abs/cs.DS/0310049">https://arxiv.org/abs/cs.DS/0310049</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="graphscope.experimental.nx.builtin.clustering">
<code class="sig-prename descclassname">graphscope.experimental.nx.builtin.</code><code class="sig-name descname">clustering</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">G</span></em>, <em class="sig-param"><span class="n">nodes</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">weight</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#graphscope.experimental.nx.builtin.clustering" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the clustering coefficient for nodes.</p>
<p>For unweighted graphs, the clustering of a node <span class="math notranslate nohighlight">\(u\)</span>
is the fraction of possible triangles through that node that exist,</p>
<div class="math notranslate nohighlight">
\[c_u = \frac{2 T(u)}{deg(u)(deg(u)-1)},\]</div>
<p>where <span class="math notranslate nohighlight">\(T(u)\)</span> is the number of triangles through node <span class="math notranslate nohighlight">\(u\)</span> and
<span class="math notranslate nohighlight">\(deg(u)\)</span> is the degree of <span class="math notranslate nohighlight">\(u\)</span>.</p>
<p>For weighted graphs, there are several ways to define clustering <a href="#id14"><span class="problematic" id="id6">[1]_</span></a>.
the one used here is defined
as the geometric average of the subgraph edge weights <a href="#id15"><span class="problematic" id="id7">[2]_</span></a>,</p>
<div class="math notranslate nohighlight">
\[c_u = \frac{1}{deg(u)(deg(u)-1))}
      \sum_{vw} (\hat{w}_{uv} \hat{w}_{uw} \hat{w}_{vw})^{1/3}.\]</div>
<p>The edge weights <span class="math notranslate nohighlight">\(\hat{w}_{uv}\)</span> are normalized by the maximum weight
in the network <span class="math notranslate nohighlight">\(\hat{w}_{uv} = w_{uv}/\max(w)\)</span>.</p>
<p>The value of <span class="math notranslate nohighlight">\(c_u\)</span> is assigned to 0 if <span class="math notranslate nohighlight">\(deg(u) &lt; 2\)</span>.</p>
<p>For directed graphs, the clustering is similarly defined as the fraction
of all possible directed triangles or geometric average of the subgraph
edge weights for unweighted and weighted directed graph respectively <a class="footnote-reference brackets" href="#id11" id="id8">3</a>.</p>
<div class="math notranslate nohighlight">
\[c_u = \frac{1}{deg^{tot}(u)(deg^{tot}(u)-1) - 2deg^{\leftrightarrow}(u)}
      T(u),\]</div>
<p>where <span class="math notranslate nohighlight">\(T(u)\)</span> is the number of directed triangles through node
<span class="math notranslate nohighlight">\(u\)</span>, <span class="math notranslate nohighlight">\(deg^{tot}(u)\)</span> is the sum of in degree and out degree of
<span class="math notranslate nohighlight">\(u\)</span> and <span class="math notranslate nohighlight">\(deg^{\leftrightarrow}(u)\)</span> is the reciprocal degree of
<span class="math notranslate nohighlight">\(u\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> (<em>graph</em>) – </p></li>
<li><p><strong>nodes</strong> (<em>container of nodes</em><em>, </em><em>optional</em><em> (</em><em>default=all nodes in G</em><em>)</em>) – Compute clustering for nodes in this container.</p></li>
<li><p><strong>weight</strong> (<em>string</em><em> or </em><em>None</em><em>, </em><em>optional</em><em> (</em><em>default=None</em><em>)</em>) – The edge attribute that holds the numerical value used as a weight.
If None, then each edge has weight 1.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>out</strong> – Clustering coefficient at specified nodes</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float, or dictionary</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">complete_graph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">clustering</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="go">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">clustering</span><span class="p">(</span><span class="n">G</span><span class="p">))</span>
<span class="go">{0: 1.0, 1: 1.0, 2: 1.0, 3: 1.0, 4: 1.0}</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<p>Self loops are ignored.</p>
<p class="rubric">References</p>
<dl class="footnote brackets">
<dt class="label" id="id9"><span class="brackets">1</span></dt>
<dd><p>Generalizations of the clustering coefficient to weighted
complex networks by J. Saramäki, M. Kivelä, J.-P. Onnela,
K. Kaski, and J. Kertész, Physical Review E, 75 027105 (2007).
<a class="reference external" href="http://jponnela.com/web_documents/a9.pdf">http://jponnela.com/web_documents/a9.pdf</a></p>
</dd>
<dt class="label" id="id10"><span class="brackets">2</span></dt>
<dd><p>Intensity and coherence of motifs in weighted complex
networks by J. P. Onnela, J. Saramäki, J. Kertész, and K. Kaski,
Physical Review E, 71(6), 065103 (2005).</p>
</dd>
<dt class="label" id="id11"><span class="brackets"><a class="fn-backref" href="#id8">3</a></span></dt>
<dd><p>Clustering in complex directed networks by G. Fagiolo,
Physical Review E, 76(2), 026107 (2007).</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="graphscope.experimental.nx.builtin.triangles">
<code class="sig-prename descclassname">graphscope.experimental.nx.builtin.</code><code class="sig-name descname">triangles</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">G</span></em>, <em class="sig-param"><span class="n">nodes</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#graphscope.experimental.nx.builtin.triangles" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="graphscope.experimental.nx.builtin.transitivity">
<code class="sig-prename descclassname">graphscope.experimental.nx.builtin.</code><code class="sig-name descname">transitivity</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">G</span></em><span class="sig-paren">)</span><a class="headerlink" href="#graphscope.experimental.nx.builtin.transitivity" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute graph transitivity, the fraction of all possible triangles
present in G.</p>
<p>Possible triangles are identified by the number of “triads”
(two edges with a shared vertex).</p>
<p>The transitivity is</p>
<div class="math notranslate nohighlight">
\[T = 3\frac{\#triangles}{\#triads}.\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>G</strong> (<em>graph</em>) – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>out</strong> – Transitivity</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">complete_graph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">transitivity</span><span class="p">(</span><span class="n">G</span><span class="p">))</span>
<span class="go">1.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="graphscope.experimental.nx.builtin.average_clustering">
<code class="sig-prename descclassname">graphscope.experimental.nx.builtin.</code><code class="sig-name descname">average_clustering</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">G</span></em>, <em class="sig-param"><span class="n">nodes</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">weight</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">count_zeros</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#graphscope.experimental.nx.builtin.average_clustering" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the average clustering coefficient for the graph G.</p>
<p>The clustering coefficient for the graph is the average,</p>
<div class="math notranslate nohighlight">
\[C = \frac{1}{n}\sum_{v \in G} c_v,\]</div>
<p>where <span class="math notranslate nohighlight">\(n\)</span> is the number of nodes in <cite>G</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> (<em>graph</em>) – </p></li>
<li><p><strong>nodes</strong> (<em>container of nodes</em><em>, </em><em>optional</em><em> (</em><em>default=all nodes in G</em><em>)</em>) – Compute average clustering for nodes in this container.</p></li>
<li><p><strong>weight</strong> (<em>string</em><em> or </em><em>None</em><em>, </em><em>optional</em><em> (</em><em>default=None</em><em>)</em>) – The edge attribute that holds the numerical value used as a weight.
If None, then each edge has weight 1.</p></li>
<li><p><strong>count_zeros</strong> (<em>bool</em>) – If False include only the nodes with nonzero clustering in the average.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>avg</strong> – Average clustering</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">complete_graph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">average_clustering</span><span class="p">(</span><span class="n">G</span><span class="p">))</span>
<span class="go">1.0</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<p>This is a space saving routine; it might be faster
to use the clustering function to get a list and then take the average.</p>
<p>Self loops are ignored.</p>
<p class="rubric">References</p>
<dl class="footnote brackets">
<dt class="label" id="id12"><span class="brackets">1</span></dt>
<dd><p>Generalizations of the clustering coefficient to weighted
complex networks by J. Saramäki, M. Kivelä, J.-P. Onnela,
K. Kaski, and J. Kertész, Physical Review E, 75 027105 (2007).
<a class="reference external" href="http://jponnela.com/web_documents/a9.pdf">http://jponnela.com/web_documents/a9.pdf</a></p>
</dd>
<dt class="label" id="id13"><span class="brackets">2</span></dt>
<dd><p>Marcus Kaiser,  Mean clustering coefficients: the role of isolated
nodes and leafs on clustering measures for small-world networks.
<a class="reference external" href="https://arxiv.org/abs/0802.2512">https://arxiv.org/abs/0802.2512</a></p>
</dd>
</dl>
</dd></dl>

</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="functions.html" class="btn btn-neutral float-right" title="Functions" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="generated/graphscope.experimental.nx.DiGraph.project_to_simple.html" class="btn btn-neutral" title="graphscope.experimental.nx.DiGraph.project_to_simple" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020-2023, Damo Academy, Alibaba Inc.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    

  

  <script type="text/javascript" src="../../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
  

  <div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      <span class="fa fa-book"> Read the Docs</span>
      v: stable
      <span class="fa fa-caret-down"></span>
    </span>
    <div class="rst-other-versions">
      <dl>
        <dt>Versions</dt>
        
          

            
              
                <dd><a href="../../latest/index.html">latest</a></dd>
              
            

          
        
          

            
              
                <dd><a href="../../index.html">stable</a></dd>
              
            

          
        
          

            
              
                <dd><a href="../../v0.2.1/index.html">v0.2.1</a></dd>
              
            

          
        
          

            
              
                <dd><a href="../../v0.2.0/index.html">v0.2.0</a></dd>
              
            

          
        
          

            
              
                <dd><a href="../../v0.1.3/index.html">v0.1.3</a></dd>
              
            

          
        
          

            
              
                <dd><a href="../../v0.1.2/index.html">v0.1.2</a></dd>
              
            

          
        
          

            
              
                <dd><a href="../../v0.1.1/index.html">v0.1.1</a></dd>
              
            

          
        
          

            
              
                <dd><a href="../../v0.1.0/index.html">v0.1.0</a></dd>
              
            

          
        
      </dl>
    </div>
  </div>

  <div class="rst-languages shift-up" role="note" aria-label="languages">
    <div class="rst-other-languages">
      <dl>
        <dt>Languages</dt>
        <dd><a href="../../index.html">en</a></dd>
        <dd><a href="../../zh/index.html">zh_CN</a></dd>
      </dl>

      <hr />
      <small>
        <span>Hosted by <a href="https://pages.github.com/">Github Pages</a>.</span>
      </small>
    </div>
  </div>


</body>
</html>