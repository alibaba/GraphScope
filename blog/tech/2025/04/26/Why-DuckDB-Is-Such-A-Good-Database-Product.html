<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />

    <title>GraphScope - graphscope blog</title>
    <meta name="description" content="GraphScope Blog" />

    <meta name="HandheldFriendly" content="True" />
    <meta name="MobileOptimized" content="320" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <link rel="stylesheet" type="text/css" href="/blog/assets/css/screen.css" />
    <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Merriweather:300,700,700italic,300italic|Open+Sans:700,400" />
    <!-- Customisation  -->
    <link rel="stylesheet" type="text/css" href="/blog/assets/css/main.css " />

</head>
<body class="home-template">

    <header class="main-header post-head no-cover">
    <nav class="main-nav  clearfix">
        <a class="back-button icon-arrow-left" href="/blog/">Home</a>
        <a class="subscribe-button" target="blank" href="https://github.com/alibaba/graphscope">Github</a>
    </nav>
</header>

<main class="content" role="main">

    <article class="post">

        <header class="post-header">
            <h1 class="post-title">Why DuckDB Is Such A Good Database Product</h1>
            <section class="post-meta">
                
                on Tech
                
                <time class="post-date" datetime=" 2025-04-26">26 Apr 2025</time>
            </section>
        </header>

        <!--         <header class="post-header">
            <a id="blog-logo" href="https://graphscope.io">
                
                    <span class="blog-title">GraphScope</span>
                
            </a>
        </header> -->

        <!-- <span class="post-meta">
            <time datetime="2025-04-26">26 Apr 2025</time>
            
                on Tech
            
        </span> -->

        <!-- <h1 class="post-title">Why DuckDB Is Such A Good Database Product</h1> -->

        <section class="post-content">
            <p><img src="/blog/assets/images/2025-03-10-title-picture.jpg" alt="why-duckdb" /></p>

<h1 id="tldr">TL;DR</h1>
<ul>
  <li>Although databases are ancient, they still provide guidance for LLMs development.</li>
  <li><strong>DuckDB’s Success Formula</strong>: Insight into trends + relentless focus on core competencies + extremely good product.</li>
  <li>Everyone agrees on “big data,” but not everyone needs “big data.”</li>
  <li><a href="https://motherduck.com/blog/big-data-is-dead/">“Big Data is Dead”</a>, and large models are a better computational paradigm.</li>
  <li>Be meticulous in initial technology selection, let data guide decisions, and avoid blind trust in authority.</li>
  <li>Technology choices must always serve the product.</li>
  <li>What appears “small and elegant” is actually the result of accumulated efforts in good products.</li>
</ul>

<hr />

<h1 id="introduction">Introduction</h1>
<p>It’s 2025, who still cares about databases? IT IS <strong>anyone who takes data seriously</strong>. Since their inception in the 1970s, relational databases have remained the backbone of data management. Despite waves of NoSQL, NewSQL, and other trends, the dominance of traditional databases and SQL remains unshaken. At SIGMOD 2023, Don Chamberlin, co-creator of SQL, delivered a keynote titled <a href="https://dl.acm.org/doi/10.1145/3555041.3589336">“49 Years of Queries”</a>, reflecting on the evolution of relational databases and SQL over nearly half a century. Chamberlin emphasized that the longevity of database systems stems from E. F. Codd’s foundational theories, such as:</p>

<ul>
  <li><strong><a href="https://en.wikipedia.org/wiki/Database_normalization">Database Normalization</a></strong>: Teaches structured data organization to eliminate redundancy.</li>
  <li><strong>Natural Language Queries</strong>: A vision pursued since 1974 with Codd’s <a href="https://dl.acm.org/doi/10.1145/1045283.1045298">“Rendezvous”</a> project, which led to SQL.</li>
  <li><strong><a href="https://en.wikipedia.org/wiki/Relational_algebra">Relational Algebra Closure</a></strong>: Ensures uniform data formats for chained operations.</li>
</ul>

<p>Fast forward 55 years: large models dominate the AI landscape, unstructured data processing explodes, yet database theory remains deeply influential. Normalization principles guide large language model (LLM) training, inspiring slogans like <a href="https://arxiv.org/pdf/2307.09288">“Data Quality is All You Need”</a>. Natural language queries finally thrive with LLMs (though perhaps too enthusiastically). Developers of agent systems now recognize the importance of <a href="https://medium.com/@kyeg/unlocking-structured-outputs-with-agents-8b5a564b5d44">closure and standardization</a> in ensuring stable, end-to-end execution.</p>

<p>In the ever-shifting tech world, databases stand out as a rare bastion of stability—flashy trends come and go, but <strong>foundational principles endure</strong>. For database products, “mastering the fundamentals” (correctness, reliability, efficiency) remains paramount. This doesn’t imply stagnation. Instead, strong foundations empower us to navigate trends confidently. Enter <a href="https://duckdb.org/">DuckDB</a>, a database that marries trend awareness with technical depth. This article explores how DuckDB’s team built a competitive product by <strong>balancing innovation and foundation</strong>.</p>

<hr />

<h1 id="market-trends">Market Trends</h1>
<p>In 2023, MotherDuck founder Jordan Tigani’s blog <a href="https://motherduck.com/blog/big-data-is-dead/">“Big Data is Dead”</a> sparked debate while crystallizing the rationale behind DuckDB’s embedded, lightweight, single-process design.</p>

<h2 id="debunking-big-data-mythsthree-truths">Debunking “Big Data Myths”—Three Truths</h2>
<ol>
  <li><strong>Most organizations don’t have “big” data</strong>. Investor surveys reveal that even large B2B companies manage mere terabytes, with many operating on gigabytes. Internal data from SingleStore and others shows core datasets often fit in single-digit gigabytes. <strong>For most, data scale isn’t the bottleneck</strong>.</li>
</ol>

<p align="center"><img src="/blog/assets/images/2025-04-27-duckdb/1745314131999-6d1a31f8-cce4-4d16-b464-5ba953aab6b7.png" width="600" /></p>
<p><em>(Source: <a href="https://motherduck.com/blog/big-data-is-dead/">Big Data is Dead</a>)</em></p>

<ol>
  <li><strong>Storage-compute imbalance</strong>. Modern architectures decouple storage and compute, but storage grows linearly while compute demand lags. Most analytics focus on recent data, leaving historical datasets underutilized. This “storage obsession” incurs maintenance costs for rarely accessed data.</li>
</ol>

<p align="center"><img src="/blog/assets/images/2025-04-27-duckdb/1745314255837-38a43980-9230-431f-a704-c2f614d68426.png" width="600" /></p>
<p><em>(Source: <a href="https://motherduck.com/blog/big-data-is-dead/">Big Data is Dead</a>)</em></p>

<ol>
  <li><strong>Rapid data value decay</strong>. Business data often loses relevance within weeks. Historical data serves audits or model training, not daily analytics. <strong>“Big data” is a game for the 1%</strong>—most users operate within traditional single-machine capabilities.</li>
</ol>

<p align="center"><img src="/blog/assets/images/2025-04-27-duckdb/1745314228128-11b4dbc0-2b5d-48db-8f65-146e40570add.png" width="600" /></p>
<p><em>(Source: <a href="https://motherduck.com/blog/big-data-is-dead/">Big Data is Dead</a>)</em></p>

<h2 id="the-scale-up-revolution">The Scale-Up Revolution</h2>
<p>The “big data” era emerged when scaling out (distributed clusters) was cheaper than scaling up (powerful single machines). Today, hardware advancements flip this equation:</p>

<ul>
  <li><strong>Memory/storage leaps</strong>: DDR5 RAM hits 70GB/s bandwidth; NVMe SSDs approach DRAM latency.</li>
  <li><strong>Unified architectures</strong>: Apple’s M-series chips fuse CPU/GPU/NPU memory, slashing data movement overhead.</li>
</ul>

<p>Result? Tasks once requiring Hadoop/Spark clusters now run efficiently on single machines. TPC-DS benchmarks show <a href="https://mp.weixin.qq.com/s?__biz=MzU1NTg2ODQ5Nw==&amp;mid=2247489796&amp;idx=1&amp;sn=f12a900681ff4d8ba5eb4aa2b38fc4db&amp;chksm=fa8886daf63e08db5550fe6b4b5a46f42dfdf5fea6700cccb2d843844ce258bde47f4aa4904e#rd">DuckDB outperforming Spark by 3-8x on 100GB datasets with 10x energy efficiency</a>.</p>

<h2 id="large-models-vs-big-data">Large Models vs. Big Data</h2>
<p>Another significant reason for the decline of big data analytics lies in the gradual transition from “big data” to “large models.” As Large Language Models (LLMs) become the new technological cornerstone, the importance of traditional “big data” stacks is being re-evaluated. Large pre-trained models essentially act as <a href="https://arxiv.org/pdf/2309.10668"><strong>compression and distillation</strong> of massive datasets</a>. Insights that previously required labor-intensive analysis of terabytes of data are now embedded within these models. When people increasingly obtain information by querying models like GPT-4 instead of executing complex queries on logs or data warehouses, the underlying data processing and computational paradigms inevitably simplify.</p>

<p>In this landscape, embedded databases like DuckDB thrive. Projects like DeepSeek’s <a href="https://github.com/deepseek-ai/smallpond">smallpond</a> leverage DuckDB for lightweight, high-performance data processing.</p>

<h2 id="duckdbs-ascent">DuckDB’s Ascent</h2>
<p>Born in defiance of the ‘big data’ hype, DuckDB started with a simple insight: nobody was building an embedded analytical database. The chart below shows exactly what the creators saw missing:</p>

<p align="center"><img src="/blog/assets/images/2025-04-27-duckdb/1745315954205-ef8dd17e-184b-4314-8d82-cde9a774a1eb.png" width="600" /></p>
<p><em>(Source：https://dl.acm.org/doi/10.1145/3299869.3320212)</em></p>

<p>Born in 2018, gaining explosive traction by 2022, DuckDB has by 2025 positioned itself as the de facto leader in the analytical processing database arena - an unprecedented rise for an embedded database:</p>
<p align="center"><img src="/blog/assets/images/2025-04-27-duckdb/1745316024111-fd54646d-162c-40d2-8c13-90c017f519a4.png" width="800" /></p>
<p><em>(Source: <a href="https://ossinsight.io/analyze/duckdb/duckdb#overview">OSS Insight</a>)</em></p>

<hr />

<h1 id="product-excellence">Product Excellence</h1>
<p>DuckDB’s success isn’t just about riding the right trends - its killer product features deserve equal credit. While we could write volumes about its capabilities, let‘s highlight the most impressive ones.</p>

<h2 id="zero-copy-data-access">Zero-Copy Data Access</h2>
<p>DuckDB queries external files (CSV, Parquet) without importing data. Its vectorized engine and columnar format enable efficient scans, even with partial HTTP Range requests. For example:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="s1">'data.parquet'</span><span class="p">;</span>
</code></pre></div></div>

<p>Queries run directly on Pandas DataFrames or Arrow data, eliminating data duplication. This “Swiss Army knife” versatility aligns perfectly with data scientists’ workflows.</p>

<p>Queries run directly on Pandas DataFrames or Arrow data, eliminating data duplication. <strong>This “Swiss Army knife” versatility aligns perfectly with data scientists’ workflows</strong>.</p>

<h2 id="httpfs-extension">HTTPFS Extension</h2>
<p>Drawing inspiration from PostgreSQL’s design, DuckDB was architected with extensibility as a first-class citizen from day one. Among its extensions, ​HTTPFS stands out as a stroke of genius. This extension enables direct access to HTTP(S) endpoints and cloud object storage (like S3) - meaning DuckDB can query remote data as if it were local tables, using nothing more than a URL.</p>

<p>For example:</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="k">count</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
<span class="k">FROM</span> <span class="s1">'https://example.com/dataset/file.parquet'</span><span class="p">;</span>
</code></pre></div></div>

<p>DuckDB automatically fetches only the required file segments via HTTP. For columnar formats like Parquet, it goes further by selectively retrieving just the needed columns, dramatically improving efficiency.</p>

<p>This capability effectively complements the “big data” paradigm: users maintain large datasets in the cloud while pulling only relevant subsets for local analysis, even joining them with existing local datasets.</p>

<p>In this quintessential <strong>“edge-cloud integration” scenario</strong>, DuckDB delivers ad-hoc cloud data analysis <strong>without complex middleware</strong> – streamlining data engineering workflows. Wait, isn’t this exactly how “datalakes” were supposed to work all along?</p>

<h2 id="the-ingenious-htap-strategy-of-seamlessly-integrating-oltpolap">The Ingenious HTAP Strategy of Seamlessly Integrating OLTP/OLAP</h2>

<h3 id="the-pitfalls-of-htap">The “Pitfalls” of HTAP</h3>
<p><a href="https://en.wikipedia.org/wiki/Hybrid_transactional/analytical_processing">HTAP, or Hybrid Transactional/Analytical Processing</a>, aims to provide both TP and AP capabilities within a single database. This presents an opportunity for both TP-oriented and AP-oriented databases to expand their business scenarios, making HTAP a fiercely contested battleground in the database market. But is HTAP really that great? Whether extending from TP to HTAP or vice versa, one risks falling into the seemingly sweet “trap” of HTAP:</p>

<ul>
  <li><strong>Storage-Compute Dissonance</strong>: OLTP relies on row-based storage (Row Store) for high-concurrency transactions, while OLAP requires column-based storage (Column Store) to accelerate aggregate computations. Forced integration necessitates maintaining two storage engines (e.g., row-store replicas + column-store replicas), leading to skyrocketing data synchronization overhead and consistency maintenance costs.</li>
  <li><strong>Resource Contention and Performance Degradation</strong>: OLTP’s short transactions (millisecond-level responses) compete with OLAP’s long queries (minute-level computations) for CPU, memory, and I/O resources.</li>
  <li><strong>Technological Conflict</strong>: OLTP emphasizes ACID transactions and row-level locks, whereas OLAP only requires relaxed eventual consistency. For instance, full-table scans in analytical queries may trigger row-store lock contention, causing transactional operations to stall.</li>
</ul>

<h3 id="why-not-leverage-the-big-players">Why Not Leverage the “Big Players”?</h3>
<p>DuckDB’s philosophy is: Instead of forcing a single system to handle both, let systems excelling in transactions and those specializing in analysis each play to their strengths, then bridge them. Thus, PostgreSQL and DuckDB—the two most scalable systems in the TP and AP domains—naturally converge.</p>

<p>On one hand, DuckDB offers the Postgres Scanner extension, which can directly connect to a PostgreSQL database and map its tables as virtual views within DuckDB for querying. This allows DuckDB to act as an analytical accelerator, reading PostgreSQL’s live data without additional replication. This approach avoids the hassles of dual writes and asynchronous synchronization. During queries, data stored in PostgreSQL is efficiently read via its binary protocol, while analytical logic is executed within DuckDB.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">postgres_scan</span><span class="p">(</span><span class="s1">'dbname=myshinydb'</span><span class="p">,</span> <span class="s1">'public'</span><span class="p">,</span> <span class="s1">'mytable'</span><span class="p">);</span>
</code></pre></div></div>

<p>On the other hand, the PostgreSQL ecosystem has seen a wave of extensions enhancing DuckDB’s AP capabilities, including the official pg_duckdb by DuckDB’s team.</p>

<p align="center"><img src="/blog/assets/images/2025-04-27-duckdb/1745323859852-27f3b8fe-8447-4247-9430-4a26ab8d3d7a.png" width="600" /></p>

<p>In <a href="https://github.com/duckdb/pg_duckdb">pg_duckdb</a>’s implementation, DuckDB aligns with PostgreSQL’s logical timestamp synchronization (Logical Timestamp Alignment), ensuring analytical queries are based on the latest consistent snapshot of the transactional database, avoiding dirty reads and phantom reads. Additionally, DuckDB leverages its Postgres Scanner to directly access PostgreSQL’s row-store tables, then uses its vectorized engine to execute OLAP queries, boosting AP performance without data replication. For example, in TPC-H benchmarks, third-party tests showed pg_duckdb achieving over <a href="https://mp.weixin.qq.com/s?__biz=MzIzOTA2NjEzNQ==&amp;mid=2454788670&amp;idx=1&amp;sn=24a3d2f17b8ad32dd7baed15598c4e28&amp;chksm=ff377ebf7a2bfdf64db0980eddcdea4d586ee40f22ec68b865a5d3c464fcd7e745621b811583#rd">1000x performance gains</a> in complex analytical queries compared to native PostgreSQL.</p>

<p><strong>PostgreSQL and DuckDB’s extensibility decouples the technical contradictions of OLTP and OLAP: PostgreSQL focuses on OLTP (e.g., order processing), DuckDB specializes in OLAP (e.g., real-time reporting), and the two achieve logical unity through in-process federated queries (rather than data copying).</strong></p>

<h3 id="graphscopes-attempts">GraphScope’s Attempts</h3>
<p>At this point, I can’t help but reflect on GraphScope’s attempt to extend graph analysis capabilities based on OLTP databases – the <a href="https://github.com/GraphScope/GART">GART project</a> (unfortunately, GART’s latest commits are already six months old).</p>

<p>GART’s original goal was to make OLTP databases the data source for graph analysis:</p>

<p>OLTP databases offer mature data management solutions. In most enterprise applications, cleaned data first lands in OLTP databases (e.g., Ant Group’s OceanBase). Let GraphScope focus on graph analysis while leaving complex data management to mature OLTP databases. This vision aligns perfectly with DuckDB + PostgreSQL = HTAP. However, during GART’s development, GraphScope attempted to integrate graph analysis with transactional processing via real-time graph construction (Binlog parsing), but faced challenges:</p>

<ul>
  <li><strong>Overly Heavy Architecture</strong>: Required maintaining an independent graph storage and compute cluster, with overly long synchronization chains (introducing Kafka + GraphEngine).</li>
  <li>
    <p><strong>Limited Scenarios</strong>: Strong reliance on external data warehouses made lightweight embedded graph analysis difficult. What if we adopted DuckDB and PostgreSQL’s design philosophy? Here’s a potential approach:</p>
  </li>
  <li><strong>Native Graph Operators</strong>: Integrate libgrape-lite (or a lighter single-machine parallel version) via PostgreSQL’s extension interface to enable graph traversal, community detection, and other operations within the transactional database, avoiding cross-system data migration.</li>
  <li><strong>Federated Graph Computing</strong>: Combine DuckDB’s <code class="language-plaintext highlighter-rouge">read_parquet</code> function to directly query graph data (via <a href="https://graphar.apache.org/">GraphAr</a>) from cloud storage.</li>
</ul>

<hr />

<h1 id="product-oriented-extreme-performance">Product-Oriented Extreme Performance</h1>

<p>The previous chapters showcased some of DuckDB’s impressive product capabilities, but behind them all lies one defining characteristic: <strong>speed</strong> – faster than large-scale Spark clusters, faster than PostgreSQL in OLTP scenarios. This performance stems from deliberate system design and architectural choices, such as:</p>

<ul>
  <li><strong>Columnar Storage</strong>: In analytical scenarios, computations typically only require a subset of columns. Traditional row storage would result in mostly inefficient scans, whereas columnar storage minimizes I/O by reading only relevant data.</li>
  <li><strong>Vectorized (Batch) Processing</strong>: Operators process data in batches rather than row-by-row. This reduces function call overhead, improves cache utilization, and leverages modern hardware’s SIMD (Single Instruction Multiple Data) parallelism.</li>
  <li><strong>Zero-Copy Operations</strong>: DuckDB meticulously avoids memory copies during data transformations. For example, when <a href="https://duckdb.org/2021/12/03/duck-arrow.html">reading Arrow data</a>, DuckDB directly operates on Arrow memory buffers, and similarly outputs results in Arrow format. This enables seamless parsing of Arrow data within the query engine and direct Arrow-formatted result exports.</li>
  <li>…</li>
</ul>

<p>While these topics are widely discussed, let’s delve deeper into some of the early design choices highlighted in DuckDB’s research papers.</p>

<hr />

<h2 id="computational-models">Computational Models</h2>

<p>During DuckDB’s development, two dominant computational models existed in the database field — <strong>Vectorized Execution</strong> and <strong>Data-Centric Code Generation (Compiled Execution)</strong> — with significant differences in architecture, performance characteristics, and use cases. Both models are backed by numerous well-known systems:</p>

<ul>
  <li><strong>Vectorized Execution</strong>:
<a href="https://ir.cwi.nl/pub/19958/19958B.pdf">VectorWise</a>, <a href="https://www.redbooks.ibm.com/abstracts/tips1204.html">DB2 BLU</a>, <a href="https://learn.microsoft.com/en-us/sql/relational-databases/indexes/columnstore-indexes-overview?view=sql-server-ver16">Columnar SQL Server</a>, <a href="https://github.com/UWQuickstep/quickstep">Quickstep</a>, etc.</li>
  <li><strong>Compiled Execution</strong>:
<a href="https://tableau.github.io/hyper-db/">HyPer</a>, <a href="https://spark.apache.org/">Apache Spark</a>, <a href="https://db.cs.cmu.edu/peloton/">Peloton</a>, etc.</li>
</ul>

<p>However, comparing these models fairly is challenging. Directly contrasting real-world systems (e.g., HyPer vs. VectorWise) can lead to skewed conclusions due to differences in storage formats, parallelization strategies, etc. The DuckDB team adopted a <strong>unified experimental framework</strong> for an apples-to-apples comparison:</p>

<h3 id="methodology">Methodology</h3>
<ul>
  <li><strong>Unified Framework</strong>: Implemented both models in the same system — <em>Typer</em> (compiled execution) and <em>Tectorwise</em> (vectorized execution) — ensuring identical algorithms, data structures, and parallel frameworks.</li>
  <li><strong>Isolated Variables</strong>: Only the execution engine was altered, eliminating interference from storage compression or optimizer variations.</li>
  <li><strong>Cross-Scenario Validation</strong>: Tested across TPC-H/SSB queries to analyze performance in compute-intensive, memory-bandwidth-sensitive, and other scenarios.</li>
</ul>

<p>Below is their comparative analysis from this <a href="https://www.vldb.org/pvldb/vol11/p2209-kersten.pdf">benchmark paper</a>:</p>

<style>
  .comparison-table {
    width: 100%;
    border-collapse: collapse;
    font-family: Arial, sans-serif;
    margin: 20px 0;
    box-shadow: 0 2px 3px rgba(0,0,0,0.1);
  }
  .comparison-table th {
    background-color: #f2f2f2;
    padding: 12px 15px;
    text-align: left;
    font-weight: bold;
    border-bottom: 2px solid #ddd;
  }
  .comparison-table td {
    padding: 10px 15px;
    border-bottom: 1px solid #ddd;
    vertical-align: top;
    min-width:150px;
  }
  .comparison-table tr:nth-child(even) {
    background-color: #f9f9f9;
  }
  .comparison-table tr:hover {
    background-color: #f1f1f1;
  }
  .comparison-table .dimension {
    font-weight: bold;
    color: #2c3e50;
  }
  .comparison-table .highlight {
    background-color: #e8f4f8;
  }
  @media screen and (max-width: 768px) {
    .comparison-table {
      display: block;
      overflow-x: auto;
    }
  }
</style>

<table class="comparison-table">
  <thead>
    <tr>
      <th>Comparison Dimension</th>
      <th>Vectorized</th>
      <th>Codegen (Compiled)</th>
      <th>Why DuckDB Chose Vectorized</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td colspan="4" class="dimension">Performance Traits</td>
    </tr>
    <tr>
      <td>Compute-Intensive Workloads</td>
      <td>Materializes intermediates; more instructions</td>
      <td>Register-optimized; fewer instructions</td>
      <td class="highlight"><strong>Memory access optimization</strong>: OLAP workloads (e.g., hash joins/aggregations) benefit from lower memory stall cycles.</td>
    </tr>
    <tr>
      <td>Memory-Bound Scenarios</td>
      <td>Batch processing hides cache misses; optimized parallel memory access</td>
      <td>Complex loops limit prefetching/out-of-order execution</td>
      <td></td>
    </tr>
    <tr>
      <td colspan="4" class="dimension">Engineering Practicality</td>
    </tr>
    <tr>
      <td>Compilation Overhead</td>
      <td>No runtime compilation; primitives pre-compiled</td>
      <td>LLVM dynamic compilation adds latency (seconds for complex queries)</td>
      <td class="highlight"><strong>Embedded-friendly</strong>: No wait for JIT compilation; reduces first-run latency.</td>
    </tr>
    <tr>
      <td>Debugging &amp; Profiling</td>
      <td>Isolated performance stats per primitive (e.g., selection/hash functions)</td>
      <td>Fused operators in generated code obscure performance attribution</td>
      <td class="highlight"><strong>Developer-friendly</strong>: Easier for contributors to pinpoint optimizations.</td>
    </tr>
    <tr>
      <td colspan="4" class="dimension">Hardware Compatibility</td>
    </tr>
    <tr>
      <td>SIMD Optimization</td>
      <td>Simple primitives enable manual vectorization (e.g., 8.4x speedup with AVX-512)</td>
      <td>Complex loops rely on compiler auto-vectorization (limited to ICC)</td>
      <td class="highlight"><strong>Future-proof</strong>: Higher potential for SIMD utilization gains.</td>
    </tr>
    <tr>
      <td>Multi-Core Parallelism</td>
      <td>Balanced batch splitting in Morsel-Driven parallelism</td>
      <td>Same framework, but complex code reduces HT efficiency (e.g., low gains on AMD)</td>
      <td class="highlight"><strong>Thread scalability</strong>: More balanced workload distribution.</td>
    </tr>
    <tr>
      <td colspan="4" class="dimension">Functional Extensibility</td>
    </tr>
    <tr>
      <td>OLTP Support</td>
      <td>Inefficient for high-frequency single-row ops</td>
      <td>Compiled stored procedures excel (ideal for HTAP)</td>
      <td class="highlight"><strong>OLAP focus</strong>: DuckDB targets analytics, not deep OLTP optimization.</td>
    </tr>
    <tr>
      <td>Dynamic Optimization</td>
      <td>Supports runtime adaptation (e.g., dynamic aggregation)</td>
      <td>Logic hardcoded in generated code; requires recompilation</td>
      <td class="highlight"><strong>Flexibility</strong>: Adapts to dynamic workloads.</td>
    </tr>
    <tr>
      <td colspan="4" class="dimension">Storage Synergy</td>
    </tr>
    <tr>
      <td>Storage Synergy</td>
      <td>Native fit for columnar formats (e.g., RLE/Dictionary)</td>
      <td>Requires type conversion/decompression (added overhead)</td>
      <td class="highlight"><strong>Columnar ecosystem</strong>: Reduces intermediate data materialization.</td>
    </tr>
  </tbody>
</table>

<p>Thus, DuckDB’s choice of vectorized execution was based on a <strong>systematic, comprehensive, textbook-grade evaluation</strong> — even though <a href="https://homepages.cwi.nl/~boncz/">Peter Boncz</a>, a pioneer of vectorized execution, was an early core advisor to DuckDB.</p>

<hr />

<h2 id="high-efficiency-mvcc-implementation">High-Efficiency MVCC Implementation</h2>

<p>As an embedded database designed for analytical workloads, DuckDB’s concurrency control mechanism fundamentally differs from traditional OLTP databases. To address batch updates, columnar operations, high compression storage, and embedded lightweight requirements in analytical scenarios, DuckDB deeply optimized its <a href="https://15721.courses.cs.cmu.edu/spring2019/papers/04-mvcc2/p677-neumann.pdf">MVCC implementation strategy</a> developed by the one and only <a href="https://en.wikipedia.org/wiki/Thomas_Neumann">Thomas Neumann</a>, primarily solving:</p>

<ul>
  <li><strong>Massive version management overhead</strong>: Traditional row-level MVCC generates excessive redundant version data during batch updates</li>
  <li><strong>Columnar compression vs. update conflicts</strong>: Compressed column data cannot be updated in-place, requiring avoidance of frequent decompression/recompression</li>
  <li><strong>Resource constraints in embedded scenarios</strong>: Ensuring transaction efficiency under memory/storage limitations</li>
  <li><strong>Analytical transaction characteristics</strong>: Coexistence needs of long-running batch operations and high-concurrency queries</li>
</ul>

<p>Below summarizes DuckDB’s innovative MVCC designs:</p>

<h3 id="optimizations-for-analytical-workloads"><strong>Optimizations for Analytical Workloads</strong></h3>

<ul>
  <li><strong>Columnar Batch Granularity</strong>
    <ul>
      <li>Row-level versions create massive Undo records during batch updates, consuming memory and incurring high scan costs</li>
      <li>DuckDB uses “per 2048-row × per-column version metadata” to record entire batch modifications at once</li>
    </ul>
  </li>
  <li><strong>Storing Deltas Instead of Old Values</strong>
    <ul>
      <li>Compressed pages cannot be modified in-place; Undo Buffer only records “change descriptions” while keeping old versions in original compressed blocks, minimizing write amplification</li>
    </ul>
  </li>
  <li>​<strong>Write Amplification-Minimized WAL/Checkpoint</strong>
    <ul>
      <li>Bulk inserts (e.g., COPY 10GB CSV) first write directly to new data blocks, then log “block references” in WAL; commits atomically replace blocks, while rollbacks mark blocks as recyclable (avoiding “double writes”)</li>
      <li>Default 16MB WAL threshold triggers auto-checkpoint (manual <code class="language-plaintext highlighter-rouge">CHECKPOINT</code> supported); <code class="language-plaintext highlighter-rouge">fsync</code> enforced pre-write for durability</li>
    </ul>
  </li>
</ul>

<h3 id="lightweight--embedded-design"><strong>Lightweight &amp; Embedded Design</strong></h3>

<ul>
  <li><strong>Minimal Metadata</strong>: 2048-row batch versions + columnar deltas ensure “zero cost when unmodified,” with memory usage scaling linearly only with modifications</li>
  <li><strong>Fast Startup</strong>: Undo Buffer stored at data page tail; recovery only needs incremental WAL parsing. DuckDB survived 4000 TPCH refresh cycles in <a href="https://github.com/dsrhaslab/lazyfs">LazyFS</a> power-failure/kill-process tests with zero data loss</li>
  <li><strong>Compression-Friendly</strong>: Version info is separated from data, keeping original column blocks compressed (no MVCC-triggered decompression/rewrites)</li>
  <li><strong>Single-Machine Concurrency</strong>: Read transactions never block; conflicting batch writes auto-retry without lock contention</li>
</ul>

<p>This design enables DuckDB to deliver ​<strong>near-zero-cost concurrent transactions</strong> and ​<strong>analytical-grade throughput</strong> in single-machine memory environments, meeting modern data science and local embedded applications’ demands for “lightweight, compressed, ready-to-use” performance.</p>

<hr />

<h2 id="compilation-optimization-focused-efficiency-where-it-matters-most">Compilation Optimization: Focused Efficiency Where It Matters Most</h2>

<p>Traditional database systems rely on “heavyweight” optimizers, while DuckDB implements lightweight yet <strong>most</strong>-practical optimization rules specifically tailored for embedded scenarios. For comparison, we examined the compiled file sizes of DuckDB versus two well-known optimization frameworks in the industry: <a href="https://github.com/apache/calcite">Calcite</a> and <a href="https://github.com/greenplum-db/gporca-archive">ORCA</a>:</p>

<p align="center"><img src="/blog/assets/images/2025-04-27-duckdb/1745734878763-11ecef7d-9eb8-4620-9005-13fe7dcdbb5a.png" width="600" /></p>

<p>Clearly, these optimization frameworks are overly bulky for DuckDB’s needs. Although DuckDB’s engineers and researchers fully understand <a href="https://duckdb.org/2024/11/14/optimizers.html">the importance of query optimization for data systems, especially in analytical scenarios</a>, they didn’t blindly pursue optimization perfection in their implementation. Instead, they strategically allocated their limited resources to the most critical areas, aligning with their vision of a “lightweight embedded analytical engine.” They achieved an elegant balance between optimization capability and resource consumption through multi-layered architectural innovations. Here are two particularly intentional design choices:</p>

<h3 id="rule-first-heuristic-optimization-framework"><strong>Rule-First Heuristic Optimization Framework</strong></h3>
<p>DuckDB employs a two-stage heuristic optimization architecture:
	- <strong>First Stage</strong>: Applies deterministic rewrite rules (e.g., predicate pushdown, expression simplification) based on logical equivalence, ensuring execution plan safety with minimal overhead (O(1) time complexity).
 	- <strong>Second Stage</strong>: Performs lightweight statistics-based cost optimization, focusing only on critical paths (e.g., join ordering) with limited search scope. Dynamic pruning strategies keep optimization time within milliseconds.</p>

<h3 id="statistics-independent-cardinality-estimation-model"><strong>Statistics-Independent Cardinality Estimation Model</strong></h3>
<p>DuckDB addresses the challenge of computing/missing statistics in embedded scenarios (e.g., when querying Parquet/CSV files directly where histograms can’t be precomputed) by introducing:</p>
<ul>
  <li><strong>Foreign Key Inference Engine</strong>: Automatically detects implied PK-FK relationships in schemas to build dynamic equivalence sets.</li>
  <li><strong>Selectivity Propagation Model</strong>: Enables multi-table join cardinality estimation via chain calculations like <code class="language-plaintext highlighter-rouge">card(A⋈B) = card(A) * card(B) / tdom</code>, achieving over 90% accuracy without stored statistics.</li>
</ul>

<hr />

<h1 id="conclusion">Conclusion</h1>

<p>DuckDB didn’t just ride the “big data backlash” —- it weaponized it using a good product. By combining:</p>
<ul>
  <li>​<strong>Vectorized Execution</strong> (2-8x faster than Spark on 100GB datasets)</li>
  <li>​<strong>Zero-Copy Workflows</strong> (Arrow/Parquet as first-class citizens)</li>
  <li>​<strong>PostgreSQL Symbiosis</strong> (1000x+ OLAP speedups via <code class="language-plaintext highlighter-rouge">postgres_scan()</code>)
…it redefined what’s possible in single-node analytics, achieving 90% of “big data” outcomes with 10% of the complexity.</li>
</ul>

<p>DuckDB’s success signals a paradigm shift:</p>

<table>
  <thead>
    <tr>
      <th>Era</th>
      <th>Dogma</th>
      <th>DuckDB’s Answer</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>​<strong>2000s</strong></td>
      <td>“Normalize all data”</td>
      <td>“Query raw Parquet”</td>
    </tr>
    <tr>
      <td>​<strong>2010s</strong></td>
      <td>“Scale out or die”</td>
      <td>“Scale up smarter”</td>
    </tr>
    <tr>
      <td>​<strong>2020s</strong></td>
      <td>“ETL everything”</td>
      <td>“Embed everywhere”</td>
    </tr>
  </tbody>
</table>

<p>As LLMs democratize data access, DuckDB’s ​<strong>“small-data engine for a small-data world”</strong> approach becomes prescient. The future belongs not to systems that demand data centralization, but to those that ​<strong>dissolve into the workflow</strong> – invisible until needed, indispensable when used.</p>

<hr />

<h1 id="references">References</h1>
<ul>
  <li><a href="https://dl.acm.org/doi/10.1145/3555041.3589336">49 Years of Query</a></li>
  <li><a href="https://www.cs.cmu.edu/~pavlo/blog/2025/01/2024-databases-retrospective.html">Databases in 2024: A Year in Review</a></li>
  <li><a href="https://motherduck.com/blog/big-data-is-dead/">Big data is dead</a></li>
  <li><a href="https://arxiv.org/abs/2309.10668">Language Modeling Is Compression</a></li>
  <li><a href="https://www.vldb.org/pvldb/vol11/p2209-kersten.pdf">Everything You Always Wanted to Know About Compiled and Vectorized Queries But Were Afraid to Ask</a></li>
  <li><a href="https://duckdb.org/2024/10/30/analytics-optimized-concurrent-transactions.html">Analytics-Optimized Concurrent Transactions</a></li>
  <li><a href="https://homepages.cwi.nl/~boncz/msc/2022-TomEbergen.pdf">Join Order Optimization with (Almost) No Statistics</a></li>
  <li><a href="https://duckdb.org/2024/11/14/optimizers.html#expression-rewriter">Optimizers: The Low-Key MVP</a></li>
</ul>


        </section>

        

        <!-- <footer class="post-footer"> -->
        <!-- If we want to display author's name and bio -->
        <!-- 
                <figure class="author-image">
                    <a class="img" href="/blog/" style="background-image: url(/blog/assets/images/profile.png)">
                    <span class="hidden">GSTeam@Alibaba's Picture</span></a>
                </figure>
                <section class="author">
                    Author Name
                    <h4> GSTeam@Alibaba </h4>
                    Author Bio
                    <p>
                        Here goes the author description. You might want to place some links too in here
                    </p>
                </section>
             -->

        <!-- Share links section -->
        <!-- <section class="share">
    <h4>Share this post</h4>
    <a class="icon-twitter" href="http://twitter.com/share?text=Why DuckDB Is Such A Good Database Product&amp;url=https://graphscope.io/tech/2025/04/26/Why-DuckDB-Is-Such-A-Good-Database-Product.html"
        onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
        <span class="hidden">Twitter</span>
    </a>
    <a class="icon-facebook" href="https://www.facebook.com/sharer/sharer.php?u=https://graphscope.io/tech/2025/04/26/Why-DuckDB-Is-Such-A-Good-Database-Product.html"
        onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
        <span class="hidden">Facebook</span>
    </a>
    <a class="icon-google-plus" href="https://plus.google.com/share?url=https://graphscope.io/tech/2025/04/26/Why-DuckDB-Is-Such-A-Good-Database-Product.html"
       onclick="window.open(this.href, 'google-plus-share', 'width=490,height=530');return false;">
        <span class="hidden">Google+</span>
    </a>
</section> -->

        <!-- Disqus comments -->
        <!--  -->

        <!-- </footer> -->

    </article>

</main>
    <footer class="site-footer clearfix">
      <section class="copyright">
        <a href="/blog">GraphScope</a> &copy; 
              2025 &bull; Some images by <a href="https://www.freepik.com">Freepik</a>.
      </section>
      <section class="poweredby">Made with Jekyll using 
        <a href="http://github.com/rosario/kasper">Kasper theme</a>
      </section>
    </footer>

    <script type="text/javascript" src="/blog/assets/js/jquery-1.11.1.min.js"></script>
    <script type="text/javascript" src="/blog/assets/js/jquery.fitvids.js"></script>
    <script type="text/javascript" src="/blog/assets/js/index.js"></script>

    <!-- Google Analytics Tracking code -->
    <script type="text/javascript">

      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'G-5V27DVHLP0']);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();

    </script>   

    <!-- Baidu analytics code -->
    <script>
      var _hmt = _hmt || [];
      (function() {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?da649ade2298891886e31922dfc8870f";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
      })();
    </script>

    <!-- MathJax code -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [ ['$', '$'], ['\\(', '\\)'] ]
        },
        svg: {
          fontCache: 'global'
        }
      };
    </script>
    <script
      type="text/javascript" id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
    </script>
</body>
</html>
