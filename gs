#!/usr/bin/env bash
# This script was generated by bashly 1.0.4 (https://bashly.dannyb.co)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if [[ "${BASH_VERSINFO:-0}" -lt 4 ]]; then
  printf "bash version 4 or higher is required. If you are using macOS, please run 'brew install bash && bash' to upgrade bash.\n" >&2
  exit 1
fi

# :command.master_script

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
gs_usage() {
  if [[ -n $long_usage ]]; then
    printf "gs - A bash utility for GraphScope\n"
    echo

  else
    printf "gs - A bash utility for GraphScope\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  gs COMMAND\n"
  printf "  gs [COMMAND] --help | -h\n"
  printf "  gs --version | -v\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   Build GraphScope on local.\n" "make        "
  printf "  %s   Build GraphScope docker images.\n" "make-image  "
  printf "  %s   Open a develop environment with docker.\n" "dev         "
  printf "  %s   Run tests of graphscope\n" "test        "
  printf "  %s   Install dependencies on local machine.\n" "install-deps"
  printf "  %s   \n" "format      "
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo
    printf "  %s\n" "--version, -v"
    printf "    Show version number\n"
    echo

    # :command.usage_environment_variables
    printf "%s\n" "Environment Variables:"

    # :environment_variable.usage
    printf "  %s\n" "GRAPHSCOPE_HOME (required)"
    printf "    Installed HOME for GraphScope.\n"
    echo

    # :environment_variable.usage
    printf "  %s\n" "GRAPHSCOPE_ENV"
    printf "    One of dev, prod.\n"
    printf "    Default: dev\n"
    echo

    # :command.footer
    printf "GraphScope is open sourced at https://github.com/alibaba/GraphScope\nby DAMO Academy, Alibaba Group.\n\n"
    echo

  fi
}

# :command.usage
gs_make_usage() {
  if [[ -n $long_usage ]]; then
    printf "gs make - Build GraphScope on local.\n"
    echo

  else
    printf "gs make - Build GraphScope on local.\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  gs make [COMPONENT] [OPTIONS]\n"
  printf "  gs make --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--install-prefix PREFIX"
    printf "    Install dependency files to [prefix]. By default, './gs make install' will\n    install all the files in '/opt/graphscope/bin', '/opt/graphscope/lib' etc.\n    You can specify an installation prefix other than '/opt/graphscope' using\n    '--install-prefix', for instance '--install-prefix=\$HOME'.\n"
    printf "    Default: /opt/graphscope\n"
    echo

    # :flag.usage
    printf "  %s\n" "--storage-type STORAGE_TYPE"
    printf "    make gie with specified storage type\n"
    printf "    Default: default\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "COMPONENT"
    printf "    component to build.\n"
    printf "    Allowed: all, install, analytical, analytical-java, interactive, learning, analytical-install, analytical-java-install, interactive-install, learning-install, client, coordinator, clean\n"
    printf "    Default: all\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  gs make analytical\n"
    printf "  gs make interactive -DskipTests\n"
    printf "  gs make install\n"
    echo

  fi
}

# :command.usage
gs_make_image_usage() {
  if [[ -n $long_usage ]]; then
    printf "gs make-image - Build GraphScope docker images.\n"
    echo

  else
    printf "gs make-image - Build GraphScope docker images.\n"
    echo

  fi

  printf "Alias: mi\n"
  echo

  printf "%s\n" "Usage:"
  printf "  gs make-image IMAGE [OPTIONS]\n"
  printf "  gs make-image --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--registry REGISTRY"
    printf "    registry name\n"
    printf "    Default: registry.cn-hongkong.aliyuncs.com\n"
    echo

    # :flag.usage
    printf "  %s\n" "--tag TAG"
    printf "    image tag name to build\n"
    printf "    Default: latest\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "IMAGE"
    printf "    Images to build.\n"
    printf "    Allowed: all, graphscope-dev, coordinator, analytical, analytical-java, interactive, interactive-frontend, interactive-executor, learning, vineyard-dev, vineyard-runtime\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  gs make-image graphscope-dev\n"
    printf "  gs make-image analytical --registry registry.cn-hongkong.aliyuncs.com\n"
    printf "  gs make-image analytical --registry docker.io\n"
    echo

  fi
}

# :command.usage
gs_dev_usage() {
  if [[ -n $long_usage ]]; then
    printf "gs dev - Open a develop environment with docker.\n"
    echo

  else
    printf "gs dev - Open a develop environment with docker.\n"
    echo

  fi

  printf "Alias: d\n"
  echo

  printf "%s\n" "Usage:"
  printf "  gs dev [OPTIONS]\n"
  printf "  gs dev --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--local, -l LOCAL"
    printf "    Local path to the source code of GraphScope.\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  gs dev\n"
    printf "  gs dev --local ~/graphscope\n"
    echo

  fi
}

# :command.usage
gs_test_usage() {
  if [[ -n $long_usage ]]; then
    printf "gs test - Run tests of graphscope\n"
    echo

  else
    printf "gs test - Run tests of graphscope\n"
    echo

  fi

  printf "Alias: t\n"
  echo

  printf "%s\n" "Usage:"
  printf "  gs test [TYPE] [OPTIONS]\n"
  printf "  gs test --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--local"
    printf "    Run local tests\n"
    echo

    # :flag.usage
    printf "  %s\n" "--storage-type STORAGE_TYPE"
    printf "    test gie with specified storage type\n"
    printf "    Default: default\n"
    echo

    # :flag.usage
    printf "  %s\n" "--k8s"
    printf "    Run k8s tests\n"
    echo

    # :flag.usage
    printf "  %s\n" "--nx"
    printf "    Run nx tests\n"
    echo

    # :flag.usage
    printf "  %s\n" "--testdata DIRECTORY"
    printf "    assign a custom test data location. This could be cloned from\n    https://github.com/graphscope/gstest\n"
    printf "    Default: /tmp/gstest\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "TYPE"
    printf "    test a subset of the codebase, organized by components.\n"
    printf "    Allowed: analytical, analytical-java, interactive, learning, local-e2e, k8s-e2e, groot\n"
    echo

  fi
}

# :command.usage
gs_install_deps_usage() {
  if [[ -n $long_usage ]]; then
    printf "gs install-deps - Install dependencies on local machine.\n"
    echo

  else
    printf "gs install-deps - Install dependencies on local machine.\n"
    echo

  fi

  printf "Alias: i\n"
  echo

  printf "%s\n" "Usage:"
  printf "  gs install-deps TYPE [OPTIONS]\n"
  printf "  gs install-deps --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--cn"
    printf "    Whether to use CN located mirrors to speed up download.\n"
    echo

    # :flag.usage
    printf "  %s\n" "--from-local, -l DIRECTORY"
    printf "    Find raw dependencies of GraphScope from a local directory. The raw\n    dependencies would then be built and installed to [prefix]. If the directory\n    is empty or not exists, dependency files would be downloaded to [directory].\n"
    printf "    Default: /tmp/gs-local-deps\n"
    echo

    # :flag.usage
    printf "  %s\n" "--install-prefix PREFIX"
    printf "    Install dependency files to [prefix]. By default, './gs install-deps dev'\n    will install all the files in '/opt/graphscope/bin', '/opt/graphscope/lib'\n    etc. You can specify an installation prefix other than '/opt/graphscope'\n    using '--install-prefix', for instance '--install-prefix=\$HOME'.\n"
    printf "    Default: /opt/graphscope\n"
    echo

    # :flag.usage
    printf "  %s\n" "--v6d-version V6D-VERSION"
    printf "    v6d version to clone\n"
    printf "    Default: main\n"
    echo

    # :flag.usage
    printf "  %s\n" "--jobs, -j JOBS"
    printf "    Concurrent jobs in building, i.e., -j argument passed to make.\n"
    echo

    # :flag.usage
    printf "  %s\n" "--for-analytical"
    printf "    Only install analytical engine dependencies\n"
    echo

    # :flag.usage
    printf "  %s\n" "--no-v6d"
    printf "    Do not install v6d, for build base docker images, could only be used with\n    '--for-analytical'\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "TYPE"
    printf "    dependencies for development or client\n"
    printf "    Allowed: dev, client\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  gs install-deps client\n"
    printf "  gs install-deps dev\n"
    printf "  gs install-deps dev --cn\n"
    printf "  gs install-deps dev --cn -j 6\n"
    printf "  gs install-deps dev --from-local ~/Downloads/gs-all-deps\n"
    printf "  gs install-deps dev --install-prefix ~/gs\n"
    echo

  fi
}

# :command.usage
gs_format_usage() {
  if [[ -n $long_usage ]]; then
    printf "gs format\n"
    echo

  else
    printf "gs format\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  gs format LANG\n"
  printf "  gs format --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "LANG"
    printf "    format which part of languages\n"
    printf "    Allowed: cpp, java, python, rust\n"
    echo

  fi
}

# :command.normalize_input
normalize_input() {
  local arg flags

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    else
      input+=("$arg")
    fi

    shift
  done
}
# :command.inspect_args
inspect_args() {
  if ((${#args[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
    echo args:
    for k in "${sorted_keys[@]}"; do echo "- \${args[$k]} = ${args[$k]}"; done
  else
    echo args: none
  fi

  if ((${#other_args[@]})); then
    echo
    echo other_args:
    echo "- \${other_args[*]} = ${other_args[*]}"
    for i in "${!other_args[@]}"; do
      echo "- \${other_args[$i]} = ${other_args[$i]}"
    done
  fi

  if ((${#deps[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!deps[@]}" | sort)
    echo
    echo deps:
    for k in "${sorted_keys[@]}"; do echo "- \${deps[$k]} = ${deps[$k]}"; done
  fi

}

# :command.user_lib
# src/lib/colors.sh
print_in_color() {
  local color="$1"
  shift
  if [[ -z ${NO_COLOR+x} ]]; then
    printf "$color%b\e[0m\n" "$*";
  else
    printf "%b\n" "$*";
  fi
}

red() { print_in_color "\e[31m" "$*"; }
green() { print_in_color "\e[32m" "$*"; }
yellow() { print_in_color "\e[33m" "$*"; }
blue() { print_in_color "\e[34m" "$*"; }
magenta() { print_in_color "\e[35m" "$*"; }
cyan() { print_in_color "\e[36m" "$*"; }
bold() { print_in_color "\e[1m" "$*"; }
underlined() { print_in_color "\e[4m" "$*"; }
red_bold() { print_in_color "\e[1;31m" "$*"; }
green_bold() { print_in_color "\e[1;32m" "$*"; }
yellow_bold() { print_in_color "\e[1;33m" "$*"; }
blue_bold() { print_in_color "\e[1;34m" "$*"; }
magenta_bold() { print_in_color "\e[1;35m" "$*"; }
cyan_bold() { print_in_color "\e[1;36m" "$*"; }
red_underlined() { print_in_color "\e[4;31m" "$*"; }
green_underlined() { print_in_color "\e[4;32m" "$*"; }
yellow_underlined() { print_in_color "\e[4;33m" "$*"; }
blue_underlined() { print_in_color "\e[4;34m" "$*"; }
magenta_underlined() { print_in_color "\e[4;35m" "$*"; }
cyan_underlined() { print_in_color "\e[4;36m" "$*"; }

# src/lib/get_os_version.sh
get_os_version() {
  if [ -f /etc/os-release ]; then
    # freedesktop.org and systemd
    . /etc/os-release
    PLATFORM="${NAME}"
    OS_VERSION="${VERSION_ID}"
  elif type lsb_release >/dev/null 2>&1; then
    # linuxbase.org
    PLATFORM=$(lsb_release -si)
    OS_VERSION=$(lsb_release -sr)
  elif [ -f /etc/lsb-release ]; then
    # For some versions of Debian/Ubuntu without lsb_release command
    . /etc/lsb-release
    PLATFORM="${DISTRIB_ID}"
    OS_VERSION="${DISTRIB_RELEASE}"
  elif [ -f /etc/debian_version ]; then
    # Older Debian/Ubuntu/etc.
    PLATFORM=Debian
    OS_VERSION=$(cat /etc/debian_version)
  elif [ -f /etc/centos-release ]; then
    # Older Red Hat, CentOS, etc.
    PLATFORM=CentOS
    OS_VERSION=$(sed 's/.* \([0-9]\).*/\1/' < /etc/centos-release)
  else
    # Fall back to uname, e.g. "Linux <version>", also works for BSD, Darwin, etc.
    PLATFORM=$(uname -s)
    OS_VERSION=$(uname -r)
  fi
  echo "$PLATFORM-$OS_VERSION"
}

# src/lib/install_thirdparty_dependencies.sh
install_cmake() {
  workdir=$1
  install_prefix=$2

  if [[ -f "${install_prefix}/bin/cmake" ]]; then
    log "cmake already installed, skip."
    return 0
  fi

  ARCH=$(uname -m)
  file="cmake-3.24.3-linux-${ARCH}.sh"
  log "Building and installing ${file}."
  pushd "${workdir}" || exit

  url="https://github.com/Kitware/CMake/releases/download/v3.24.3"
  url=$(maybe_set_to_cn_url ${url})
  [ ! -f "${file}" ] &&
    fetch_source "${file}" "${url}"
  bash "${file}" --prefix="${install_prefix}" --skip-license
  popd || exit
  cleanup_files "${workdir}/${file}"
}

install_open_mpi() {
  workdir=$1
  install_prefix=$2
  MPI_PREFIX="/opt/openmpi"  # fixed, related to coordinator/setup.py

  if [[ -f "${install_prefix}/include/mpi.h" ]]; then
    log "openmpi already installed, skip."
    return 0
  fi

  directory="openmpi-4.0.5"
  file="openmpi-4.0.5.tar.gz"
  url="https://download.open-mpi.org/release/open-mpi/v4.0"
  url=$(maybe_set_to_cn_url ${url})
  log "Building and installing ${directory}."
  pushd "${workdir}" || exit
  download_tar_and_untar_if_not_exists ${directory} ${file} "${url}"
  pushd ${directory} || exit

  ./configure --enable-mpi-cxx --disable-dlopen --prefix=${MPI_PREFIX}
  make -j$(nproc)
  make install
  popd || exit
  popd || exit
  cp -rs ${MPI_PREFIX}/* "${install_prefix}"
  cleanup_files "${workdir}/${directory}" "${workdir}/${file}"
}

install_gflags() {
  workdir=$1
  install_prefix=$2

  if [[ -f "${install_prefix}/include/gflags/gflags.h" ]]; then
    log "gflags already installed, skip."
    return 0
  fi

  directory="gflags-2.2.2"
  file="v2.2.2.tar.gz"
  url="https://github.com/gflags/gflags/archive"
  url=$(maybe_set_to_cn_url ${url})
  log "Building and installing gflags-2.2.2."
  pushd "${workdir}" || exit
  download_tar_and_untar_if_not_exists ${directory} ${file} "${url}"
  pushd ${directory} || exit

  cmake . -DCMAKE_INSTALL_PREFIX="${install_prefix}" \
          -DCMAKE_PREFIX_PATH="${install_prefix}" \
          -DBUILD_SHARED_LIBS=ON
  make -j$(nproc)
  make install
  popd || exit
  popd || exit
  cleanup_files "${workdir}/${directory}" "${workdir}/${file}"
}

install_glog() {
  workdir=$1
  install_prefix=$2

  if [[ -f "${install_prefix}/include/glog/logging.h" ]]; then
    log "glog already installed, skip."
    return 0
  fi

  directory="glog-0.6.0"
  file="v0.6.0.tar.gz"
  url="https://github.com/google/glog/archive"
  url=$(maybe_set_to_cn_url ${url})
  log "Building and installing ${directory}."
  pushd "${workdir}" || exit
  download_tar_and_untar_if_not_exists ${directory} ${file} "${url}"
  pushd ${directory} || exit

  cmake . -DCMAKE_INSTALL_PREFIX="${install_prefix}" \
          -DCMAKE_PREFIX_PATH="${install_prefix}" \
          -DBUILD_SHARED_LIBS=ON
  make -j$(nproc)
  make install
  popd || exit
  popd || exit
  cleanup_files "${workdir}/${directory}" "${workdir}/${file}"
}

install_apache_arrow() {
  workdir=$1
  install_prefix=$2

  if [[ -f "${install_prefix}/include/arrow/api.h" ]]; then
    log "apache-arrow already installed, skip."
    return 0
  fi

  directory="arrow-apache-arrow-10.0.1"
  file="apache-arrow-10.0.1.tar.gz"
  url="https://github.com/apache/arrow/archive"
  url=$(maybe_set_to_cn_url ${url})
  log "Building and installing ${directory}."
  pushd "${workdir}" || exit
  download_tar_and_untar_if_not_exists ${directory} ${file} "${url}"
  pushd ${directory} || exit

  cmake ./cpp \
    -DCMAKE_PREFIX_PATH="${install_prefix}" \
    -DCMAKE_INSTALL_PREFIX="${install_prefix}" \
    -DARROW_COMPUTE=ON \
    -DARROW_WITH_UTF8PROC=OFF \
    -DARROW_CSV=ON \
    -DARROW_CUDA=OFF \
    -DARROW_DATASET=OFF \
    -DARROW_FILESYSTEM=ON \
    -DARROW_FLIGHT=OFF \
    -DARROW_GANDIVA=OFF \
    -DARROW_HDFS=OFF \
    -DARROW_JSON=OFF \
    -DARROW_ORC=OFF \
    -DARROW_PARQUET=OFF \
    -DARROW_PLASMA=OFF \
    -DARROW_PYTHON=OFF \
    -DARROW_S3=OFF \
    -DARROW_WITH_BZ2=OFF \
    -DARROW_WITH_ZLIB=OFF \
    -DARROW_WITH_LZ4=OFF \
    -DARROW_WITH_SNAPPY=OFF \
    -DARROW_WITH_ZSTD=OFF \
    -DARROW_WITH_BROTLI=OFF \
    -DARROW_IPC=ON \
    -DARROW_BUILD_BENCHMARKS=OFF \
    -DARROW_BUILD_EXAMPLES=OFF \
    -DARROW_BUILD_INTEGRATION=OFF \
    -DARROW_BUILD_UTILITIES=OFF \
    -DARROW_BUILD_TESTS=OFF \
    -DARROW_ENABLE_TIMING_TESTS=OFF \
    -DARROW_FUZZING=OFF \
    -DARROW_USE_ASAN=OFF \
    -DARROW_USE_TSAN=OFF \
    -DARROW_USE_UBSAN=OFF \
    -DARROW_JEMALLOC=OFF \
    -DARROW_BUILD_SHARED=ON \
    -DARROW_BUILD_STATIC=OFF
  make -j$(nproc)
  make install
  popd || exit
  popd || exit
  cleanup_files "${workdir}/${directory}" "${workdir}/${file}"
}

install_boost() {
  workdir=$1
  install_prefix=$2

  if [[ -f "${install_prefix}/include/boost/version.hpp" ]]; then
    log "boost already installed, skip."
    return 0
  fi

  directory="boost_1_74_0"
  file="${directory}.tar.gz"
  url="https://boostorg.jfrog.io/artifactory/main/release/1.74.0/source"
  url=$(maybe_set_to_cn_url ${url})
  log "Building and installing ${directory}."
  pushd "${workdir}" || exit
  download_tar_and_untar_if_not_exists ${directory} ${file} "${url}"
  pushd ${directory} || exit

  ./bootstrap.sh --prefix="${install_prefix}" \
    --with-libraries=system,filesystem,context,program_options,regex,thread,random,chrono,atomic,date_time
  ./b2 install link=shared runtime-link=shared variant=release threading=multi
  popd || exit
  popd || exit
  cleanup_files "${workdir}/${directory}" "${workdir}/${file}"
}

install_openssl() {
  workdir=$1
  install_prefix=$2

  if [[ -f "${install_prefix}/include/openssl/ssl.h" ]]; then
    log "openssl already installed, skip."
    return 0
  fi

  directory="openssl-OpenSSL_1_1_1k"
  file="OpenSSL_1_1_1k.tar.gz"
  url="https://github.com/openssl/openssl/archive"
  url=$(maybe_set_to_cn_url ${url})
  log "Building and installing ${directory}."
  pushd "${workdir}" || exit
  download_tar_and_untar_if_not_exists ${directory} ${file} "${url}"
  pushd ${directory} || exit

  ./config --prefix="${install_prefix}" -fPIC -shared
  make -j$(nproc)
  make install
  popd || exit
  popd || exit
  cleanup_files "${workdir}/${directory}" "${workdir}/${file}"
}

install_openssl_static() {
  workdir=$1
  install_prefix=$2

  if [[ -f "${install_prefix}/include/openssl/ssl.h" ]]; then
    log "openssl already installed, skip."
    return 0
  fi

  directory="openssl-OpenSSL_1_1_1k"
  file="OpenSSL_1_1_1k.tar.gz"
  url="https://github.com/openssl/openssl/archive"
  url=$(maybe_set_to_cn_url ${url})
  log "Building and installing ${directory}."
  pushd "${workdir}" || exit
  download_tar_and_untar_if_not_exists ${directory} ${file} "${url}"
  pushd ${directory} || exit

  ./config --prefix="${install_prefix}" no-shared -fPIC
  make -j$(nproc)
  make install
  popd || exit
  popd || exit
  cleanup_files "${workdir}/${directory}" "${workdir}/${file}"
}

install_zlib() {
  workdir=$1
  install_prefix=$2

  if [[ -f "${install_prefix}/include/zlib.h" ]]; then
    log "zlib already installed, skip."
    return 0
  fi

  directory="zlib-1.2.11"
  file="v1.2.11.tar.gz"
  url="https://github.com/madler/zlib/archive"
  url=$(maybe_set_to_cn_url ${url})
  log "Building and installing ${directory}."
  pushd "${workdir}" || exit
  download_tar_and_untar_if_not_exists ${directory} ${file} "${url}"
  pushd ${directory} || exit

  cmake . -DCMAKE_INSTALL_PREFIX="${install_prefix}" \
          -DCMAKE_PREFIX_PATH="${install_prefix}" \
          -DBUILD_SHARED_LIBS=ON
  make -j$(nproc)
  make install
  popd || exit
  popd || exit
  cleanup_files "${workdir}/${directory}" "${workdir}/${file}"
}

install_protobuf() {
  workdir=$1
  install_prefix=$2

  if [[ -f "${install_prefix}/include/google/protobuf/port.h" ]]; then
    log "protobuf already installed, skip."
    return 0
  fi

  directory="protobuf-21.9"
  file="protobuf-all-21.9.tar.gz"
  url="https://github.com/protocolbuffers/protobuf/releases/download/v21.9"
  url=$(maybe_set_to_cn_url ${url})
  log "Building and installing ${directory}."
  pushd "${workdir}" || exit
  download_tar_and_untar_if_not_exists ${directory} ${file} "${url}"
  pushd ${directory} || exit

  ./configure --prefix="${install_prefix}" --enable-shared --disable-static
  make -j$(nproc)
  make install
  popd || exit
  popd || exit
  cleanup_files "${workdir}/${directory}" "${workdir}/${file}"
}

install_grpc() {
  workdir=$1
  install_prefix=$2

  if [[ -f "${install_prefix}/include/grpcpp/grpcpp.h" ]]; then
    log "grpc already installed, skip."
    return 0
  fi

  directory="grpc"
  branch="v1.49.1"
  file="${directory}-${branch}.tar.gz"
  url="https://github.com/grpc/grpc.git"
  url=$(maybe_set_to_cn_url ${url})
  log "Building and installing ${directory}."
  pushd "${workdir}" || exit
  if [[ ${url} == *.git ]]; then
    clone_if_not_exists ${directory} ${file} "${url}" ${branch}
  else
    download_tar_and_untar_if_not_exists ${directory} ${file} "${url}"
  fi
  pushd ${directory} || exit

  cmake . -DCMAKE_INSTALL_PREFIX="${install_prefix}" \
          -DCMAKE_PREFIX_PATH="${install_prefix}" \
          -DBUILD_SHARED_LIBS=ON \
          -DgRPC_INSTALL=ON \
          -DgRPC_BUILD_TESTS=OFF \
          -DgRPC_BUILD_CSHARP_EXT=OFF \
          -DgRPC_BUILD_GRPC_CSHARP_PLUGIN=OFF \
          -DgRPC_BUILD_GRPC_NODE_PLUGIN=OFF \
          -DgRPC_BUILD_GRPC_OBJECTIVE_C_PLUGIN=OFF \
          -DgRPC_BUILD_GRPC_PHP_PLUGIN=OFF \
          -DgRPC_BUILD_GRPC_PYTHON_PLUGIN=OFF \
          -DgRPC_BUILD_GRPC_RUBY_PLUGIN=OFF \
          -DgRPC_BACKWARDS_COMPATIBILITY_MODE=ON \
          -DgRPC_PROTOBUF_PROVIDER=package \
          -DgRPC_ZLIB_PROVIDER=package \
          -DgRPC_SSL_PROVIDER=package \
          -DOPENSSL_ROOT_DIR="${install_prefix}" \
          -DCMAKE_CXX_FLAGS="-fpermissive" \
          -DPNG_ARM_NEON_OPT=0
  make -j$(nproc)
  make install
  popd || exit
  popd || exit
  cleanup_files "${workdir}/${directory}" "${workdir}/${file}"
}

install_patchelf() {
  workdir=$1
  install_prefix=$2

  if [[ -f "${install_prefix}/bin/patchelf" ]]; then
    log "patchelf already installed, skip."
    return 0
  fi

  ARCH=$(uname -m)

  directory="patchelf"  # patchelf doesn't have a folder
  file="patchelf-0.14.5-${ARCH}.tar.gz"
  url="https://github.com/NixOS/patchelf/releases/download/0.14.5"
  url=$(maybe_set_to_cn_url ${url})
  log "Building and installing ${directory}."
  pushd "${workdir}" || exit
  mkdir -p "${directory}"
  pushd "${directory}" || exit
  download_tar_and_untar_if_not_exists ${directory} ${file} "${url}"
  mkdir -p ${install_prefix}/bin
  mv bin/patchelf ${install_prefix}/bin/patchelf
  popd || exit
  popd || exit
  cleanup_files "${workdir}/${directory}" "${workdir}/${file}"
}

install_cppkafka() {
  workdir=$1
  install_prefix=$2

  if [[ -f "${install_prefix}/include/cppkafka/cppkafka.h" ]]; then
    log "cppkafka already installed, skip."
    return 0
  fi

  directory="cppkafka-0.4.0"
  file="0.4.0.tar.gz"
  url="https://github.com/mfontanini/cppkafka/archive/refs/tags"
  url=$(maybe_set_to_cn_url ${url})
  log "Building and installing ${directory}."
  pushd "${workdir}" || exit
  download_tar_and_untar_if_not_exists ${directory} ${file} "${url}"
  pushd ${directory} || exit

  # cppkafka may not find the lib64 directory
  export LIBRARY_PATH=${LIBRARY_PATH}:${install_prefix}/lib:${install_prefix}/lib64

  cmake . -DCMAKE_INSTALL_PREFIX="${install_prefix}" \
          -DCMAKE_PREFIX_PATH="${install_prefix}" \
          -DCPPKAFKA_DISABLE_TESTS=ON  \
          -DCPPKAFKA_DISABLE_EXAMPLES=ON
  make -j4
  make install
  popd || exit
  popd || exit
  cleanup_files "${workdir}/${directory}" "${workdir}/${file}"
}

install_maven() {
  workdir=$1
  install_prefix=$2

  if [[ -f "${install_prefix}/bin/mvn" ]]; then
    log "maven already installed, skip."
    return 0
  fi

  directory="apache-maven-3.8.6"
  file="apache-maven-3.8.6-bin.tar.gz"
  url="https://archive.apache.org/dist/maven/maven-3/3.8.6/binaries"
  url=$(maybe_set_to_cn_url ${url})
  log "Building and installing ${directory}."
  pushd "${workdir}" || exit
  download_tar_and_untar_if_not_exists ${directory} ${file} "${url}"
  cp -r ${directory} "${install_prefix}"/

  mkdir -p "${install_prefix}"/bin
  ln -s "${install_prefix}/${directory}/bin/mvn" "${install_prefix}/bin/mvn"
  popd || exit
  cleanup_files "${workdir}/${directory}" "${workdir}/${file}"
}

# src/lib/install_vineyard.sh
install_vineyard() {
  workdir=$1
  install_prefix=$2
  v6d_version=$3
  jobs=${4:-4} # $4:default=4
  V6D_PREFIX="/opt/vineyard"  # fixed, related to coordinator/setup.py

  if [[ -f "${V6D_PREFIX}/include/vineyard/client/client.h" ]]; then
    log "vineyard already installed, skip."
    return 0
  fi

  auditwheel_path=$(python3 -c "import auditwheel; print(auditwheel.__path__[0] + '/main_repair.py')")
  sed -i 's/p.error/logger.warning/g' ${auditwheel_path}

  log "Building and installing v6d."
  pushd "${workdir}" || exit
  if [[ "${v6d_version}" != "v"* ]]; then
    directory="v6d"
    file="${directory}-${v6d_version}.tar.gz"
    url="https://github.com/v6d-io/v6d.git"
    clone_if_not_exists ${directory} "${file}" "${url}" "${v6d_version}"
  else
    # remove the prefix 'v'
    directory="v6d-${v6d_version:1:100}"
    file="${directory}.tar.gz"
    url="https://github.com/v6d-io/v6d/releases/download/${v6d_version}"
    cn_url=$(maybe_set_to_cn_url "${url}")
    status=$(curl --head --silent "${cn_url}"/"${file}" | head -n 1)
    if echo "${status}" | grep -q 404; then
      download_tar_and_untar_if_not_exists ${directory} "${file}" "${url}"
    else
      download_tar_and_untar_if_not_exists ${directory} "${file}" "${cn_url}"
    fi
  fi
  pushd ${directory} || exit

  cmake . -DCMAKE_PREFIX_PATH="${install_prefix}" \
        -DCMAKE_INSTALL_PREFIX="${V6D_PREFIX}" \
        -DBUILD_VINEYARD_TESTS=OFF \
        -DBUILD_SHARED_LIBS=ON \
        -DBUILD_VINEYARD_PYTHON_BINDINGS=ON  \
        -DBUILD_VINEYARD_GRAPH_WITH_GAR=ON
  make -j"${jobs}"
  make install
  strip "${V6D_PREFIX}"/bin/vineyard* "${V6D_PREFIX}"/lib/libvineyard*
  pip3 install --no-cache -i https://pypi.org/simple -U "vineyard" "vineyard-io"
  cp -rs "${V6D_PREFIX}"/* "${install_prefix}"/
  popd || exit
  popd || exit
  cleanup_files "${workdir}/${directory}" "${workdir}/${file}"
}

# src/lib/log.sh
err() {
  echo -e "$(red_bold "[ERROR] $*")" >&2
}

warning() {
  echo -e "$(yellow_bold "[WARNING] $*")" >&1
}

log() {
  echo -e "$(green "$*")" >&1
}

info() {
  echo -e "$(green "$*")" >&1
}

succ() {
  echo -e "$(green_bold "[SUCCESS]: $*")" >&1
}

# src/lib/util.sh
# refer from https://github.com/pypa/manylinux/blob/b4884d90c984cb17f7cb4aabe3509347698d7ee7/docker/build_scripts/build_utils.sh#L26
function fetch_source {
    local file=$1
    local url=$2
    if [ -f "${file}" ]; then
        echo "${file} exists, skipping fetch"
    else
        curl -fsSL -o "${file}" "${url}/${file}"
        # Use sock5s proxy to download files in case download fails in normal cases
        # `host.docker.internal` is the localhost of host machine from a container's perspective.
        # See https://docs.docker.com/desktop/networking/#i-want-to-connect-from-a-container-to-a-service-on-the-host
        # curl -fsSL -o ${file} ${url}/${file} || curl -x socks5h://host.docker.internal:13659 -fsSL -o ${file} ${url}/${file}
    fi
}

function download_tar_and_untar_if_not_exists {
    local directory=$1
    local file=$2
    local url=$3
    if [ ! -d "${directory}" ]; then
      [ ! -f "${file}" ] &&
        fetch_source "${file}" "${url}"
      tar zxf "${file}"
    fi
}

function clone_if_not_exists {
    local directory=$1
    local file=$2
    local url=$3
    local branch=$4
    if [ ! -d "${directory}" ]; then
      if [ ! -f "${file}" ]; then
        git clone --depth=1 --branch "${branch}" "${url}" "${directory}"
        pushd "${directory}" || exit
        git submodule update --init || true
        popd || exit
      else
        tar zxf "${file}"
      fi
    fi
}

function cleanup_files {
  if [ "${GRAPHSCOPE_NO_INSTALL_CLEANUP}" != "true" ]; then
    log "Cleaning up intermediate files [$*]"
    log "Disable this behaviour by setting GRAPHSCOPE_NO_INSTALL_CLEANUP=true."
    for file in "$@"
    do
        log "Cleaning up ${file}"
        if [[ -f "${file}" || -d "${file}" ]]; then
          rm -rf "${file}"
        fi
    done
  fi
}

function maybe_set_to_cn_url {
  local url=$1
  if [ "${GRAPHSCOPE_DOWNLOAD_FROM_CN}" == "true" ]; then
    url="https://graphscope.oss-cn-beijing.aliyuncs.com/dependencies"
  fi
  echo ${url}
}

# :command.command_functions
# :command.function
gs_make_command() {
  # src/make_command.sh
  echo "# this file is located in 'src/make_command.sh'"
  echo "# code for 'gs make' goes here"
  echo "# you can edit it freely and regenerate (it will not be overwritten)"
  inspect_args

  component=${args[component]}

  log "Making component ${component}"

  install_prefix=${args[--install-prefix]}
  storage_type=${args[--storage-type]}

  GS_SOURCE_DIR="$(dirname -- "$(readlink -f "${BASH_SOURCE}")")"

  export INSTALL_PREFIX=${install_prefix}

  make_all() {
      make all
  }

  make_install() {
      make install
  }

  make_analytical() {
      make analytical
  }

  make_interactive() {
      if [[ ${storage_type} = "experimental" ]]; then
          cd "${GS_SOURCE_DIR}"/interactive_engine/compiler && make build QUIET_OPT=""
      elif [[ ${storage_type} = "vineyard" ]]; then
          cd "${GS_SOURCE_DIR}"/interactive_engine && mvn install -DskipTests -Drust.compile.mode=release -P graphscope,graphscope-assembly
          cd "${GS_SOURCE_DIR}"/interactive_engine/assembly/target && tar xvzf graphscope.tar.gz
      else
          make interactive
      fi
  }

  make_learning() {
      make learning
  }

  make_analytical-install() {
      make analytical-install INSTALL_PREFIX=${install_prefix}
  }

  make_interactive-install() {
      make interactive-install INSTALL_PREFIX=${install_prefix}
  }

  make_learning-install() {
      make learning-install INSTALL_PREFIX=${install_prefix}
  }

  make_client() {
      make client
  }

  make_coordinator() {
      make coordinator
  }

  make_analytical-java() {
      make analytical-java
  }

  make_analytical-java-install() {
      make analytical-java-install INSTALL_PREFIX=${install_prefix}
  }

  make_clean() {
      make clean
  }

  make_${component}

}

# :command.function
gs_make_image_command() {
  # src/make_image_command.sh
  echo "# this file is located in 'src/make_image_command.sh'"
  echo "# code for 'gs make-image' goes here"
  echo "# you can edit it freely and regenerate (it will not be overwritten)"
  inspect_args

  #     allowed: [all, graphscope-dev, coordinator, analytical, analytical-java, interactive, interactive-frontend, interactive-executor, learning, vineyard-dev, vineyard-runtime]

  component=${args[component]}

  log "Making image ${component}"

  registry=${args[--registry]}
  tag=${args[--tag]}

  export INSTALL_PREFIX=${install_prefix}

  make_all() {
      cd k8s
      make all
  }

  make_graphscope-dev() {
      cd k8s
      make graphscope-dev REGISTRY=${registry} VERSION=${tag}
  }

  make_analytical() {
      cd k8s
      make analytical REGISTRY=${registry} VERSION=${tag}
  }

  make_interactive() {
      cd k8s
      make interactive REGISTRY=${registry} VERSION=${tag}
  }

  make_interactive-frontend() {
      cd k8s
      make interactive-frontend REGISTRY=${registry} VERSION=${tag}
  }

  make_interactive-executor() {
      cd k8s
      make interactive-executor REGISTRY=${registry} VERSION=${tag}
  }

  make_learning() {
      cd k8s
      make learning REGISTRY=${registry} VERSION=${tag}
  }

  make_coordinator() {
      cd k8s
      make coordinator REGISTRY=${registry} VERSION=${tag}
  }

  make_vineyard-dev() {
      cd k8s
      make vineyard-dev REGISTRY=${registry} VERSION=${tag}
  }

  make_vineyard-runtime() {
      cd k8s
      make vineyard-runtime REGISTRY=${registry} VERSION=${tag}
  }

  make_${component}
}

# :command.function
gs_dev_command() {
  # src/dev_command.sh
  inspect_args

  local=${args[--local]}

  mount_option=""

  if [[ -n $local ]]; then
  	echo "Opened a new container with $local mounted to /home/graphscope/graphscope."
  	mount_option="--mount type=bind,source=${local},target=/home/graphscope/graphscope"
  else
  	echo "No local directory assigned, open a new container without mounting local directory."
  fi

  # docker pull graphscope/graphscope-dev
  REGISTRY="registry.cn-hongkong.aliyuncs.com"
  docker run \
  	-it \
  	${mount_option} \
  	${REGISTRY}/graphscope/graphscope-dev:latest

}

# :command.function
gs_test_command() {
  # src/test_command.sh
  inspect_args

  testdata=${args[--testdata]}
  on_local=${args[--local]}
  storage_type=${args[--storage-type]}
  on_k8s=${args[--k8s]}
  nx=${args[--nx]}
  export GS_TEST_DIR=${testdata}

  # analytical, analytical-java, interactive, learning, e2e, groot

  type=${args[type]}

  GS_SOURCE_DIR="$(dirname -- "$(readlink -f "${BASH_SOURCE}")")"

  function get_test_data {
  	if [[ ! -d ${GS_TEST_DIR} ]]; then
  		log "Downloading test data to ${testdata}"
  		git clone -b master --single-branch --depth=1 https://github.com/graphscope/gstest.git "${GS_TEST_DIR}"
  	fi
  }

  function test_analytical {
  	get_test_data
  	info "Testing analytical on local"
  	"${GS_SOURCE_DIR}"/analytical_engine/test/app_tests.sh --test_dir "${GS_TEST_DIR}"
  }

  function test_analytical-java {
  	get_test_data
  	info "Testing analytical-java on local"

  	pushd "${GS_SOURCE_DIR}"/analytical_engine/java || exit
  	mvn test -Dmaven.antrun.skip=true
  	popd || exit

  	version=$(cat "${GS_SOURCE_DIR}"/VERSION)
  	export RUN_JAVA_TESTS=ON
  	export USER_JAR_PATH="${GS_SOURCE_DIR}"/analytical_engine/java/grape-demo/target/grape-demo-${version}-shaded.jar
  	# for giraph test
  	export GIRAPH_JAR_PATH="${GS_SOURCE_DIR}"/analytical_engine/java/grape-giraph/target/grape-giraph-${version}-shaded.jar

  	"${GS_SOURCE_DIR}"/analytical_engine/test/app_tests.sh --test_dir "${GS_TEST_DIR}"
  }

  function test_interactive {
  	get_test_data
  	if [[ -n ${on_local} ]]; then
  		if [[ ${storage_type} = "experimental" ]]; then
  			info "Testing interactive on local with experimental storage"
  			# IR unit test
  			cd "${GS_SOURCE_DIR}"/interactive_engine/compiler && make test
  			# CommonType Unit Test
  			cd "${GS_SOURCE_DIR}"/interactive_engine/executor/common/dyn_type && cargo test
  			# Store Unit test
  			cd "${GS_SOURCE_DIR}"/interactive_engine/executor/store/exp_store && cargo test
  			# IR integration test
  			cd "${GS_SOURCE_DIR}"/interactive_engine/compiler && ./ir_exprimental_ci.sh
  			# IR integration pattern test
  			cd "${GS_SOURCE_DIR}"/interactive_engine/compiler && ./ir_exprimental_pattern_ci.sh
  		elif [[ ${storage_type} = "vineyard" ]]; then
  			info "Testing interactive on local with vineyard storage"
  			# start vineyard service
  			export VINEYARD_IPC_SOCKET=/tmp/vineyard.sock
  			vineyardd --socket=${VINEYARD_IPC_SOCKET} --meta=local &
  			# load modern graph
  			export STORE_DATA_PATH="${GS_SOURCE_DIR}"/charts/gie-standalone/data
  			vineyard-graph-loader --config "${GS_SOURCE_DIR}"/charts/gie-standalone/config/v6d_modern_loader.json
  			# start gie executor && frontend
  			export GRAPHSCOPE_HOME="${GS_SOURCE_DIR}"/interactive_engine/assembly/target/graphscope
  			schema_json=$(ls /tmp/*.json | head -1)
  			object_id=${schema_json//[^0-9]/}
  			GRAPHSCOPE_HOME=${GRAPHSCOPE_HOME} ${GRAPHSCOPE_HOME}/bin/giectl create_gremlin_instance_on_local /tmp/gs/${object_id} ${object_id} ${schema_json} 1 1235 1234 8182 ${VINEYARD_IPC_SOCKET}
  			# IR integration test
  			sleep 3s
  			cd "${GS_SOURCE_DIR}"/interactive_engine/compiler
  			make gremlin_test || true
  			# clean
  			rm -rf /tmp/*.json
  			id=$(pgrep -f 'gaia_executor')
  			if [[ -n ${id} ]]; then
  				echo ${id} | xargs kill
  			fi
  			id=$(pgrep -f 'frontend')
  			if [[ -n ${id} ]]; then
  				echo ${id} | xargs kill
  			fi
  			id=$(pgrep -f 'vineyardd')
  			if [[ -n ${id} ]]; then
  				echo ${id} | xargs kill -9
  			fi
  		else
  			info "Testing interactive on local with default storage"
  		fi
  	fi
  	if [[ -n ${on_k8s} ]]; then
  		info "Testing interactive on k8s"
  		export PYTHONPATH="${GS_SOURCE_DIR}"/python:${PYTHONPATH}
  		cd "${GS_SOURCE_DIR}"/interactive_engine && mvn clean install --quiet -DskipTests -Drust.compile.skip=true -P graphscope,graphscope-assembly
  		cd "${GS_SOURCE_DIR}"/interactive_engine/tests || exit
  		./function_test.sh 8112 2
  	fi
  }
  function test_learning {
  	get_test_data
  	err "Not implemented"
  	exit 1
  }

  function test_e2e {
  	get_test_data
  	cd "${GS_SOURCE_DIR}"/python || exit
  	if [[ -n ${on_local} ]]; then
  		# unittest
  		python3 -m pytest -s -vvv --exitfirst graphscope/tests/minitest/test_min.py
  	fi
  	if [[ -n ${on_k8s} ]]; then
  		python3 -m pytest -s -vvv --exitfirst ./graphscope/tests/kubernetes/test_demo_script.py
  	fi
  }

  function test_groot {
  	get_test_data
  	if [[ -n ${on_local} ]]; then
  		info "Testing groot on local"
  		cd "${GS_SOURCE_DIR}"/interactive_engine/groot-server
  		mvn test -Pgremlin-test
  	fi
  	if [[ -n ${on_k8s} ]]; then
  		info "Testing groot on k8s, note you must already setup a groot cluster and necessary environment variables"
  		cd "${GS_SOURCE_DIR}"/python || exit
  		python3 -m pytest --exitfirst -s -vvv ./graphscope/tests/kubernetes/test_store_service.py
  	fi
  }

  test_"${type}"

}

# :command.function
gs_install_deps_command() {
  # src/install_deps_command.sh
  inspect_args

  type=${args[type]}
  cn=${args[--cn]}
  install_prefix=${args[--install-prefix]}
  deps_prefix=${args[--from-local]}
  v6d_version=${args[--v6d-version]}
  jobs=${args[--jobs]}

  for_analytical=${args[--for-analytical]}
  no_v6d=${args[--no-v6d]}

  SUDO=sudo
  if [[ $(id -u) -eq 0 ]]; then
    warning "Please note that I am running as root."
    SUDO=""
  fi

  readonly OS=$(get_os_version)
  readonly OS_PLATFORM=${OS%-*}
  readonly OS_VERSION=${OS#*-}

  readonly OUTPUT_ENV_FILE="${HOME}/.graphscope_env"

  log "Installing ${type} dependencies for GraphScope on ${OS}..."

  if [[ -n ${cn} ]]; then
    log "Set to speed up downloading for CN locations."
    # export some mirror locations for CN, e.g., brew/docker...
    export HOMEBREW_BREW_GIT_REMOTE="https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/brew.git"
    export HOMEBREW_CORE_GIT_REMOTE="https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-core.git"
    export HOMEBREW_BOTTLE_DOMAIN="https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles"
    export GRAPHSCOPE_DOWNLOAD_FROM_CN="true"
  fi

  check_os_compatibility() {
    if [[ "${OS_PLATFORM}" != *"Ubuntu"* && "${OS_PLATFORM}" != *"CentOS"* && "${OS_PLATFORM}" != *"Darwin"* ]]; then
      err "The script is only support platforms of Ubuntu/CentOS/macOS"
      exit 1
    fi

    if [[ "${OS_PLATFORM}" == *"Ubuntu"* && "${OS_VERSION:0:2}" -lt "20" ]]; then
      err "The version of Ubuntu is ${OS_VERSION}. This script requires Ubuntu 20 or greater."
      exit 1
    fi

    if [[ "${OS_PLATFORM}" == *"CentOS"* && "${OS_VERSION}" -lt "7" ]]; then
      err "The version of CentOS is ${OS_VERSION}. This script requires CentOS 8 or greater."
      exit 1
    fi

    log "Running on ${OS_PLATFORM} ${OS_VERSION}"
  }

  BASIC_PACKAGES_LINUX=("file" "curl" "wget" "git" "sudo")

  BASIC_PACKAGES_UBUNTU=("${BASIC_PACKAGES_LINUX[@]}" "build-essential" "cmake" "libunwind-dev" "python3-pip")

  BASIC_PACKAGES_CENTOS_8=("${BASIC_PACKAGES_LINUX[@]}" "epel-release" "libunwind-devel" "libcurl-devel" "perl" "which")
  BASIC_PACKAGES_CENTOS_7=("${BASIC_PACKAGES_CENTOS_8[@]}" "centos-release-scl-rh")
  ADDITIONAL_PACKAGES_CENTOS_8=("gcc-c++" "python38-devel")
  ADDITIONAL_PACKAGES_CENTOS_7=("make" "devtoolset-8-gcc-c++" "rh-python38-python-pip" "rh-python38-python-devel")

  ANALYTICAL_UBUNTU=(
    "libboost-all-dev"
    "libopenmpi-dev"
    "libgflags-dev"
    "libgoogle-glog-dev"
    "libprotobuf-dev"
    "libgrpc++-dev"
    "libmsgpack-dev"
    "librdkafka-dev"
    "protobuf-compiler-grpc"
    "rapidjson-dev"
  )

  ANALYTICAL_CENTOS_7=("librdkafka-devel" "msgpack-devel" "rapidjson-devel")
  ANALYTICAL_CENTOS_8=("${ANALYTICAL_CENTOS_7[@]}" "boost-devel" "gflags-devel" "glog-devel")

  ANALYTICAL_MACOS=(
    "apache-arrow"
    "boost"
    "gflags"
    "glog"
    "open-mpi"
    "openssl@1.1"
    "protobuf"
    "grpc"
    "rapidjson"
    "msgpack-cxx"
    "librdkafka"
    "patchelf"
  )

  _install_apache_arrow_ubuntu() {
    log "Installing apache-arrow."
    ${SUDO} apt-get install -y lsb-release
    # shellcheck disable=SC2046,SC2019,SC2018
    wget -c https://apache.jfrog.io/artifactory/arrow/"$(lsb_release --id --short | tr 'A-Z' 'a-z')"/apache-arrow-apt-source-latest-$(lsb_release --codename --short).deb \
      -P /tmp/
    ${SUDO} apt-get install -y -V /tmp/apache-arrow-apt-source-latest-"$(lsb_release --codename --short)".deb
    ${SUDO} apt-get update -y
    ${SUDO} apt-get install -y libarrow-dev
    rm /tmp/apache-arrow-apt-source-latest-*.deb
  }

  _install_java_maven_ubuntu() {
    if ! command -v javac &>/dev/null; then
      log "Installing default-jdk"
      ${SUDO} apt-get install default-jdk -y
    fi
    if ! command -v mvn &>/dev/null; then
      log "Installing maven"
      ${SUDO} apt-get install maven -y
    fi
  }

  _install_java_maven_centos() {
    if ! command -v javac &>/dev/null; then
      log "Installing java-1.8.0-openjdk-devel"
      ${SUDO} yum install java-1.8.0-openjdk-devel -y
    fi
    if ! command -v mvn &>/dev/null; then
      log "Installing maven"
      install_maven "${deps_prefix}" "${install_prefix}"
    fi
  }

  _install_java_maven_macos() {
    if ! command -v javac &>/dev/null; then
      log "Installing openjdk@11"
      # we need arm64-base jvm, install from brew.
      brew install --ignore-dependencies openjdk@11
    fi
    if ! command -v mvn &>/dev/null; then
      log "Installing maven"
      brew install --ignore-dependencies maven
    fi
  }

  _install_dependencies_analytical_ubuntu() {
    DEBIAN_FRONTEND=noninteractive TZ=Etc/UTC ${SUDO} apt-get install -y ${ANALYTICAL_UBUNTU[*]}
    _install_apache_arrow_ubuntu
  }

  _install_dependencies_analytical_centos_common() {
    # the openssl must put before grpc, otherwise the grpc
    # cannot find the openssl.
    install_apache_arrow "${deps_prefix}" "${install_prefix}"
    install_open_mpi "${deps_prefix}" "${install_prefix}"
    install_protobuf "${deps_prefix}" "${install_prefix}"
    install_zlib "${deps_prefix}" "${install_prefix}"
    install_grpc "${deps_prefix}" "${install_prefix}"
  }

  _install_dependencies_analytical_centos8() {
    ${SUDO} yum install -y ${ANALYTICAL_CENTOS_8[*]}
    export LD_LIBRARY_PATH=${LD_LIBRARY_PATH}:/lib/:/lib64${install_prefix}/lib:${install_prefix}/lib64
    install_cmake "${deps_prefix}" "${install_prefix}"
    install_openssl_static "${deps_prefix}" "${install_prefix}"
    _install_dependencies_analytical_centos_common
  }
  _install_dependencies_analytical_centos7() {
    ${SUDO} yum install -y ${ANALYTICAL_CENTOS_7[*]}
    source /opt/rh/devtoolset-8/enable
    source /opt/rh/rh-python38/enable
    export LD_LIBRARY_PATH=${LD_LIBRARY_PATH}:${install_prefix}/lib:${install_prefix}/lib64

    install_cmake "${deps_prefix}" "${install_prefix}"
    install_gflags "${deps_prefix}" "${install_prefix}"
    install_glog "${deps_prefix}" "${install_prefix}"
    install_boost "${deps_prefix}" "${install_prefix}"
    install_openssl "${deps_prefix}" "${install_prefix}"
    _install_dependencies_analytical_centos_common
  }
  _install_dependencies_analytical_macos() {
    brew install ${ANALYTICAL_MACOS[*]}
    homebrew_prefix=$(brew --prefix)
    export LDFLAGS="${LDFLAGS} -L${homebrew_prefix}/opt/openssl@1.1/lib"
    export CPPFLAGS="${CPPFLAGS} -I${homebrew_prefix}/opt/openssl@1.1/include"
    export PKG_CONFIG_PATH="${homebrew_prefix}/opt/openssl@1.1/lib/pkgconfig"
  }

  install_basic_packages_universal() {
    if [[ "${OS_PLATFORM}" == *"Ubuntu"* ]]; then
      ${SUDO} apt-get update -y
      DEBIAN_FRONTEND=noninteractive TZ=Etc/UTC ${SUDO} apt-get install -y ${BASIC_PACKAGES_UBUNTU[*]}
    elif [[ "${OS_PLATFORM}" == *"CentOS"* ]]; then
      if [[ "${OS_VERSION}" -eq "7" ]]; then
        ${SUDO} yum install -y ${BASIC_PACKAGES_CENTOS_7[*]}
        ${SUDO} yum install -y ${ADDITIONAL_PACKAGES_CENTOS_7[*]}
      else
        sed -i 's/mirrorlist/#mirrorlist/g' /etc/yum.repos.d/CentOS-*
        sed -i 's|#baseurl=http://mirror.centos.org|baseurl=http://vault.centos.org|g' /etc/yum.repos.d/CentOS-*
        ${SUDO} yum install -y 'dnf-command(config-manager)'
        ${SUDO} dnf install -y epel-release
        ${SUDO} dnf config-manager --set-enabled epel
        ${SUDO} dnf config-manager --set-enabled powertools
        ${SUDO} yum install -y ${BASIC_PACKAGES_CENTOS_8[*]}
        ${SUDO} yum install -y ${ADDITIONAL_PACKAGES_CENTOS_8[*]}
      fi
    fi
  }

  install_grape_vineyard_universal() {
    if [[ "${OS_PLATFORM}" == *"Darwin"* ]]; then
      brew install vineyard
    else
      log "Installing python packages for vineyard codegen."
      pip3 --no-cache-dir install pip -U --user
      pip3 --no-cache-dir install libclang wheel auditwheel --user
      install_vineyard "${deps_prefix}" "${install_prefix}" "${v6d_version}" "${jobs}"
    fi
  }

  install_rust_universal() {
    if ! command -v rustup &>/dev/null; then
      log "Installing rust."
      curl -sf -L https://static.rust-lang.org/rustup.sh | sh -s -- -y --profile minimal
    fi
  }

  install_java_maven_universal() {
    if [[ "${OS_PLATFORM}" == *"Darwin"* ]]; then
      _install_java_maven_macos
    elif [[ "${OS_PLATFORM}" == *"Ubuntu"* ]]; then
      _install_java_maven_ubuntu
    else
      _install_java_maven_centos
    fi
  }

  install_llvm_universal() {
    if [[ "${OS_PLATFORM}" == *"Darwin"* ]]; then
      brew install llvm || true # prevent the `brew link` failure
      homebrew_prefix=$(brew --prefix)
      export CC=${homebrew_prefix}/opt/llvm/bin/clang
      export CXX=${homebrew_prefix}/opt/llvm/bin/clang++
      export CPPFLAGS="${CPPFLAGS} -I${homebrew_prefix}/opt/llvm/include"
      export CARGO_TARGET_X86_64_APPLE_DARWIN_LINKER=${CC}
    elif [[ "${OS_PLATFORM}" == *"Ubuntu"* ]]; then
      ${SUDO} apt-get install -y llvm-11-dev lld-11 clang-11
    else
      if [[ "${OS_VERSION}" -eq "7" ]]; then
        ${SUDO} yum install -y llvm-toolset-7.0-clang-devel
        source /opt/rh/llvm-toolset-7.0/enable
        export LIBCLANG_PATH=/opt/rh/llvm-toolset-7.0/root/usr/lib64/
      else
        ${SUDO} yum install -y llvm-devel clang-devel lld
      fi
    fi
  }

  install_dependencies_analytical_universal() {
    if [[ "${OS_PLATFORM}" == *"Darwin"* ]]; then
      _install_dependencies_analytical_macos
    elif [[ "${OS_PLATFORM}" == *"Ubuntu"* ]]; then
      install_patchelf "${deps_prefix}" "${install_prefix}"
      _install_dependencies_analytical_ubuntu
    else
      install_patchelf "${deps_prefix}" "${install_prefix}"
      if [[ "${OS_VERSION}" -eq "7" ]]; then
        _install_dependencies_analytical_centos7
        install_java_maven_universal
      else
        _install_dependencies_analytical_centos8
      fi
    fi
  }

  write_env_config() {
    log "Output environments config file ${OUTPUT_ENV_FILE}"
    if [ -f "${OUTPUT_ENV_FILE}" ]; then
      warning "Found ${OUTPUT_ENV_FILE} exists, remove the environment config file and generate a new one."
      rm -f "${OUTPUT_ENV_FILE}"
    fi

    {
      echo "export GRAPHSCOPE_HOME=${install_prefix}"
      echo "export CMAKE_PREFIX_PATH=/opt/vineyard"
      echo "export PATH=${install_prefix}/bin:\$HOME/.cargo/bin:\$PATH"
      echo "export LD_LIBRARY_PATH=${LD_LIBRARY_PATH}"
      echo "export LIBRARY_PATH=${install_prefix}/lib:${install_prefix}/lib64"
    } >>"${OUTPUT_ENV_FILE}"

    if [[ "${OS_PLATFORM}" == *"Darwin"* ]]; then
      homebrew_prefix=$(brew --prefix)
      {
        echo "export CC=${homebrew_prefix}/opt/llvm/bin/clang"
        echo "export CXX=${homebrew_prefix}/opt/llvm/bin/clang++"
        echo "export CARGO_TARGET_X86_64_APPLE_DARWIN_LINKER=${CC}"
        if [ -z "${JAVA_HOME}" ]; then
          echo "export JAVA_HOME=\$(/usr/libexec/java_home -v11)"
        fi
        echo "export OPENSSL_ROOT_DIR=${homebrew_prefix}/opt/openssl"
        echo "export OPENSSL_LIBRARIES=${homebrew_prefix}/opt/openssl/lib"
        echo "export OPENSSL_SSL_LIBRARY=${homebrew_prefix}/opt/openssl/lib/libssl.dylib"
        echo "export LDFLAGS=\"-L${homebrew_prefix}/opt/llvm/lib\""
        echo "export CPPFLAGS=\"-I${homebrew_prefix}/opt/llvm/include\""
      } >>"${OUTPUT_ENV_FILE}"

    elif [[ "${OS_PLATFORM}" == *"Ubuntu"* ]]; then
      {
        if [ -z "${JAVA_HOME}" ]; then
          echo "export JAVA_HOME=/usr/lib/jvm/default-java"
        fi
      } >>"${OUTPUT_ENV_FILE}"
    else
      {
        if [[ "${OS_VERSION}" -eq "7" ]]; then
          echo "source /opt/rh/devtoolset-8/enable"
          echo "source /opt/rh/rh-python38/enable"
          echo "source /opt/rh/llvm-toolset-7.0/enable || true"
          echo "export LIBCLANG_PATH=/opt/rh/llvm-toolset-7.0/root/usr/lib64/"
        fi
        if [ -z "${JAVA_HOME}" ]; then
          echo "export JAVA_HOME=/usr/lib/jvm/jre-openjdk"
        fi
        echo "export OPENSSL_ROOT_DIR=${install_prefix}"
      } >>"${OUTPUT_ENV_FILE}"
    fi
  }

  init_workspace_and_env() {
    mkdir -p "${install_prefix}"
    mkdir -p "${deps_prefix}"
    export PATH=${install_prefix}/bin:${PATH}
    export LD_LIBRARY_PATH=${LD_LIBRARY_PATH}:${install_prefix}/lib:${install_prefix}/lib64
  }

  install_deps_for_dev() {
    # install_deps for development on local
    check_os_compatibility

    init_workspace_and_env

    if [[ "${OS_PLATFORM}" == *"Darwin"* ]]; then
      export HOMEBREW_NO_INSTALL_CLEANUP=1
      export HOMEBREW_NO_INSTALLED_DEPENDENTS_CHECK=1
    fi

    install_basic_packages_universal
    if [[ -n ${for_analytical} ]]; then
      install_dependencies_analytical_universal
      if [[ -z ${no_v6d} ]]; then
        install_grape_vineyard_universal
      fi
    else # for all
      install_dependencies_analytical_universal
      if [[ -z ${no_v6d} ]]; then
        install_grape_vineyard_universal
      fi
      install_java_maven_universal
      install_llvm_universal
      install_rust_universal
      install_cppkafka "${deps_prefix}" "${install_prefix}"
    fi

    write_env_config

    succ "The script has installed all dependencies for building GraphScope, use commands:\n
    $ source ${OUTPUT_ENV_FILE}
    $ make install
    \nto build and develop GraphScope."
  }

  install_deps_for_client() {
    # install python..
    # TODO: refine
    pip3 --no-cache-dir install -U pip --user
    pip3 --no-cache-dir install auditwheel daemons etcd-distro gremlinpython \
      hdfs3 fsspec oss2 s3fs ipython kubernetes libclang networkx==2.4 numpy pandas parsec pycryptodome \
      pyorc pytest scipy scikit_learn wheel --user
    pip3 --no-cache-dir install Cython --pre -U --user
  }

  # run subcommand with the type
  install_deps_for_"${type}"

}

# :command.function
gs_format_command() {
  # src/format_command.sh
  echo "# this file is located in 'src/format_command.sh'"
  echo "# code for 'gs format' goes here"
  echo "# you can edit it freely and regenerate (it will not be overwritten)"
  inspect_args

  GS_SOURCE_DIR="$(dirname -- "$(readlink -f "${BASH_SOURCE}")")"

  function format_cpp {
  	if ! [ -x "$(command -v clang-format)" ]; then
  		echo 'Downloading clang-format.' >&2
  		curl -L https://github.com/muttleyxd/clang-tools-static-binaries/releases/download/master-22538c65/clang-format-8_linux-amd64 --output ${GRAPHSCOPE_HOME}/bin/clang-format
  		chmod +x ${GRAPHSCOPE_HOME}/clang-format
  		export PATH="${GRAPHSCOPE_HOME}/bin:${PATH}"
  	fi
  	pushd "${GS_SOURCE_DIR}"/analytical_engine || exit
  	files=$(find ./apps ./benchmarks ./core ./frame ./misc ./test \( -name "*.h" -o -name "*.cc" \))

  	# run format
  	clang-format -i --style=file $(echo $files)
  	popd || exit
  }

  function lint_cpp {
  	pushd "${GS_SOURCE_DIR}"/analytical_engine || exit
  	files=$(find ./apps ./benchmarks ./core ./frame ./misc ./test \( -name "*.h" -o -name "*.cc" \))

  	./misc/cpplint.py $(echo $files)
  	popd || exit
  }

  function format_java {
  	jarfile=google-java-format-1.13.0-all-deps.jar
  	if [[ ! -f ${jarfile} ]]; then
  		wget https://github.com/google/google-java-format/releases/download/v1.13.0/${jarfile}
  	fi
  	# run formatter in-place
  	java -jar ${jarfile} --aosp --skip-javadoc-formatting -i $(git ls-files *.java)

  }

  function format_python {
  	if ! [ -x "$(command -v black)" ]; then
  		pip3 install -r ${GS_SOURCE_DIR}/coordinator/requirements-dev.txt --user
  	fi
  	pushd python || exit
  	python3 -m isort --check --diff .
  	python3 -m black --check --diff .
  	python3 -m flake8 .
  	popd || exit
  	pushd coordinator || exit
  	python3 -m isort --check --diff .
  	python3 -m black --check --diff .
  	python3 -m flake8 .
  	popd || exit
  }

  function format_rust {
  	cd "${GS_SOURCE_DIR}"/interactive_engine/executor/assembly/groot
  	cargo +nightly fmt -- --check
  	cd "${GS_SOURCE_DIR}"/interactive_engine/executor/assembly/v6d
  	cargo +nightly fmt -- --check
  	cd "${GS_SOURCE_DIR}"/interactive_engine/executor/common/dyn_type/
  	cargo +nightly fmt -- --check
  	cd "${GS_SOURCE_DIR}"/interactive_engine/executor/engine/pegasus/
  	cargo +nightly fmt -- --check
  	cd "${GS_SOURCE_DIR}"/interactive_engine/executor/ir/
  	cargo +nightly fmt -- --check
  	cd "${GS_SOURCE_DIR}"/interactive_engine/executor/store/
  	cargo +nightly fmt -- --check
  }

  format_"${lang}"

}

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --version | -v)
        version_command
        exit
        ;;

      --help | -h)
        long_usage=yes
        gs_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.environment_variables_filter
  # :command.environment_variables_default
  export GRAPHSCOPE_ENV="${GRAPHSCOPE_ENV:-dev}"

  if [[ -z "${GRAPHSCOPE_HOME:-}" ]]; then
    printf "missing required environment variable: GRAPHSCOPE_HOME\n" >&2
    exit 1
  fi

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    make)
      action="make"
      shift
      gs_make_parse_requirements "$@"
      shift $#
      ;;

    make-image | mi)
      action="make-image"
      shift
      gs_make_image_parse_requirements "$@"
      shift $#
      ;;

    dev | d)
      action="dev"
      shift
      gs_dev_parse_requirements "$@"
      shift $#
      ;;

    test | t)
      action="test"
      shift
      gs_test_parse_requirements "$@"
      shift $#
      ;;

    install-deps | i)
      action="install-deps"
      shift
      gs_install_deps_parse_requirements "$@"
      shift $#
      ;;

    format)
      action="format"
      shift
      gs_format_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      gs_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
gs_make_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        gs_make_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="make"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --install-prefix)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--install-prefix']="$2"
          shift
          shift
        else
          printf "%s\n" "--install-prefix requires an argument: --install-prefix PREFIX" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --storage-type)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--storage-type']="$2"
          shift
          shift
        else
          printf "%s\n" "--storage-type requires an argument: --storage-type STORAGE_TYPE" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['component']+x} ]]; then

          args['component']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.default_assignments
  [[ -n ${args['component']:-} ]] || args['component']="all"
  [[ -n ${args['--install-prefix']:-} ]] || args['--install-prefix']="/opt/graphscope"
  [[ -n ${args['--storage-type']:-} ]] || args['--storage-type']="default"

  # :command.whitelist_filter
  if [[ -n ${args['component']} ]] && [[ ! ${args['component']} =~ ^(all|install|analytical|analytical-java|interactive|learning|analytical-install|analytical-java-install|interactive-install|learning-install|client|coordinator|clean)$ ]]; then
    printf "%s\n" "component must be one of: all, install, analytical, analytical-java, interactive, learning, analytical-install, analytical-java-install, interactive-install, learning-install, client, coordinator, clean" >&2
    exit 1
  fi

}

# :command.parse_requirements
gs_make_image_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        gs_make_image_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.dependencies_filter
  if command -v docker >/dev/null 2>&1; then
    deps['docker']="$(command -v docker | head -n1)"
  else
    printf "missing dependency: docker\n" >&2
    exit 1
  fi

  # :command.command_filter
  action="make-image"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --registry)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--registry']="$2"
          shift
          shift
        else
          printf "%s\n" "--registry requires an argument: --registry REGISTRY" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --tag)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--tag']="$2"
          shift
          shift
        else
          printf "%s\n" "--tag requires an argument: --tag TAG" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['image']+x} ]]; then

          args['image']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['image']+x} ]]; then
    printf "missing required argument: IMAGE\nusage: gs make-image IMAGE [OPTIONS]\n" >&2
    exit 1
  fi

  # :command.default_assignments
  [[ -n ${args['--registry']:-} ]] || args['--registry']="registry.cn-hongkong.aliyuncs.com"
  [[ -n ${args['--tag']:-} ]] || args['--tag']="latest"

  # :command.whitelist_filter
  if [[ -n ${args['image']} ]] && [[ ! ${args['image']} =~ ^(all|graphscope-dev|coordinator|analytical|analytical-java|interactive|interactive-frontend|interactive-executor|learning|vineyard-dev|vineyard-runtime)$ ]]; then
    printf "%s\n" "image must be one of: all, graphscope-dev, coordinator, analytical, analytical-java, interactive, interactive-frontend, interactive-executor, learning, vineyard-dev, vineyard-runtime" >&2
    exit 1
  fi

}

# :command.parse_requirements
gs_dev_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        gs_dev_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.dependencies_filter
  if command -v docker >/dev/null 2>&1; then
    deps['docker']="$(command -v docker | head -n1)"
  else
    printf "missing dependency: docker\n" >&2
    exit 1
  fi

  # :command.command_filter
  action="dev"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --local | -l)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--local']="$2"
          shift
          shift
        else
          printf "%s\n" "--local requires an argument: --local, -l LOCAL" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
gs_test_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        gs_test_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="test"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --local)

        # :flag.case_no_arg
        args['--local']=1
        shift
        ;;

      # :flag.case
      --storage-type)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--storage-type']="$2"
          shift
          shift
        else
          printf "%s\n" "--storage-type requires an argument: --storage-type STORAGE_TYPE" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --k8s)

        # :flag.case_no_arg
        args['--k8s']=1
        shift
        ;;

      # :flag.case
      --nx)

        # :flag.case_no_arg
        args['--nx']=1
        shift
        ;;

      # :flag.case
      --testdata)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--testdata']="$2"
          shift
          shift
        else
          printf "%s\n" "--testdata requires an argument: --testdata DIRECTORY" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['type']+x} ]]; then

          args['type']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.default_assignments
  [[ -n ${args['--storage-type']:-} ]] || args['--storage-type']="default"
  [[ -n ${args['--testdata']:-} ]] || args['--testdata']="/tmp/gstest"

  # :command.whitelist_filter
  if [[ -n ${args['type']} ]] && [[ ! ${args['type']} =~ ^(analytical|analytical-java|interactive|learning|local-e2e|k8s-e2e|groot)$ ]]; then
    printf "%s\n" "type must be one of: analytical, analytical-java, interactive, learning, local-e2e, k8s-e2e, groot" >&2
    exit 1
  fi

}

# :command.parse_requirements
gs_install_deps_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        gs_install_deps_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="install-deps"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --cn)

        # :flag.case_no_arg
        args['--cn']=1
        shift
        ;;

      # :flag.case
      --from-local | -l)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--from-local']="$2"
          shift
          shift
        else
          printf "%s\n" "--from-local requires an argument: --from-local, -l DIRECTORY" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --install-prefix)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--install-prefix']="$2"
          shift
          shift
        else
          printf "%s\n" "--install-prefix requires an argument: --install-prefix PREFIX" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --v6d-version)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--v6d-version']="$2"
          shift
          shift
        else
          printf "%s\n" "--v6d-version requires an argument: --v6d-version V6D-VERSION" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --jobs | -j)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--jobs']="$2"
          shift
          shift
        else
          printf "%s\n" "--jobs requires an argument: --jobs, -j JOBS" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --for-analytical)

        # :flag.case_no_arg
        args['--for-analytical']=1
        shift
        ;;

      # :flag.case
      --no-v6d)

        # :flag.case_no_arg
        args['--no-v6d']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['type']+x} ]]; then

          args['type']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['type']+x} ]]; then
    printf "missing required argument: TYPE\nusage: gs install-deps TYPE [OPTIONS]\n" >&2
    exit 1
  fi

  # :command.default_assignments
  [[ -n ${args['--from-local']:-} ]] || args['--from-local']="/tmp/gs-local-deps"
  [[ -n ${args['--install-prefix']:-} ]] || args['--install-prefix']="/opt/graphscope"
  [[ -n ${args['--v6d-version']:-} ]] || args['--v6d-version']="main"

  # :command.whitelist_filter
  if [[ -n ${args['type']} ]] && [[ ! ${args['type']} =~ ^(dev|client)$ ]]; then
    printf "%s\n" "type must be one of: dev, client" >&2
    exit 1
  fi

}

# :command.parse_requirements
gs_format_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        gs_format_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="format"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['lang']+x} ]]; then

          args['lang']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['lang']+x} ]]; then
    printf "missing required argument: LANG\nusage: gs format LANG\n" >&2
    exit 1
  fi

  # :command.whitelist_filter
  if [[ -n ${args['lang']} ]] && [[ ! ${args['lang']} =~ ^(cpp|java|python|rust)$ ]]; then
    printf "%s\n" "lang must be one of: cpp, java, python, rust" >&2
    exit 1
  fi

}

# :command.initialize
initialize() {
  version="0.1.0"
  long_usage=''
  set -e

  # :command.environment_variables_default
  export GRAPHSCOPE_ENV="${GRAPHSCOPE_ENV:-dev}"

  # src/initialize.sh

  bash_source_dir="$(dirname -- "$(readlink -f "${BASH_SOURCE}")")"

  if [ "${GRAPHSCOPE_ENV:-dev}" == "dev" ]; then
      log "Setting the environment for development.\n"
      warning "GRAPHSCOPE_HOME will set to source root (${bash_source_dir}) for development."
      warning "To use you assigned GRAPHSCOPE_HOME, export GRAPHSCOPE_ENV=prod.\n"
      export GRAPHSCOPE_HOME="${bash_source_dir}"
  elif [ "${GRAPHSCOPE_ENV:-dev}" == "prod" ]; then
      log "Setting the environment for production"
      export GRAPHSCOPE_HOME=${GRAPHSCOPE_HOME}
  else
      err "Invalid GRAPHSCOPE_ENV. (should be dev or prod)"
      exit 1
  fi

  log "Read the env: GRAPHSCOPE_HOME=${GRAPHSCOPE_HOME:-}"
}

# :command.run
run() {
  declare -A args=()
  declare -A deps=()
  declare -a other_args=()
  declare -a input=()
  normalize_input "$@"
  parse_requirements "${input[@]}"

  case "$action" in
    "make") gs_make_command ;;
    "make-image") gs_make_image_command ;;
    "dev") gs_dev_command ;;
    "test") gs_test_command ;;
    "install-deps") gs_install_deps_command ;;
    "format") gs_format_command ;;
  esac
}

initialize
run "$@"
