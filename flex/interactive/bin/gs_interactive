#!/bin/bash
# Copyright 2020 Alibaba Group Holding Limited.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


# The product name
DB_PROD_NAME="interactive"

# colored error and info functions to wrap messages.
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
NC='\033[0m' # No Color
err() {
  echo -e "${RED}[$(date +'%Y-%m-%d %H:%M:%S')] -ERROR- $* ${NC}" >&2
}

info() {
  echo -e "${GREEN}[$(date +'%Y-%m-%d %H:%M:%S')] -INFO- $* ${NC}"
}

emph(){
  echo -e "${YELLOW}[$(date +'%Y-%m-%d %H:%M:%S')] -INFO- $* ${NC}"
}

################## Some Util Functions ##################

###############################################################################
#
# source: https://github.com/mrbaseman/parse_yaml.git
#
###############################################################################
# Parses a YAML file and outputs variable assignments.  Can optionally accept a 
# variable name prefix and a variable name separator
#
# Usage:
#   parse_yaml file [prefix] [separator]
###############################################################################

function parse_yaml {
  unset i
  unset fs
  local prefix=$2
  local separator=${3:-_}

  local indexfix=-1
  # Detect awk flavor
  if awk --version 2>&1 | grep -q "GNU Awk" ; then
      # GNU Awk detected
      indexfix=-1
  elif awk -Wv 2>&1 | grep -q "mawk" ; then
      # mawk detected
      indexfix=0
  fi

  local s='[[:space:]]*' sm='[ \t]*' w='[a-zA-Z0-9_]*' fs=${fs:-$(echo @|tr @ '\034')} i=${i:-  }

  ###############################################################################
  # cat:   read the yaml file into the stream
  # awk 1: process multi-line text
  # sed 1: remove comments and empty lines
  # sed 2: process lists
  # sed 3: process dictionaries
  # sed 4: rearrange anchors
  # sed 5: remove '---'/'...'/quotes, add file separator to create fields for awk 2
  # awk 2: convert the formatted data to variable assignments
  ###############################################################################

  cat $1 | \
  awk -F$fs "{multi=0;
      if(match(\$0,/$sm\|$sm$/)){multi=1; sub(/$sm\|$sm$/,\"\");}
      if(match(\$0,/$sm>$sm$/)){multi=2; sub(/$sm>$sm$/,\"\");}
      while(multi>0){
          str=\$0; gsub(/^$sm/,\"\", str);
          indent=index(\$0,str);
          indentstr=substr(\$0, 0, indent+$indexfix) \"$i\";
          obuf=\$0;
          getline;
          while(index(\$0,indentstr)){
              obuf=obuf substr(\$0, length(indentstr)+1);
              if (multi==1){obuf=obuf \"\\\\n\";}
              if (multi==2){
                  if(match(\$0,/^$sm$/))
                      obuf=obuf \"\\\\n\";
                      else obuf=obuf \" \";
              }
              getline;
          }
          sub(/$sm$/,\"\",obuf);
          print obuf;
          multi=0;
          if(match(\$0,/$sm\|$sm$/)){multi=1; sub(/$sm\|$sm$/,\"\");}
          if(match(\$0,/$sm>$sm$/)){multi=2; sub(/$sm>$sm$/,\"\");}
      }
  print}" | \
  sed -e "s|^\($s\)?|\1-|" \
      -ne "s|^\($s\)-$s\($w\)$s:$s\(.*\)|\1-\n\1 \2: \3|" \
      -ne "s|^$s#.*||;s|$s#[^\"']*$||;s|^\([^\"'#]*\)#.*|\1|;t 1" \
      -ne "t" \
      -ne ":1" \
      -ne "s|^$s\$||;t 2" \
      -ne "p" \
      -ne ":2" \
      -ne "d" | \
  sed -ne "s|,$s\]|]|g" \
      -e ":1" \
      -e "s|^\($s\)\($w\)$s:$s\(&$w\)$s\[$s\(.*\)$s,$s\(.*\)$s\]|\1\2: \3[\4]\n\1$i- \5|;t 1" \
      -e "s|^\($s\)\($w\)$s:$s\(&$w\)$s\[$s\(.*\)$s\]|\1\2: \3\n\1$i- \4|;" \
      -e ":2" \
      -e "s|^\($s\)\($w\)$s:$s\[$s\(.*\)$s,$s\(.*\)$s\]|\1\2: [\3]\n\1$i- \4|;t 2" \
      -e "s|^\($s\)\($w\)$s:$s\[$s\(.*\)$s\]|\1\2:\n\1$i- \3|;" \
      -e ":3" \
      -e "s|^\($s\)-$s\[$s\(.*\)$s,$s\(.*\)$s\]|\1- [\2]\n\1$i- \3|;t 3" \
      -e "s|^\($s\)-$s\[$s\(.*\)$s\]|\1-\n\1$i- \2|;p" | \
  sed -ne "s|,$s}|}|g" \
      -e ":1" \
      -e "s|^\($s\)-$s{$s\(.*\)$s,$s\($w\)$s:$s\(.*\)$s}|\1- {\2}\n\1$i\3: \4|;t 1" \
      -e "s|^\($s\)-$s{$s\(.*\)$s}|\1-\n\1$i\2|;" \
      -e ":2" \
      -e "s|^\($s\)\($w\)$s:$s\(&$w\)$s{$s\(.*\)$s,$s\($w\)$s:$s\(.*\)$s}|\1\2: \3 {\4}\n\1$i\5: \6|;t 2" \
      -e "s|^\($s\)\($w\)$s:$s\(&$w\)$s{$s\(.*\)$s}|\1\2: \3\n\1$i\4|;" \
      -e ":3" \
      -e "s|^\($s\)\($w\)$s:$s{$s\(.*\)$s,$s\($w\)$s:$s\(.*\)$s}|\1\2: {\3}\n\1$i\4: \5|;t 3" \
      -e "s|^\($s\)\($w\)$s:$s{$s\(.*\)$s}|\1\2:\n\1$i\3|;p" | \
  sed -e "s|^\($s\)\($w\)$s:$s\(&$w\)\(.*\)|\1\2:\4\n\3|" \
      -e "s|^\($s\)-$s\(&$w\)\(.*\)|\1- \3\n\2|" | \
  sed -ne "s|^\($s\):|\1|" \
      -e "s|^\($s\)\(---\)\($s\)||" \
      -e "s|^\($s\)\(\.\.\.\)\($s\)||" \
      -e "s|^\($s\)-$s[\"']\(.*\)[\"']$s\$|\1$fs$fs\2|p;t" \
      -e "s|^\($s\)\($w\)$s:$s[\"']\(.*\)[\"']$s\$|\1$fs\2$fs\3|p;t" \
      -e "s|^\($s\)-$s\(.*\)$s\$|\1$fs$fs\2|" \
      -e "s|^\($s\)\($w\)$s:$s[\"']\?\(.*\)$s\$|\1$fs\2$fs\3|" \
      -e "s|^\($s\)[\"']\?\([^&][^$fs]\+\)[\"']$s\$|\1$fs$fs$fs\2|" \
      -e "s|^\($s\)[\"']\?\([^&][^$fs]\+\)$s\$|\1$fs$fs$fs\2|" \
      -e "s|^\($s\)\($w\)$s:$s[\"']\(.*\)$s\$|\1$fs\2$fs\3|" \
      -e "s|^\($s\)[\"']\([^&][^$fs]*\)[\"']$s\$|\1$fs$fs$fs\2|" \
      -e "s|^\($s\)[\"']\([^&][^$fs]*\)$s\$|\1$fs$fs$fs\2|" \
      -e "s|^\($s\)\($w\)$s:$s\(.*\)$s\$|\1$fs\2$fs\3|" \
      -e "s|^\($s\)\([^&][^$fs]*\)[\"']$s\$|\1$fs$fs$fs\2|" \
      -e "s|^\($s\)\([^&][^$fs]*\)$s\$|\1$fs$fs$fs\2|" \
      -e "s|$s\$||p" | \
  awk -F$fs "{
      gsub(/\t/,\"        \",\$1);
      if(NF>3){if(value!=\"\"){value = value \" \";}value = value  \$4;}
      else {
          if(match(\$1,/^&/)){anchor[substr(\$1,2)]=full_vn;getline};
          indent = length(\$1)/length(\"$i\");
          vname[indent] = \$2;
          value= \$3;
          for (i in vname) {if (i > indent) {delete vname[i]; idx[i]=0}}
          if(length(\$2)== 0){  vname[indent]= ++idx[indent] };
          vn=\"\"; for (i=0; i<indent; i++) { vn=(vn)(vname[i])(\"$separator\")}
          vn=\"$prefix\" vn;
          full_vn=vn vname[indent];
          if(vn==\"$prefix\")vn=\"$prefix$separator\";
          if(vn==\"_\")vn=\"__\";
      }
      assignment[full_vn]=value;
      if(!match(assignment[vn], full_vn))assignment[vn]=assignment[vn] \" \" full_vn;
      if(match(value,/^\*/)){
          ref=anchor[substr(value,2)];
          if(length(ref)==0){
              printf(\"%s=\\\"%s\\\"\n\", full_vn, value);
          } else {
              for(val in assignment){
                  if((length(ref)>0)&&index(val, ref)==1){
                      tmpval=assignment[val];
                      sub(ref,full_vn,val);
                      if(match(val,\"$separator\$\")){
                          gsub(ref,full_vn,tmpval);
                      } else if (length(tmpval) > 0) {
                          printf(\"%s=\\\"%s\\\"\n\", val, tmpval);
                      }
                      assignment[val]=tmpval;
                  }
              }
          }
      } else if (length(value) > 0) {
          printf(\"%s=\\\"%s\\\"\n\", full_vn, value);
      }
  }END{
      for(val in assignment){
          if(match(val,\"$separator\$\"))
              printf(\"%s=\\\"%s\\\"\n\", val, assignment[val]);
      }
  }"
}

# check if the file exists, if not, exit.
function check_file_exists(){
  if [ ! -f "$1" ]; then
    err "file $1 not exists"
    exit 1
  fi
}
function check_directory_exists(){
  if [ ! -d "$1" ]; then
    err "directory $1 not exists"
    exit 1
  fi
}

HOST_DB_HOME="$(
  cd "$(dirname "$0")/../" >/dev/null 2>&1
  pwd -P
)"
info "HOST_DB_HOME = ${HOST_DB_HOME}"
mkdir -p "${HOST_DB_HOME}/data"

################### GET USER INFO ###################
# get uid
uid=$(id -u)
# get group id
gid=$(id -g)


####################  DEFINE CONSTANTS ####################

# the log directory
# HOST_DB_INTERACTIVE_YAML="${HOST_DB_CONF_DIR}/interactive.yaml"
HOST_DB_RUNNING_FILE="${HOST_DB_HOME}/.running"
HOST_DB_ENV_FILE="${HOST_DB_HOME}/.env"

DOCKER_DB_GRAPHSCOPE_HOME="/opt/flex"
DOCKER_DB_GIE_HOME="${DOCKER_DB_GRAPHSCOPE_HOME}"
DOCKER_DB_SERVER_BIN="${DOCKER_DB_GRAPHSCOPE_HOME}/bin/interactive_server"
DOCKER_DB_GRAPH_IMPORT_BIN="${DOCKER_DB_GRAPHSCOPE_HOME}/bin/bulk_loader"
DOCKER_DB_COMPILER_BIN="com.alibaba.graphscope.GraphServer"
DOCKER_DB_GEN_BIN="${DOCKER_DB_GRAPHSCOPE_HOME}/bin/load_plan_and_gen.sh"
HOST_DB_TMP_DIR="/tmp/"

#################### DEFINE DEFAULT CONSTANTS ####################
DATABASE_VERSION="v0.0.3"
DATABASE_DEFAULT_GRAPH_NAME="gs_interactive_default_graph"
DATABASE_CURRENT_GRAPH_NAME=${DATABASE_DEFAULT_GRAPH_NAME}
DATABASE_DEFAULT_GRAPH_DOCKER_PATH="/home/graphscope/${DATABASE_DEFAULT_GRAPH_NAME}"
DATABASE_DEFAULT_GRAPH_MOUNT_CMD="${HOST_DB_HOME}/examples/modern_graph/:${DATABASE_DEFAULT_GRAPH_DOCKER_PATH}"
DATABASE_VOLUMES="${DATABASE_DEFAULT_GRAPH_MOUNT_CMD}"
DATABASE_LOG_LEVEL="INFO"
DATABASE_PORTS=""

## compiler related default configuration
DATABASE_COMPILER_PLANNER_IS_ON="true"
DATABASE_COMPILER_PLANNER_OPT="RBO"
DATABASE_COMPILER_PLANNER_RULES="FilterIntoJoinRule,FilterMatchRule,NotMatchToAntiJoinRule"
DATABASE_COMPILER_ENDPOINT_ADDRESS="localhost"
DATABASE_COMPILER_BOLT_PORT="7687"
DATABASE_COMPILER_QUERY_TIMEOUT="20000"

## hiactor related default configuration
DATABASE_COMPUTE_ENGINE_PORT="10000"
DATABASE_ADMIN_PORT="7777"
DATABASE_COMPUTE_ENGINE_THREAD_NUM_PER_WORKER=1

## directories
DATABASE_WORKSPACE="/home/graphscope/workspace/"
DATABASE_DATA_DIR_NAME="data"
DATABASE_LOG_DIR_NAME="logs"
DATABASE_CONF_DIR_NAME="conf"


################### IMAGE VERSION ###################
GIE_DB_IMAGE_NAME="registry.cn-hongkong.aliyuncs.com/graphscope/${DB_PROD_NAME}"
#GIE_DB_IMAGE_NAME="interactive"
GIE_DB_CONTAINER_NAME="${DB_PROD_NAME}-server"


####################  Prepare uncreated directories ####################

info "Finish create log dir"

####################  DEFINE FUNCTIONS ####################

function check_graph_name_valid() {
  if [ $# -ne 1 ]; then
    err "Expect graph name given."
    exit 1
  fi
  local graph_name=$1
  # check graph_name can be a valid directory name
  if [[ ! "${graph_name}" =~ ^[a-zA-Z0-9_]+$ ]]; then
    err "graph name [${graph_name}] is not valid, only [a-zA-Z0-9_] are allowed."
    exit 1
  fi
}
function check_running_containers_and_exit(){
  # check if there is any running containers
  info "Check running containers and exit"
  running_containers=$(docker ps -a --format "{{.Names}}" | grep "${GIE_DB_CONTAINER_NAME}")
  if [[ -n "${running_containers}" ]]; then
    err "There are running containers: ${running_containers}, please stop them first."
    exit 1
  fi
  info "finish check"
}

function check_container_running(){
  if [ "$(docker inspect -f '{{.State.Running}}' "${GIE_DB_CONTAINER_NAME}")" = "true" ]; then
    info "container ${GIE_DB_CONTAINER_NAME} is running"
  else
    info "container ${GIE_DB_CONTAINER_NAME} is not running"
    # start the container
    docker start "${GIE_DB_CONTAINER_NAME}"
  fi
}

function ensure_container_running(){
  if [ "$(docker inspect -f '{{.State.Running}}' "${GIE_DB_CONTAINER_NAME}")" = "true" ]; then
    info "container ${GIE_DB_CONTAINER_NAME} is running"
  else
    info "container ${GIE_DB_CONTAINER_NAME} is not running"
    # start the container
    docker start "${GIE_DB_CONTAINER_NAME}"
  fi
}

function check_process_running_in_container(){
  local container_name=$1
  local process_name=$2
  local error_msg=$3
  local process_id=$(docker top  "${container_name}" | grep "${process_name}" | awk '{print $2}')
  if [ -z "${process_id}" ]; then
    err "process ${process_name} is not running in container ${container_name}"
    err "${error_msg}"
    exit 1 
  fi
  info "process ${process_name} is running in container ${container_name}, process id is ${process_id}"
}

function check_process_not_running_in_container(){
  local container_name=$1
  local process_name=$2
  local error_msg=$3
  local process_id=$(docker top  "${container_name}" | grep "${process_name}" | awk '{print $2}')
  if [ -z "${process_id}" ]; then
    info "process ${process_name} is not running in container ${container_name}"
  else
    err "process ${process_name} is running in container ${container_name}, process id is ${process_id}"
    err "${error_msg}"
    exit 1
  fi
}

# check the given graph is locked or not.
function check_graph_not_running(){
  info "Check graph whether is not running"
  if [ $# -ne 1 ]; then
    err "Expect graph name given."
    exit 1
  fi
  local graph_name=$1
  # check whether .lock is presented in container's data/${graph_name}/ directory
  if [ -f "${HOST_DB_RUNNING_FILE}" ]; then
      . ${HOST_DB_ENV_FILE}
  fi
  local lock_file="${DATABASE_WORKSPACE}/data/${graph_name}/.lock"
  info "Check lock file ${lock_file}"
  # check lock_file whether exists in container, if not exists, exit 0, else exit 1
  docker exec "${GIE_DB_CONTAINER_NAME}" bash -c "[ ! -f ${lock_file} ]"
}

function update_init_config_from_yaml(){
  if [ $# -ne 1 ]; then
    err "Expect configuration file given"
    exit 1
  fi
  config_file=$1
  eval $(parse_yaml "${config_file}")
  # update workspace if exists
  if [[ -n "${workspace}" ]]; then
    DATABASE_WORKSPACE="${workspace}"
  fi
  # update database version if exists
  if [[ -n "${version}" ]]; then
    DATABASE_VERSION="${version}"
  fi
  # append the found volumes to DATABASE_VOLUMES
  # map the HOST_DB_HOME/data/ to ${DATABASE_WORKSPACE}/data
  DATABASE_VOLUMES="${DATABASE_VOLUMES},${HOST_DB_HOME}/data:${DATABASE_WORKSPACE}/data"

  x=1
  while true; do
    volume_x_key="volume_${x}"
    volume_x=$(eval echo "\$${volume_x_key}")
    if [ -z "${volume_x}" ]; then
      break
    fi
    DATABASE_VOLUMES="${DATABASE_VOLUMES},${volume_x}"
    x=$((x + 1))
  done
  # append compiler port and engine port to DATABASE_PORTS
  DATABASE_PORTS="${DATABASE_COMPILER_BOLT_PORT}:${DATABASE_COMPILER_BOLT_PORT}"
  DATABASE_PORTS="${DATABASE_PORTS},${DATABASE_COMPUTE_ENGINE_PORT}:${DATABASE_COMPUTE_ENGINE_PORT}"
  DATABASE_PORTS="${DATABASE_PORTS},${DATABASE_ADMIN_PORT}:${DATABASE_ADMIN_PORT}"
}

function update_engine_config_from_yaml(){
  if [ $# -ne 1 ]; then
    err "Expect configuration file given"
    exit 1
  fi
  config_file=$1
  eval $(parse_yaml "${config_file}")
  if [[ -n "${log_level}" ]]; then
    DATABASE_LOG_LEVEL="${log_level}"
  fi
  # default_graph
  if [[ -n "${default_graph}" ]]; then
    DATABASE_CURRENT_GRAPH_NAME="${default_graph}"
  fi
  # update hiactor shard num
  if [[ -n "${compute_engine_thread_num_per_worker}" ]]; then
    DATABASE_COMPUTE_ENGINE_THREAD_NUM_PER_WORKER="${compute_engine_thread_num_per_worker}"
  fi
  # compiler
  if [[ -n ${compiler_planner_is_on} ]]; then 
    DATABASE_COMPILER_PLANNER_IS_ON="${compiler_planner_is_on}"
  fi
  info "Found compiler planner opt: ${compiler_planner_is_on}, ${DATABASE_COMPILER_PLANNER_IS_ON}"
  if [[ -n ${compiler_planner_opt} ]]; then 
    DATABASE_COMPILER_PLANNER_OPT="${compiler_planner_opt}"
  fi
  # append the founded compiler planner rules to DATABASE_COMPILER_PLANNER_RULES
  x=1
  CURRENT_DATABASE_COMPILER_PLANNER_RULES=""
  while true; do
    compiler_planner_rules_x_key="compiler_planner_rules_${x}"
    compiler_planner_rules_x=$(eval echo "\$${compiler_planner_rules_x_key}")
    if [ -z "${compiler_planner_rules_x}" ]; then
      break
    fi
    # check compiler_planner_rules_x present in DATABASE_COMPILER_PLANNER_RULES, if not, append
    if [[ ! "${CURRENT_DATABASE_COMPILER_PLANNER_RULES}" =~ "${compiler_planner_rules_x}" ]]; then
      CURRENT_DATABASE_COMPILER_PLANNER_RULES="${CURRENT_DATABASE_COMPILER_PLANNER_RULES},${compiler_planner_rules_x}"
    fi
    x=$((x + 1))
  done
  # if CURRENT_DATABASE_COMPILER_PLANNER_RULES is not empty,override DATABASE_COMPILER_PLANNER_RULES
  if [[ -n "${CURRENT_DATABASE_COMPILER_PLANNER_RULES}" ]]; then
    # remove the first ','
    CURRENT_DATABASE_COMPILER_PLANNER_RULES=$(echo "${CURRENT_DATABASE_COMPILER_PLANNER_RULES}" | sed 's/^,//g')
    DATABASE_COMPILER_PLANNER_RULES="${CURRENT_DATABASE_COMPILER_PLANNER_RULES}"
  fi
  if [[ -n "${compiler_endpoint_address}" ]]; then
    DATABASE_COMPILER_ENDPOINT_ADDRESS="${compiler_endpoint_address}"
  fi
  if [[ -n "${compiler_endpoint_bolt_connector_port}" ]]; then
    DATABASE_COMPILER_BOLT_PORT="${compiler_endpoint_bolt_connector_port}"
  fi
  if [[ -n "${compiler_query_timeout}" ]]; then
    DATABASE_COMPILER_QUERY_TIMEOUT="${compiler_query_timeout}"
  fi
}

function amplify_graph_schema(){
  # two args, input schema_file and output schema_file
  if [ $# -ne 2 ]; then
    err "Expect two args, but got $#"
    exit 1
  fi
  input_schema_file=$1
  output_schema_file=$2
  # check input_schema_file exists
  check_file_exists "${input_schema_file}"
  # rm output_schema_file if exists
  if [ -f "${output_schema_file}" ]; then
    rm "${output_schema_file}"
  fi
  # read input_schema_file line by line, and append to output_schema_file
  local cur_vertex_label_ind=0
  local cur_edge_label_ind=0
  local cur_prop_ind=0
  # the type id may not be specified in input_schema_file
  local type_id_specified=false
  local prop_id_specified=false
  # if stored_type is not specified in input_schema_file's content, append it to output_schema_file
  stored_type_specified=false
  label_type="vertex"
  IFS=''
  while read -r line; do
    if [[ "${line}" =~ ^[[:space:]]*# ]]; then
     echo "found comment line ${line}"
    else
      # if line contains 'type_name', then prepend - type_id: 0 before it
      if [[ "${line}" =~ vertex_types ]]; then 
        label_type="vertex"
        echo ${line} >> "${output_schema_file}"
      elif [[ "${line}" =~ edge_types ]]; then
        label_type="edge"
        echo ${line} >> "${output_schema_file}"
      elif [[ "${line}" =~ type_id ]]; then
        type_id_specified=true
        echo ${line} >> "${output_schema_file}"
      elif [[ "${line}" =~ property_id ]]; then
        prop_id_specified=true
        echo ${line} >> "${output_schema_file}"
      elif [[ "${line}" =~ type_name ]] && [ "${type_id_specified}" == "false" ]; then
        if [ "${label_type}" == "edge" ]; then
          echo "    - type_id: ${cur_edge_label_ind}" >> "${output_schema_file}"
          cur_edge_label_ind=$((cur_edge_label_ind + 1))
        else 
          echo "    - type_id: ${cur_vertex_label_ind}" >> "${output_schema_file}"
          cur_vertex_label_ind=$((cur_vertex_label_ind + 1))
        fi
        cur_prop_ind=0
        type_id_specified=false
        echo "${line}" | sed 's/- /  /g' >> "${output_schema_file}"
      elif [[ "${line}" =~ property_name ]] && [ "${prop_id_specified}" == "false" ]; then
        echo "        - property_id: ${cur_prop_ind}" >> "${output_schema_file}"
        cur_prop_ind=$((cur_prop_ind + 1))
        prop_id_specified=false
        # replace the '- ' in ${line} and append to output_schema_file
        echo "${line}" | sed 's/- /  /g' >> "${output_schema_file}"
      elif [[ "${line}" =~ store_type ]]; then
        stored_type_specified=true
        emph "stored type : ${stored_type_specified}"
        echo "${line}" >> "${output_schema_file}"
      else
        echo "${line}" >> "${output_schema_file}"
      fi
    fi
  done <<< $(cat "${input_schema_file}")
  if [ "${stored_type_specified}" == "false" ]; then
    emph "stored type : ${stored_type_specified}"
    echo "store_type: mutable_csr" >> "${output_schema_file}"
  fi
  info "Finish amplify schema file ${input_schema_file} to ${output_schema_file}"
}


####################  DEFINE USAGE ####################

function init_usage() {
  cat << EOF
    gs_interactive init -c [--config] <config file>
                Init the database, create the containers. Specify the database version and volume mounting in the config yaml.
EOF
}

function destroy_usage() {
  cat << EOF
    gs_interactive destroy
                Destroy the current database, remove the container.
EOF
}

function create_usage() {
  cat << EOF
    gs_interactive database create -g [--graph] <graph_name> -c [--config] <schema file>
                Create a graph in database, with the provided schema file.
                User should import data to the created graph.
EOF
}

function remove_usage() {
  cat << EOF
    gs_interactive database remove -g [--graph] <graph_name> 
                Remove the database with the given graph.
EOF
}

function import_usage() {
  cat << EOF
    gs_interactive database import -g [--graph] <graph_name> -c [--config] <bulk load file>
                Load the raw data specified in bulk load file to the specified graph.
EOF
}

function list_usage() {
  cat << EOF
    gs_interactive database list
                List all graphs in the database.
EOF
}

function database_usage(){
  create_usage
  remove_usage
  import_usage
  list_usage
}


function start_usage() {
  cat << EOF
    gs_interactive service start -g [--graph] <graph_name> -c [--config] <engine config file>
                Start the graph service on the specified graph, with the provided engine config file.
EOF
}

function stop_usage() {
  cat << EOF
    gs_interactive service stop
                Stop the database with the given graph.
EOF
}

function restart_usage() {
  cat << EOF
    gs_interactive service restart -c [--config] [engine config file]
                Restart the database with current running graph. Can update with new engine config file.
EOF
}

function get_log_usage() {
  cat << EOF
    gs_interactive service get_log -o [--output] output directory
                Get the log of the specified service/compiler, and write to the output file.
EOF
}

function services_usage(){
  start_usage
  stop_usage
  restart_usage
  get_log_usage
}

function compile_usage(){
  cat << EOF
    gs_interactive procedure compile -g[--graph] <graph_name> -i <sourcefile[.cc, .cypher, directory] 
                                  -n[--name] <name of the stored procedure> -d [--description] <description of the stored procedure>
                                  --compile_only 
                Compile cypher/.cc to dynamic library, according to the schema of graph. The output library will be placed at ./data/{graph_name}/lib.
                If --compile_only is specified, the library will not be loaded to the graph.
EOF
}

## .enable and .disable file controls the stored procedure enable/disable

function enable_proc_usage(){
  cat << EOF
    gs_interactive procedure enable -g[--graph] <graph_name> -n[--name] <library names,separated by ','>
                                 -c[--config] <stored_procedures.yaml>
                Enable the stored procedure in the given graph, with the provided library.
                stored_procedures.yaml contains the stored procedure names at each line.
EOF
}

function disable_proc_usage(){
  cat << EOF
    gs_interactive procedure disable -g[--graph] <graph_name> -n[--name] <library names,separated by ','>
                                  -c[--config] <stored_procedures.yaml>
                Disable the stored procedure in the given graph, with the provided library.
                stored_procedures.yaml contains the stored procedure names at each line.
EOF
}

function show_stored_procedure_usage(){
  cat << EOF
    gs_interactive procedure show -g[--graph] graph_name
                Show all stored procedure for the given graph.
EOF
}


function procedure_usage(){
  compile_usage
  enable_proc_usage
  disable_proc_usage
  show_stored_procedure_usage
}

# parse the args and set the variables.
function usage() {
  init_usage
  destroy_usage
  database_usage
  services_usage
  procedure_usage
}

################### Generate config file ###################
function do_gen_conf(){
  # receive only one args, the config file
  while [[ $# -gt 0 ]]; do
    key="$1"
    case $key in
    -o | --output)
      output_config_file="$2"
      shift
      shift
      ;;
    *)
      err "unknown option $1"
      exit 1
      ;;
    esac
  done

  #if output_config_file exists, remove the file, if remove failed, exists
  if [ -f "${output_config_file}" ]; then
    if ! rm "${output_config_file}"; then
      err "remove ${output_config_file} failed"
      exit 1
    fi
  fi
  
  # echo directories
  echo "directories:" >> ${output_config_file}
  echo "  workspace: ${DATABASE_WORKSPACE}" >> ${output_config_file}
  echo "  subdirs:" >> ${output_config_file}
  echo "    data: ${DATABASE_DATA_DIR_NAME}" >> ${output_config_file}
  echo "    logs: ${DATABASE_LOG_DIR_NAME}" >> ${output_config_file}
  echo "    conf: ${DATABASE_CONF_DIR_NAME}" >> ${output_config_file}

  # log level
  echo "log_level: ${DATABASE_LOG_LEVEL}" >> ${output_config_file}

  # current graph
  echo "default_graph: ${DATABASE_CURRENT_GRAPH_NAME}" >> ${output_config_file}
  

  #compute_engine
  echo "compute_engine:" >> ${output_config_file}
  echo "  type: hiactor" >> ${output_config_file}
  echo "  workers:" >> ${output_config_file}
  echo "    - localhost:${DATABASE_COMPUTE_ENGINE_PORT}" >> ${output_config_file}
  echo "  thread_num_per_worker: ${DATABASE_COMPUTE_ENGINE_THREAD_NUM_PER_WORKER}" >> ${output_config_file}


  #compiler
  echo "compiler:" >> ${output_config_file}
  echo "  planner:" >> ${output_config_file}
  echo "    is_on: ${DATABASE_COMPILER_PLANNER_IS_ON}" >> ${output_config_file}
  echo "    opt: ${DATABASE_COMPILER_PLANNER_OPT}" >> ${output_config_file}
  # split compiler planner rules and put as sequences in yaml
  echo "    rules:" >> ${output_config_file}
  IFS=',' read -ra RULES_ARRAY <<<"${DATABASE_COMPILER_PLANNER_RULES}"
  for rule in "${RULES_ARRAY[@]}"; do
    echo "      - ${rule}" >> ${output_config_file}
  done
  echo "  endpoint:"  >> ${output_config_file}
  echo "    default_listen_address: ${DATABASE_COMPILER_ENDPOINT_ADDRESS}" >> ${output_config_file}
  echo "    bolt_connector:" >> ${output_config_file}
  echo "      disabled: false" >> ${output_config_file}
  echo "      port: ${DATABASE_COMPILER_BOLT_PORT}" >> ${output_config_file}
  echo "    gremlin_connector:" >> ${output_config_file}
  echo "      disabled: true" >> ${output_config_file}
  echo "      port: 8182" >> ${output_config_file}
  echo "  query_timeout: ${DATABASE_COMPILER_QUERY_TIMEOUT}" >> ${output_config_file}

  #echo http_service
  echo "http_service:" >> ${output_config_file}
  echo "  default_listen_address: localhost" >> ${output_config_file}
  echo "  admin_port: ${DATABASE_ADMIN_PORT}" >> ${output_config_file}
  echo "  query_port: ${DATABASE_COMPUTE_ENGINE_PORT}" >> ${output_config_file}

  info "Finish generate config file ${output_config_file}"
}

function generate_real_engine_conf(){
  # expect less than three args
  if [ $# -gt 2 ] || [ $# -eq 0 ]; then
    err "Expect one or two args, but got $#"
    exit 1
  fi
  if [ $# -eq 1 ]; then
    real_engine_config_file=$1
    info "engine config file is not specified, using default engine config"
    if ! do_gen_conf -o ${real_engine_config_file}; then
      err "generate engine config file failed"
      exit 1
    fi
  else
    engine_config_file=$1
    real_engine_config_file=$2
    check_file_exists "${engine_config_file}"
    update_engine_config_from_yaml "${engine_config_file}"
    if ! do_gen_conf -o ${real_engine_config_file}; then
      err "generate engine config file failed"
      exit 1
    fi
  fi
}

function update_graph_yaml_with_procedure_enabling(){
  # expect one args, graph name
  if [ $# -ne 1 ]; then
    err "Expect one args, but got $#"
    exit 1
  fi
  graph_name=$1

  # gather .enable and append to graph yaml

  if [ -f "${HOST_DB_RUNNING_FILE}" ]; then
      . ${HOST_DB_ENV_FILE}
  fi
  # copy graph_name's graph0.yaml to ${HOST_DB_TMP_DIR}
  docker cp "${GIE_DB_CONTAINER_NAME}:${DATABASE_WORKSPACE}/data/${graph_name}/graph0.yaml" "${HOST_DB_TMP_DIR}/graph0.yaml"
  echo "" >> ${HOST_DB_TMP_DIR}/graph0.yaml
  echo "stored_procedures:" >> ${HOST_DB_TMP_DIR}/graph0.yaml
  echo "  enable_lists:" >> ${HOST_DB_TMP_DIR}/graph0.yaml
  # copy graph_name's .enable file to ${HOST_DB_TMP_DIR}
  if [ -f "${HOST_DB_TMP_DIR}/.enable" ]; then
    if ! rm "${HOST_DB_TMP_DIR}/.enable"; then
      err "remove ${HOST_DB_TMP_DIR}/.enable failed"
      exit 1
    fi
  fi

  docker cp "${GIE_DB_CONTAINER_NAME}:${DATABASE_WORKSPACE}/data/${graph_name}/plugins/.enable" "${HOST_DB_TMP_DIR}/.enable" || true
  # get .enable and .disable file
  local enable_file="${HOST_DB_TMP_DIR}/.enable"
  any_stored_procedures=false
  # check enable_file and disable_file exists
  if [ ! -f "${enable_file}" ]; then
    info "enable file ${enable_file} not exists, all stored procedure are enabled"
  else
    # cat all lines in enable_file and split by '\n'
    while IFS= read -r line; do
      echo "Found enable procedure: $line"
      echo "    - ${line}" >> ${HOST_DB_TMP_DIR}/graph0.yaml
      any_stored_procedures=true
    done < ${enable_file}
  fi
  if [ "${any_stored_procedures}" = false ]; then
    echo "  directory: not-a-directory" >> ${HOST_DB_TMP_DIR}/graph0.yaml
  else
    echo "  directory: plugins" >> ${HOST_DB_TMP_DIR}/graph0.yaml
  fi
  
  # copy graph0.yaml to container
  docker cp "${HOST_DB_TMP_DIR}/graph0.yaml" "${GIE_DB_CONTAINER_NAME}:${DATABASE_WORKSPACE}/data/${graph_name}/graph.yaml"
  info "Finish update graph yaml with procedure enabling, add stored procedures of size ${#ENABLED_ARRAY[@]}."
}


function check_database_initialized(){
  # check if the container is running
  running_containers=$(docker ps -a --format "{{.Names}}" | grep "${GIE_DB_CONTAINER_NAME}")
  if [[ -z "${running_containers}" ]]; then
    err "Database is not initialized, please run init command first."
    exit  1
  fi
}

####################  Init database ####################
# Init the current data base.
# create a user with same user id in container
function do_init(){
  # check running containers and exit
  check_running_containers_and_exit
  info "Ok, no running instance found, start init database..."
  # if no containers running, proceed to init

#  check args num 1, and get the first args as CONFIG_FILE
  if [ $# -eq 0 ]; then
    err "init command need 1 args, but got $#"
    init_usage
    exit 1
  fi

  while [[ $# -gt 0 ]]; do
    key="$1"
    case $key in
    -c | --config)
      config_file="$2"
      shift # past argument
      shift
      ;;
    *)
      err "unknown option $1"
      init_usage
      exit 1
      ;;
    esac
  done

  check_file_exists "${config_file}"

  # Parse the configuration presented in yaml, and override the default values.
  update_init_config_from_yaml "${config_file}"

  #if $HOST_DB_ENV_FILE exists, remove it
  if [ -f "${HOST_DB_ENV_FILE}" ]; then
    if ! rm "${HOST_DB_ENV_FILE}"; then
      err "remove ${HOST_DB_ENV_FILE} failed"
      exit 1
    fi
  fi
  if ! touch "${HOST_DB_ENV_FILE}"; then
    err "create ${HOST_DB_ENV_FILE} failed"
    exit 1
  fi

  #0. Found workspace
  info "Found docker db home: ${DATABASE_WORKSPACE}"
  # put docker_workspace into env
  echo "export DATABASE_WORKSPACE=${DATABASE_WORKSPACE}" >> ${HOST_DB_ENV_FILE}
  echo "export DATABASE_DATA_DIR_NAME=${DATABASE_DATA_DIR_NAME}" >> ${HOST_DB_ENV_FILE}
  info "Found database version: ${DATABASE_VERSION}"

  #2. Found mounting volumes from yaml file
  mount_cmd=""
  # split DATABASE_VOLUMES and append to mount_cmd
  IFS=',' read -ra VOLUME_ARRAY <<<"${DATABASE_VOLUMES}"
  for volume in "${VOLUME_ARRAY[@]}"; do
    # split with : and check host path exists
    volume_value_array=(${volume//:/ })
    # if volume_value_array length is not 2, error
    if [ ${#volume_value_array[@]} -ne 2 ]; then
      err "volume ${volume_value_array} is not valid, should be <host_path>:<docker_path>"
      exit 1
    fi
    # get host_path
    host_path=${volume_value_array[0]}
    docker_path=${volume_value_array[1]}
    # check host_path exists
    info "Found host path: ${host_path}"
    check_directory_exists "${host_path}" || (err "host path ${host_path} not exists" && exit 1)
    mount_cmd="${mount_cmd} -v ${volume}"
  done
#  mount_cmd="${mount_cmd} -v /etc/passwd:/etc/passwd:ro -v /etc/group:/etc/group:ro"
 
  info "Found docker volumes: ${mount_cmd}"

  #3. get mapped port
  port_cmd=""
  # split the DATABASE_PORTS and append to port_cmd
  IFS=',' read -ra DATABASE_PORTS_ARRAY <<<"${DATABASE_PORTS}"
  for ports in "${DATABASE_PORTS_ARRAY[@]}"; do
    port_x_value_array=(${ports//:/ })
    # if volume_x_value_array length is not 2, error
    if [ ${#port_x_value_array[@]} -ne 2 ]; then
      err "port ${port_x_value_array} is not valid, should be <host_port>:<docker_port>"
      exit 1
    fi
    # get host_path
    host_port=${port_x_value_array[0]}
    docker_port=${port_x_value_array[1]}
    #check port are int
    if ! [[ "${host_port}" =~ ^[0-9]+$ ]]; then
      err "host port ${host_port} is not valid"
      exit 1
    fi
    if ! [[ "${docker_port}" =~ ^[0-9]+$ ]]; then
      err "docker port ${docker_port} is not valid"
      exit 1
    fi
    port_cmd="${port_cmd} -p ${host_port}:${docker_port}"
  done
  info "Found docker port: ${port_cmd}"

    # get uid 
  local uid=$(id -u)
  local gid=$(id -g)
  # get group name
  local group_name=$(id -gn)
  # get username
  local username=$(id -un)

  GIE_DB_IMAGE_NAME_TAG="${GIE_DB_IMAGE_NAME}:${DATABASE_VERSION}"
  cmd="docker run -it -d --privileged --name ${GIE_DB_CONTAINER_NAME}"

  # create user in container
  cmd="${cmd} ${port_cmd} ${mount_cmd} ${GIE_DB_IMAGE_NAME_TAG} bash"
  
  info "Running cmd: ${cmd}"
  # eval $cmd, exit if failed
  if ! eval $cmd; then
    err "Fail to init database."
    exit 1
  fi

  info "Finish init database"

  # create the workspace directory in container
  docker exec -u graphscope "${GIE_DB_CONTAINER_NAME}" bash -c "mkdir -p ${DATABASE_WORKSPACE}" || exit 1
  docker exec -u graphscope "${GIE_DB_CONTAINER_NAME}" bash -c "sudo chown -R graphscope:graphscope ${DATABASE_WORKSPACE}" || exit 1
  docker exec -u graphscope "${GIE_DB_CONTAINER_NAME}" bash -c "mkdir -p ${DATABASE_WORKSPACE}/logs" || exit 1
  docker exec -u graphscope "${GIE_DB_CONTAINER_NAME}" bash -c "mkdir -p ${DATABASE_WORKSPACE}/conf" || exit 1
  docker exec -u graphscope "${GIE_DB_CONTAINER_NAME}" bash -c "mkdir -p ${DATABASE_WORKSPACE}/data" || exit 1

  # create default_graph
  do_create -g ${DATABASE_DEFAULT_GRAPH_NAME} -c ${HOST_DB_HOME}/examples/modern_graph/modern_graph.yaml
  # check whether do_import success
  if ! do_import -g ${DATABASE_DEFAULT_GRAPH_NAME} -c ${HOST_DB_HOME}/examples/modern_graph/bulk_load.yaml; then
    err "Fail to import default graph"
    exit 1
  fi
  info "Successfully create and import default graph: [${DATABASE_DEFAULT_GRAPH_NAME}]"
}


####################  Create graph ####################
function do_create(){
  while [[ $# -gt 0 ]]; do
    key="$1"
    case $key in
    -g | --graph)
      graph_name="$2"
      shift # past argument
      shift
      ;;
    -c | --config)
      schema_file="$2"
      shift
      shift
      ;;
    *)
      err "unknown option $1"
      create_usage
      exit 1
      ;;
    esac
  done
  # check graph_name is set
  if [ -z "${graph_name}" ]; then
    err "graph name is not specified"
    create_usage
    exit 1
  fi

  if [ -z "${schema_file}" ]; then
    err "graph schema is not specified, need graph_schema.yaml given by -c option"
    create_usage
    exit 1
  fi

  check_graph_name_valid "${graph_name}"
  if [ -d "${HOST_DB_HOME}/data/${graph_name}" ]; then
    err "graph [${graph_name}] has already been created."
    exit 1
  fi
  check_file_exists "${schema_file}"
  amplify_schema_file="${HOST_DB_TMP_DIR}/graph0.yaml"
  # add some default settings and non-user-aware settings to schema file.
  amplify_graph_schema ${schema_file} ${amplify_schema_file}
  # check graph is running inside docker
  check_graph_not_running ${graph_name} || (err "Can not create graph ${graph_name}, since a graph with same naming running." && exit 1)
  # create the graph directory in the docker's workspace
  if [ -f "${HOST_DB_RUNNING_FILE}" ]; then
      . ${HOST_DB_ENV_FILE}
  fi
  docker_graph_dir="${DATABASE_WORKSPACE}/data/${graph_name}"
  docker_graph_schema_file="${docker_graph_dir}/graph.yaml"
  docker_graph_schema_file_back="${docker_graph_dir}/graph0.yaml" # used for later adding/removing stored procedure
  # check docker_graph_schema_file exists in the container, if exists, tell user to remove it first
  docker exec "${GIE_DB_CONTAINER_NAME}" bash -c "[ -f ${docker_graph_schema_file} ] && echo -e \"${RED} Graph ${graph_name} already exists, please remove it first. ${NC}\" && exit 1 || exit 0" || exit 1
  # create the graph directory in the docker's workspace
  docker exec "${GIE_DB_CONTAINER_NAME}" bash -c "mkdir -p ${docker_graph_dir}" || exit 1
  # create plugins dir
  docker exec "${GIE_DB_CONTAINER_NAME}" bash -c "mkdir -p ${docker_graph_dir}/plugins" || exit 1
  # copy the schema file to the docker's workspace
  docker cp "${amplify_schema_file}" "${GIE_DB_CONTAINER_NAME}:${docker_graph_schema_file}" || exit 1
  docker cp "${amplify_schema_file}" "${GIE_DB_CONTAINER_NAME}:${docker_graph_schema_file_back}" || exit 1
  info "Successfully create graph [${graph_name}]"
  #TODO: support creating an empty graph
}

###################Remove graph####################
function do_remove(){
  while [[ $# -gt 0 ]]; do
    key="$1"
    case $key in
    -g | --graph)
      graph_name="$2"
      shift # past argument
      shift
      ;;
    *)
      err "unknown option $1"
      create_usage
      exit 1
      ;;
    esac
  done
  # check graph_name is set
  if [ -z "${graph_name}" ]; then
    err "graph name is not specified"
    remove_usage
    exit 1
  fi
  check_graph_name_valid "${graph_name}"
  # check if the graph is created
  if [ ! -d "${HOST_DB_HOME}/data/${graph_name}" ]; then
    err "graph [${graph_name}] can not be removed, since it is not created."
    exit 1
  fi
  # check graph is running inside docker
  if ! check_graph_not_running ${graph_name}; then
    err "Can not remove graph ${graph_name}, since a graph with same naming running!"
    exit 1;
  fi
  if [ -f "${HOST_DB_RUNNING_FILE}" ]; then
      . ${HOST_DB_ENV_FILE}
  fi
  docker_graph_dir="${DATABASE_WORKSPACE}/data/${graph_name}"
  ### let user confirm to remove the graph
  read -p "Are you sure to remove graph [${graph_name}?] [y/n]" -n 1 -r
  echo
  if [[ ! $REPLY =~ ^[Yy]$ ]]; then
    info "Abort removing graph [${graph_name}]"
    exit 1
  fi

  # rm -rf the graph directory in the docker's workspace
  docker exec "${GIE_DB_CONTAINER_NAME}" bash -c "rm -rf ${docker_graph_dir}" || ( echo "Fail to delete graph ${graph_name}" && exit 1)
  info "Successfully remove graph [${graph_name}]"
  # if graph_name is current graph, set current graph to .running 
  if [ "${DATABASE_CURRENT_GRAPH_NAME}" = "${graph_name}" ]; then
    info "Remove current graph [${graph_name}], set current graph to default_graph: ${DATABASE_DEFAULT_GRAPH_NAME}"
    echo "export DATABASE_CURRENT_GRAPH_NAME=${DATABASE_DEFAULT_GRAPH_NAME}" >> ${HOST_DB_ENV_FILE}
  fi
  #local graph_name=$(sed -n '1p' ${HOST_DB_RUNNING_FILE} | cut -d '=' -f 2)
  # if the removed graph is in .running, remove it
  if [ -f "${HOST_DB_RUNNING_FILE}" ]; then
    local graph_name=$(sed -n '1p' ${HOST_DB_RUNNING_FILE} | cut -d '=' -f 2)
    if [ "${graph_name}" = "${graph_name}" ]; then
      rm ${HOST_DB_RUNNING_FILE}
    fi
  fi
}

####################  Import ####################
function do_import(){
  while [[ $# -gt 0 ]]; do
    key="$1"
    case $key in
    -g | --graph)
      graph_name="$2"
      shift # past argument
      shift
      ;;
    -c | --config)
      bulk_load_file="$2"
      shift
      shift
      ;;
    *)
      err "unknown option $1"
      import_usage
      exit 1
      ;;
    esac
  done
  # check graph_name is set
  if [ -z "${graph_name}" ]; then
    err "graph name is not specified"
    import_usage
    exit 1
  fi
  check_graph_name_valid "${graph_name}"
  if [ ! -d "${HOST_DB_HOME}/data/${graph_name}" ]; then
    err "graph [${graph_name}] can not be found, please create it first"
    exit 1
  fi
  info "Import data to graph [${graph_name}] from ${bulk_load_file}"
  # check if the container is running
  check_container_running
  # check if the bulk_load_file exists
  check_file_exists "${bulk_load_file}"
  info "bulk_load_file ${bulk_load_file} exists"

  check_graph_not_running ${graph_name} || info "Can not import data to graph [${graph_name}], since it is already running."
  if [ -f "${HOST_DB_RUNNING_FILE}" ]; then
      . ${HOST_DB_ENV_FILE}
  fi
  # check graph_schema_file exists in container, if not, let user create graph first
  docker_graph_schema_file="${DATABASE_WORKSPACE}/data/${graph_name}/graph.yaml"
  docker exec "${GIE_DB_CONTAINER_NAME}" bash -c "[ -f ${docker_graph_schema_file} ] || (echo -e \"${RED}graph [${graph_name}] not exists, please create it first.${NC}\" && exit 1)"
  info "Graph Schema exists"
  # copy the bulk_load_file to container
  bulk_load_file_name=$(basename "${bulk_load_file}")
  docker_bulk_load_file="${HOST_DB_TMP_DIR}/${bulk_load_file_name}"
  docker cp "${bulk_load_file}" "${GIE_DB_CONTAINER_NAME}:${docker_bulk_load_file}"

  docker_graph_data_dir="${DATABASE_WORKSPACE}/data//${graph_name}/indices"
  # currently we can only overwrite the indices, so if it exists, remove it first
  docker exec "${GIE_DB_CONTAINER_NAME}" bash -c "[ -d ${docker_graph_data_dir} ] && rm -rf ${docker_graph_data_dir} || exit 0" || exit 1

  cmd="${DOCKER_DB_GRAPH_IMPORT_BIN} -g ${docker_graph_schema_file} -l ${docker_bulk_load_file} -d ${docker_graph_data_dir}"
  info "Running cmd: ${cmd}"
  # docker exec the cmd, fail if cmd fail
  if ! docker exec "${GIE_DB_CONTAINER_NAME}" bash -c  "${cmd} ||(echo -e \"${RED} Fail to import graph [${graph_name}]${NC}\" && exit 1 )"; then
    err "Fail to import graph [${graph_name}]"
    exit 1
  fi
  info "Successfully import data to graph [${graph_name}]"
}

####################  List Graph ####################
function do_list() {
  # check if the container is running
  check_container_running
  # get all graph names
  if [ -f "${HOST_DB_RUNNING_FILE}" ]; then
      . ${HOST_DB_ENV_FILE}
  fi
  host_data_dir="${HOST_DB_HOME}/${DATABASE_DATA_DIR_NAME}"
  # get all graph names into a array
  graph_names=($(ls ${host_data_dir}))
  # if graph_names is empty, no graph exists
  if [ ${#graph_names[@]} -eq 0 ]; then
    info "No graph has been created."
    exit 0
  fi
  # print all graph names
  for graph_name in "${graph_names[@]}"; do
    echo "Found graph: [${graph_name}]"
  done

}

####################  Destroy ####################
function do_destroy() {

  # if container not exists, exit
  if ! docker ps -a --format '{{.Names}}' | grep -Eq "^${GIE_DB_CONTAINER_NAME}$"; then
    info "Database has not been created, exit"
    exit 0
  fi
  # check if the GraphServer and SyncServer are running, if running, echo "Service is running, please stop it first" and exit
  if ! check_process_not_running_in_container ${GIE_DB_CONTAINER_NAME} "GraphServer" "Service is running, please stop it first: ./bin/gs_interactive service stop"; then
    exit 1
  fi
  if ! check_process_not_running_in_container ${GIE_DB_CONTAINER_NAME} "interactive_server" "Service is running, please stop it first: ./bin/gs_interactive service stop"; then
    exit 1
  fi

  # let user confirm to destroy the database
  read -p "Are you sure to destroy the database? [y/n]" -n 1 -r
  echo
  if [[ ! $REPLY =~ ^[Yy]$ ]]; then
    info "Abort destroying database"
    exit 1
  fi

  info "Destroying database..."
  docker stop "${GIE_DB_CONTAINER_NAME}"
  docker rm "${GIE_DB_CONTAINER_NAME}"
  if [ -f "${HOST_DB_RUNNING_FILE}" ]; then
      . ${HOST_DB_ENV_FILE}
  fi
  # rm host data/*
  sudo rm -rf ${HOST_DB_HOME}/data/*

  #rm .running
  if [ -f "${HOST_DB_RUNNING_FILE}" ]; then
    rm ${HOST_DB_RUNNING_FILE}
  fi
  if [ -f "${HOST_DB_ENV_FILE}" ]; then
    rm ${HOST_DB_ENV_FILE}
  fi
  # rm the temp files used
  if [ -f "${HOST_DB_TMP_DIR}/graph0.yaml" ]; then
    rm ${HOST_DB_TMP_DIR}/graph0.yaml
  fi
  if [ -f "${HOST_DB_TMP_DIR}/.enable" ]; then
    rm ${HOST_DB_TMP_DIR}/.enable
  fi
  # rm ${HOST_DB_TMP_DIR}/engine_config.yaml ${HOST_DB_TMP_DIR}/real_engine_config.yaml, ${HOST_DB_TMP_DIR}/graph_exists ${HOST_DB_TMP_DIR}/graph_loaded
  if [ -f "${HOST_DB_TMP_DIR}/engine_config.yaml" ]; then
    rm ${HOST_DB_TMP_DIR}/engine_config.yaml
  fi
  if [ -f "${HOST_DB_TMP_DIR}/real_engine_config.yaml" ]; then
    rm ${HOST_DB_TMP_DIR}/real_engine_config.yaml
  fi
  if [ -f "${HOST_DB_TMP_DIR}/graph_exists" ]; then
    rm ${HOST_DB_TMP_DIR}/graph_exists
  fi
  if [ -f "${HOST_DB_TMP_DIR}/graph_loaded" ]; then
    rm ${HOST_DB_TMP_DIR}/graph_loaded
  fi

  info "Finish destroy database"
}

####################  Start database ####################
function do_start(){
  check_database_initialized
  if [ -f "${HOST_DB_ENV_FILE}" ];then 
    . ${HOST_DB_ENV_FILE}
  fi
  info "Starting database..."

  # check whether the .running file exists, if exists, exit
  local compiler_process_id=$(docker top "${GIE_DB_CONTAINER_NAME}" | grep "${DOCKER_DB_COMPILER_BIN}" | awk '{print $2}')
  local server_process_id=$(docker top "${GIE_DB_CONTAINER_NAME}" | grep "${DOCKER_DB_SERVER_BIN}" | awk '{print $2}')
  # if both process are running, exit
  # if only one process is running, kill the process
  if [ -n "${compiler_process_id}" ] && [ -n "${server_process_id}" ]; then
    local old_graph_name=$(sed -n '1p' ${HOST_DB_RUNNING_FILE} | cut -d '=' -f 2)
    err "Database is already running on [${old_graph_name}], please stop it first"
    exit 1
  fi
  if [ -n "${compiler_process_id}" ]; then
    docker exec "${GIE_DB_CONTAINER_NAME}" bash -c "kill -9 ${compiler_process_id}"
  fi
  if [ -n "${server_process_id}" ]; then
    docker exec "${GIE_DB_CONTAINER_NAME}" bash -c "kill -9 ${server_process_id}"
  fi


  # set trap to do_stop
  trap do_stop SIGINT SIGTERM

  graph_name=""
  engine_config_file=""
  while [[ $# -gt 0 ]]; do
    key="$1"
    case $key in
    -g | --graph)
      graph_name="$2"
      shift # past argument
      shift
      ;;
    -c | --config)
      engine_config_file="$2"
      shift
      shift
      ;;
    *)
      err "unknown option $1"
      start_usage
      exit 1
      ;;
    esac
  done
  # try parse default_graph from engine_config_file
  # generate real engine config file, put it at ${HOST_DB_TMP_DIR}/real_engine_config.yaml
  if  [ -z "${graph_name}" ]; then
    graph_name=${DATABASE_CURRENT_GRAPH_NAME}
  else 
    DATABASE_CURRENT_GRAPH_NAME=${graph_name}
    info "Using user specified graph [${graph_name}]"
  fi
  check_graph_name_valid "${graph_name}"
  if [ ! -d "${HOST_DB_HOME}/data/${graph_name}" ]; then
    err "graph [${graph_name}] can not be found, please create it and import data first."
    exit 1
  fi

  real_engine_config_file="${HOST_DB_TMP_DIR}/real_engine_config.yaml"
  if [ -z "${engine_config_file}" ]; then
    if ! generate_real_engine_conf "${real_engine_config_file}"; then
      err "generate engine config file failed"
      exit 1
    fi
  else 
    if ! generate_real_engine_conf "${engine_config_file}" "${real_engine_config_file}"; then
      err "generate engine config file failed"
      exit 1
    fi
  fi

  # copy engine config file to container
  dst_engine_config_file="${DATABASE_WORKSPACE}/conf/engine_config.yaml"
  docker cp "${real_engine_config_file}" "${GIE_DB_CONTAINER_NAME}:${dst_engine_config_file}" || (echo "fail to copy $engine_config_file to container" && exit 1)


  # check if modern_graph exists in container, get the result as bool
  docker_graph_schema_file="${DATABASE_WORKSPACE}/data/${graph_name}/graph.yaml"
  flag_file="${DATABASE_WORKSPACE}/data/${graph_name}/indices/schema"
  if [ -f "${HOST_DB_TMP_DIR}/graph_exists" ]; then
    if ! rm "${HOST_DB_TMP_DIR}/graph_exists"; then
      err "fail to remove ${HOST_DB_TMP_DIR}/graph_exists, please remove it manually, maybe sudo rm -rf ${HOST_DB_TMP_DIR}/graph_exists"
      exit 1
    fi
  fi
  if [ -f "${HOST_DB_TMP_DIR}/graph_loaded" ]; then
    if ! rm "${HOST_DB_TMP_DIR}/graph_loaded"; then
      err "fail to remove ${HOST_DB_TMP_DIR}/graph_loaded, please remove it manually, maybe sudo rm -rf ${HOST_DB_TMP_DIR}/graph_loaded"
      exit 1
    fi
  fi
  docker exec "${GIE_DB_CONTAINER_NAME}" bash -c "( [ -f ${docker_graph_schema_file} ] && echo \"true\" e) || echo \"false\"" > ${HOST_DB_TMP_DIR}/graph_exists
  docker exec "${GIE_DB_CONTAINER_NAME}" bash -c "( [ -f ${flag_file} ] && echo \"true\" e) || echo \"false\"" > ${HOST_DB_TMP_DIR}/graph_loaded
  graph_exists=$(cat ${HOST_DB_TMP_DIR}/graph_exists)
  graph_loaded=$(cat ${HOST_DB_TMP_DIR}/graph_loaded)
  if [ "${graph_exists}" = "false" ]; then
    # if graph_name is default_graph, we should create it first
    # otherwise, we should tell user to create it first
    if [ "${graph_name}" != "${DATABASE_DEFAULT_GRAPH_NAME}" ]; then
      err "graph [${graph_name}] not exists, please create it first"
      exit 1
    fi
  fi

  if [ "${graph_loaded}" = "false" ]; then
    err "graph [${graph_name}] is empty, please import data first"
    exit 1
  fi

  info "graph [${graph_name}] exists, start it"
  
  do_stop
  ensure_container_running
  # regenerate graph.yaml from graph0.yaml and override graph.yaml with stored procedure enable and disable
  update_graph_yaml_with_procedure_enabling ${graph_name}

  # the bulk_load_file should place inside ${DATABASE_WORKSPACE}. and should use relative path
  if [ -f "${HOST_DB_RUNNING_FILE}" ]; then
      . ${HOST_DB_ENV_FILE}
  fi
  info "In start database, received graph_name = ${graph_name}, engine_config_file = ${engine_config_file}"
  docker_server_log_path="${DATABASE_WORKSPACE}/logs/server.log"
  graph_schema_file="${DATABASE_WORKSPACE}/data/${graph_name}/graph.yaml"
  csr_data_dir="${DATABASE_WORKSPACE}/data/${graph_name}/indices"
  cmd="docker exec ${GIE_DB_CONTAINER_NAME} bash -c \""
  cmd="${cmd} ${DOCKER_DB_SERVER_BIN} -c ${dst_engine_config_file}"
  cmd="${cmd} -g ${graph_schema_file}  --data-path ${csr_data_dir}"
  cmd="${cmd} > ${docker_server_log_path} 2>&1  & \""
  echo "Running cmd: ${cmd}"
  # eval command, if fails exist
  eval ${cmd} || (echo "Fail to launch hqps server" && exit 1)
  sleep 4
  # check whether the process is running
  check_process_running_in_container ${GIE_DB_CONTAINER_NAME} ${DOCKER_DB_SERVER_BIN} ", use gs_interactive service get_log -o [dir] to see get logs"
  info "Successfully start server"

  # start compiler
  docker_compiler_log_path="${DATABASE_WORKSPACE}/logs/compiler.log"
  cmd="docker exec ${GIE_DB_CONTAINER_NAME} bash -c \""
  cmd=${cmd}"java -cp \"${DOCKER_DB_GIE_HOME}/lib/*:${DOCKER_DB_GIE_HOME}/lib/compiler-0.0.1-SNAPSHOT.jar\" "
  cmd=${cmd}" -Djna.library.path=${DOCKER_DB_GIE_HOME}/lib/"
  cmd=${cmd}" -Dgraph.schema=${graph_schema_file}"
  # should error be reported?
  # cmd=${cmd}" -Dgraph.stored.procedures.uri=file:${docker_graph_plugin_dir}"
  cmd=${cmd}" ${DOCKER_DB_COMPILER_BIN} ${dst_engine_config_file} > ${docker_compiler_log_path} 2>&1 &"
  cmd=${cmd}"\""
  info "Running cmd: ${cmd}"
  eval ${cmd}
  sleep 6
  check_process_running_in_container ${GIE_DB_CONTAINER_NAME} ${DOCKER_DB_COMPILER_BIN} ", use gs_interactive service get_log -o [dir] to see more details"
  info "Successfully start compiler"
  # get cypher port from engine config file
  # bolt_connector_port=$(parse_yaml "${engine_config_file}" | grep "compiler_endpoint_bolt_connector_port" | awk -F "=" '{print $2}')
  emph "DataBase service is running, port is open on :${DATABASE_COMPILER_BOLT_PORT}"

  # if do_start success, we should write current args to ${HOST_DB_RUNNING_FILE}
  echo "GRAPH_NAME=${graph_name}" > ${HOST_DB_RUNNING_FILE}
  echo "ENGINE_CONFIG_FILE=${engine_config_file}" >> ${HOST_DB_RUNNING_FILE}
  # create .lock file
  docker_graph_lock_file="${DATABASE_WORKSPACE}/data/${graph_name}/.lock"
  docker exec "${GIE_DB_CONTAINER_NAME}" bash -c "touch ${docker_graph_lock_file}" || exit 1
}


####################  Stop database ####################
function do_stop(){
  # if container is not running, do nothing
  if [ -f "${HOST_DB_RUNNING_FILE}" ]; then
      . ${HOST_DB_ENV_FILE}
  else
    info "No running database found, do nothing"
  fi
  # get graph_name from ${HOST_DB_RUNNING_FILE}
  if [ -f "${HOST_DB_RUNNING_FILE}" ]; then
    local graph_name=$(sed -n '1p' ${HOST_DB_RUNNING_FILE} | cut -d '=' -f 2)
    docker_graph_lock_file="${DATABASE_WORKSPACE}/data/${graph_name}/.lock"
    docker exec "${GIE_DB_CONTAINER_NAME}" bash -c "rm -f ${docker_graph_lock_file}" || exit 1
    info "Successfully remove ${docker_graph_lock_file} file"
  else
    info "No graph is running"
  fi

  # stop the SERVER_BIN process and graph_server process
  docker exec "${GIE_DB_CONTAINER_NAME}" bash -c "pkill -f ${DOCKER_DB_SERVER_BIN}" 
  docker exec "${GIE_DB_CONTAINER_NAME}" bash -c "pkill -f ${DOCKER_DB_COMPILER_BIN}"
  sleep 6
  info "Successfully stop database"
}


####################  Get database status ####################
function do_status() {
  if [ "$(docker inspect -f '{{.State.Running}}' "${GIE_DB_CONTAINER_NAME}")" = "true" ]; then
    info "container ${GIE_DB_CONTAINER_NAME} is running"
  else
    info "container ${GIE_DB_CONTAINER_NAME} is not running"
    info "Please start database first"
  fi
  if [ -f "${HOST_DB_RUNNING_FILE}" ]; then
      . ${HOST_DB_ENV_FILE}
  fi
  # the container is running but the process is not running
  check_process_running_in_container ${GIE_DB_CONTAINER_NAME} ${DOCKER_DB_SERVER_BIN}  "The service is stopped or down. Use gs_interactive service get_log -o [dir] to see more details"
  check_process_running_in_container ${GIE_DB_CONTAINER_NAME} ${DOCKER_DB_COMPILER_BIN} "The service is stopped or down. Use gs_interactive service get_log -o [dir] to see more details"
  # get cypher port from engine config file in container

  docker_engine_config_file="${DATABASE_WORKSPACE}/conf/engine_config.yaml"
  # copy the engine config file to host's tmp directory
  docker cp "${GIE_DB_CONTAINER_NAME}:${docker_engine_config_file}" "${HOST_DB_TMP_DIR}/engine_config.yaml" || exit 1
  eval $(parse_yaml "${HOST_DB_TMP_DIR}/engine_config.yaml")
  emph "Database service is running, port is open on :${compiler_endpoint_bolt_connector_port}"
  # print current running graph name
  if [ -f "${HOST_DB_RUNNING_FILE}" ]; then
    local graph_name=$(sed -n '1p' ${HOST_DB_RUNNING_FILE} | cut -d '=' -f 2)
    emph "Current running graph is [${graph_name}]"
  else
    err "No graph is running"
  fi
}



####################  Restart ####################
function do_restart() {
  # read args from cached file.
  # get num lines in file ${HOST_DB_RUNNING_FILE}
  num_lines=$(wc -l < ${HOST_DB_RUNNING_FILE})
  if [ ${num_lines} -ne 2 ]; then
    err "Error: ${HOST_DB_RUNNING_FILE} should have 2 lines, but got ${num_lines}, something wrong with the file ${HOST_DB_RUNNING_FILE}"
    exit 1
  fi
  # read args from file
  GRAPH_NAME=$(sed -n '1p' ${HOST_DB_RUNNING_FILE} | cut -d '=' -f 2)
  ENGINE_CONFIG_FILE=$(sed -n '2p' ${HOST_DB_RUNNING_FILE} | cut -d '=' -f 2)
  # parse current args, override the args from file
  info "Restarting database..."
  while [[ $# -gt 0 ]]; do
    key="$1"
    case $key in
    -g | --graph)
      GRAPH_NAME="$2"
      shift # past argument
      shift
      ;;
    -c | --config)
      ENGINE_CONFIG_FILE="$2"
      shift
      shift
      ;;
    *)
      err "unknown option $1"
      restart_usage
      exit 1
      ;;
    esac
  done
  do_stop
  info "Successfully stop database"
  do_start -g ${GRAPH_NAME} -c ${ENGINE_CONFIG_FILE}
  info "Finish restarting database..."
}

####################  Get log ####################
function do_log(){
  if [ -f "${HOST_DB_RUNNING_FILE}" ]; then
      . ${HOST_DB_ENV_FILE}
  fi
  while [[ $# -gt 0 ]]; do
    key="$1"
    case $key in
    -o | --output)
      directory="$2"
      shift # past argument
      shift
      ;;
    *)
      err "unknown option $1"
      get_log_usage
      exit 1
      ;;
    esac
  done
  # check directory is set
  if [ -z "${directory}" ]; then
    err "output directory is not specified"
    get_log_usage
    exit 1
  fi
  # get log directory in container
  docker_log_dir="${DATABASE_WORKSPACE}/logs"
  # copy ${docker_log_dir}/compiler.log and ${docker_log_dir}/server.log to ${directory}
  docker_compiler_log="${docker_log_dir}/compiler.log"
  docker_server_log="${docker_log_dir}/server.log"
  # docker cp
  docker cp "${GIE_DB_CONTAINER_NAME}:${docker_compiler_log}" "${directory}/compiler.log" || exit 1
  docker cp "${GIE_DB_CONTAINER_NAME}:${docker_server_log}" "${directory}/server.log" || exit 1
  info "Successfully get log to ${directory}, please check compiler.log and server.log"
}

# the compiled dynamic libs will be placed at data/${graph_name}/plugins/
# after compilation, the user need to write the corresponding yaml, telling the compiler about 
# the input and output of the stored procedure
function do_compile() {
  ensure_container_running
  if [ $# -lt 2 ]; then
    err "compile stored_procedure command at least 2 args, but got $#"
    compile_usage
    exit 1
  fi
  compile_only=false

  while [[ $# -gt 0 ]]; do
    key="$1"
    case $key in
    -g | --graph)
      graph_name="$2"
      info "graph_name = ${graph_name}"
      shift # past argument
      shift
      ;;
    -i | --input)
      file_path="$2"
      shift # past argument
      shift
      ;;
    -n | --name)
      stored_procedure_name="$2"
      shift
      shift
      ;;
    -d | --description)
      stored_procedure_desc="$2"
      shift
      shift
      ;;
    --compile_only)
      compile_only=true
      shift
      shift
      ;;
    *)
      err "unknown option $1"
      compile_usage
      exit 1
      ;;
    esac
  done

  # check graph_name 
  if [ -z "${graph_name}" ]; then
    # let user confirm that no graph_name is specified, will use default graph.
    read -p "No graph_name is specified, will use default graph, continue? [y/n]" -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
      info "Abort compile stored_procedure"
      compile_usage
      exit 1
    fi
    info "Using default graph [${DATABASE_DEFAULT_GRAPH_NAME}]"
    graph_name=${DATABASE_DEFAULT_GRAPH_NAME}
  fi
  check_graph_name_valid "${graph_name}"
  # check graph exists
  if [ ! -d "${HOST_DB_HOME}/data/${graph_name}" ]; then
    err "graph [${graph_name}] can not be found, please create it first"
    exit 1
  fi

  # check file_path 
  check_file_exists "${file_path}"
  # get real file_path
  file_name=$(basename "${file_path}")
  # get file_name and assign to stored_procedure_name if stored_procedure_name is not set
  if [ -z "${stored_procedure_name}" ]; then
    stored_procedure_name="${file_name%.*}"
  fi
  real_file_path=$(realpath "${file_path}")
  # check exists
  if [ ! -f "${real_file_path}" ]; then
    err "file ${real_file_path} not exist"
    exit 1
  fi

  if [ -f "${HOST_DB_RUNNING_FILE}" ]; then
      . ${HOST_DB_ENV_FILE}
  fi

  real_engine_config_file="${HOST_DB_TMP_DIR}/real_engine_config.yaml"
  # update default graph name
  DATABASE_CURRENT_GRAPH_NAME=${graph_name}
  if ! generate_real_engine_conf "${real_engine_config_file}"; then
    err "Fail to generate real engine config file, please remove ${real_engine_config_file} and try again"
    exit 1
  fi
  # copy to container 
  docker_engine_config="${DATABASE_WORKSPACE}/conf/engine_config.yaml"
  docker cp "${real_engine_config_file}" "${GIE_DB_CONTAINER_NAME}:${docker_engine_config}" || exit 1

  docker_graph_dir="${DATABASE_WORKSPACE}/data/${graph_name}"
  docker_graph_schema="${docker_graph_dir}/graph.yaml"
  docker exec "${GIE_DB_CONTAINER_NAME}" bash -c "[ -d ${docker_graph_dir} ] || (echo -e \"${RED} Graph [${graph_name}] not exists, please create it first.${NC}\" && exit 1)"
  # Fetch current installed procedures, and check if the procedure is already installed
  # if not compile_only, we should add the stored_procedure_name to .enable
  docker_graph_enable_file="${docker_graph_dir}/plugins/.enable"
  # copy container to host
  if [ -f "${HOST_DB_TMP_DIR}/.enable" ]; then
    if ! rm -f ${HOST_DB_TMP_DIR}/.enable; then
      err "fail to remove ${HOST_DB_TMP_DIR}/.enable, please remove it manually, maybe sudo rm -rf ${HOST_DB_TMP_DIR}/.enable"
      exit 1
    fi
  fi
  # if docker_graph_enable_file exists. copy it to host
  docker exec "${GIE_DB_CONTAINER_NAME}" test -e "${docker_graph_enable_file}" && (docker cp "${GIE_DB_CONTAINER_NAME}:${docker_graph_enable_file}" "${HOST_DB_TMP_DIR}/.enable")

  if [ ! -f "${HOST_DB_TMP_DIR}/.enable" ]; then
    touch "${HOST_DB_TMP_DIR}/.enable"
  fi
  # check if the stored_procedure_name is already in .enable, exact match
  if grep -q "^${stored_procedure_name}$" "${HOST_DB_TMP_DIR}/.enable"; then
    err "stored_procedure_name [${stored_procedure_name}] already exists, please use another name"
    exit 1
  fi

  container_output_dir="${DATABASE_WORKSPACE}/data/${graph_name}/plugins"
  container_input_path="${HOST_DB_TMP_DIR}/${file_name}"
  # docker cp file to container
  cmd="docker cp ${real_file_path} ${GIE_DB_CONTAINER_NAME}:${container_input_path}"
  eval ${cmd} || exit 1

  cmd="docker exec ${GIE_DB_CONTAINER_NAME} bash -c '"
  cmd=${cmd}" ${DOCKER_DB_GEN_BIN}"
  cmd=${cmd}" --engine_type=hqps"
  cmd=${cmd}" --input=${container_input_path}"
  cmd=${cmd}" --work_dir=/tmp/codegen/"
  cmd=${cmd}" --ir_conf=${docker_engine_config}"
  cmd=${cmd}" --graph_schema_path=${docker_graph_schema}"
  cmd=${cmd}" --output_dir=${container_output_dir}"
  cmd=${cmd}" --procedure_name=${stored_procedure_name}"
  if [ ! -z "${stored_procedure_desc}" ]; then
    cmd=${cmd}" --procedure_desc=\"${stored_procedure_desc}\""
  fi
  cmd=${cmd}" '"

  echo "Running cmd: ${cmd}"
  eval ${cmd} || exit 1
  # check output exists
  # remove the suffix of file_name
  output_file="${HOST_DB_HOME}/data/${graph_name}/plugins/lib${stored_procedure_name}.so"

  if [ ! -f "${output_file}" ]; then
    err "output file ${output_file} not exist, compilation failed"
    exit 1
  fi
  info "success generate dynamic lib ${output_file}."

  # if compile_only equal to false
  if [ "${compile_only}" = false ]; then
    echo "${stored_procedure_name}" >> ${HOST_DB_TMP_DIR}/.enable
  fi
  # copy back 
  docker cp "${HOST_DB_TMP_DIR}/.enable" "${GIE_DB_CONTAINER_NAME}:${docker_graph_enable_file}" || exit 1
}

function do_enable(){
  while [[ $# -gt 0 ]]; do
    key="$1"
    case $key in
    -g | --graph)
      graph_name="$2"
      shift # past argument
      shift
      ;;
    -n | --name)
      stored_procedure_names="$2"
      shift
      shift
      ;;
    -c | --config)
      stored_procedure_names_yaml="$2"
      shift
      shift
      ;;
    *)
      err "unknown option $1"
      enable_proc_usage
      exit 1
      ;;
    esac
  done
  # check graph_name not empty
  # check graph_name 
  if [ -z "${graph_name}" ]; then
    # let user confirm that no graph_name is specified, will use default graph.
    read -p "No graph_name is specified, will use default graph, continue? [y/n]" -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
      info "Abort compile stored_procedure"
      enable_proc_usage
      exit 1
    fi
    info "Using default graph [${DATABASE_DEFAULT_GRAPH_NAME}]"
    graph_name=${DATABASE_DEFAULT_GRAPH_NAME}
  fi
  check_graph_name_valid "${graph_name}"
  if [ ! -d "${HOST_DB_HOME}/data/${graph_name}" ]; then
    err "graph [${graph_name}] can not be found, please create it first"
    exit 1
  fi

  # --name and --config can not be set at the same time
  if [ ! -z "${stored_procedure_names}" ] && [ ! -z "${stored_procedure_names_yaml}" ]; then
    err "--name and --config can not be set at the same time"
    enable_proc_usage
    exit 1
  fi
  # use stored_procedures_names_yaml if it is set
  if [ ! -z "${stored_procedure_names_yaml}" ]; then
    check_file_exists "${stored_procedure_names_yaml}"
    # cat the file and get each line as a stored_procedure_name, join them with ','
    stored_procedure_names=$(< ${stored_procedure_names_yaml} tr '\n' ',' |  sed 's/,$//')
  fi
  info "stored_procedure_names = ${stored_procedure_names}"
  # add the names to .enable file for graph_name 
  if [ -f "${HOST_DB_RUNNING_FILE}" ]; then
      . ${HOST_DB_ENV_FILE}
  fi
  docker_graph_dir="${DATABASE_WORKSPACE}/data/${graph_name}"
  docker exec "${GIE_DB_CONTAINER_NAME}" bash -c "[ -d ${docker_graph_dir} ] || (echo -e \"${RED} Graph ${graph_name} not exists, please create it first.${NC}\" && exit 1)"
  docker_graph_plugin_dir="${docker_graph_dir}/plugins"
  docker_graph_enable_file="${docker_graph_plugin_dir}/.enable"
  if [ -f "${HOST_DB_TMP_DIR}/.enable" ]; then
    if ! rm -f ${HOST_DB_TMP_DIR}/.enable; then
      err "fail to remove ${HOST_DB_TMP_DIR}/.enable, please remove it manually, maybe sudo rm -rf ${HOST_DB_TMP_DIR}/.enable"
      exit 1
    fi
  fi
  # copy the .enable file to host, and append the stored_procedure_names to it; if the stored_procedure_names already exists, do nothing
  docker cp "${GIE_DB_CONTAINER_NAME}:${docker_graph_enable_file}" "${HOST_DB_TMP_DIR}/.enable" || true
  if [ ! -f "${HOST_DB_TMP_DIR}/.enable" ]; then
    touch "${HOST_DB_TMP_DIR}/.enable"
  fi
  old_line_num=$(wc -l < ${HOST_DB_TMP_DIR}/.enable)
  # split the stored_procedure_names by ',' and append them to .enable file
  IFS=',' read -ra stored_procedure_names_array <<< "${stored_procedure_names}"
  for stored_procedure_name in "${stored_procedure_names_array[@]}"; do
    # check if the stored_procedure_name already exists in .enable file
    if grep -q "${stored_procedure_name}" "${HOST_DB_TMP_DIR}/.enable"; then
      info "stored_procedure_name ${stored_procedure_name} already exists in .enable file, skip"
    else
      echo "${stored_procedure_name}" >> ${HOST_DB_TMP_DIR}/.enable
    fi
  done
  # copy the .enable file back to container
  docker cp "${HOST_DB_TMP_DIR}/.enable" "${GIE_DB_CONTAINER_NAME}:${docker_graph_enable_file}" || exit 1
  new_line_num=$(wc -l < ${HOST_DB_TMP_DIR}/.enable)
  info "Successfully enable stored_procedures ${stored_procedure_names} for graph [${graph_name}], ${old_line_num} -> ${new_line_num}"
}

function do_disable(){
  disable_all=false
  while [[ $# -gt 0 ]]; do
    key="$1"
    case $key in
    -g | --graph)
      graph_name="$2"
      shift # past argument
      shift
      ;;
    -n | --name)
      stored_procedure_names="$2"
      shift
      shift
      ;;
    -c | --config)
      stored_procedure_names_yaml="$2"
      shift
      shift
      ;;
    -a | --all)
      disable_all=true
      shift
      ;;
    *)
      err "unknown option $1"
      disable_proc_usage
      exit 1
      ;;
    esac
  done

  # --name and --config can not be set at the same time
  if [ ! -z "${stored_procedure_names}" ] && [ ! -z "${stored_procedure_names_yaml}" ] && [ "${disable_all}" = true ]; then
    err "--name, --config and --all can not be set at the same time"
    disable_proc_usage
    exit 1
  fi
  if [ -f "${HOST_DB_RUNNING_FILE}" ]; then
      . ${HOST_DB_ENV_FILE}
  fi
  # check graph_name not empty
  if [ -z "${graph_name}" ]; then
    # let user confirm that no graph_name is specified, will use default graph.
    read -p "No graph_name is specified, will use default graph, continue? [y/n]" -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
      info "Abort compile stored_procedure"
      disable_proc_usage
      exit 1
    fi
    info "Using default graph [${DATABASE_DEFAULT_GRAPH_NAME}]"
    graph_name=${DATABASE_DEFAULT_GRAPH_NAME}
  fi
  check_graph_name_valid "${graph_name}"
  if [ ! -d "${HOST_DB_HOME}/data/${graph_name}" ]; then
    err "graph [${graph_name}] can not be found, please create it first"
    exit 1
  fi

  info "graph_name = ${graph_name}"
  docker_graph_dir="${DATABASE_WORKSPACE}/data/${graph_name}"
  docker exec "${GIE_DB_CONTAINER_NAME}" bash -c "[ -d ${docker_graph_dir} ] || (echo \"graph ${graph_name} not exists, please create it first\" && exit 1)"
  docker_graph_plugin_dir="${docker_graph_dir}/plugins"
  docker_graph_enable_file="${docker_graph_plugin_dir}/.enable"
  echo "disable_all = ${disable_all}"
  if [ "${disable_all}" = true ]; then
    # clear the .enable file
    info "disable all stored_procedures for graph [${graph_name}]"
    docker exec "${GIE_DB_CONTAINER_NAME}" bash -c "(rm \"\" > ${docker_graph_enable_file}) || exit 0" || exit 1
    info "Successfully disable all stored_procedures for graph [${graph_name}]"
    exit 0
  fi

  # use stored_procedures_names_yaml if it is set
  if [ ! -z "${stored_procedure_names_yaml}" ]; then
    check_file_exists "${stored_procedure_names_yaml}"
    # cat the file and get each line as a stored_procedure_name, join them with ','
    stored_procedure_names=$(< ${stored_procedure_names_yaml} tr '\n' ',' |  sed 's/,$//')
  fi
  info "stored_procedure_names = ${stored_procedure_names}"
  # add the names to .enable file for graph_name 

  # copy the .enable file to host, and remove the stored_procedure_names from it
  docker cp "${GIE_DB_CONTAINER_NAME}:${docker_graph_enable_file}" "${HOST_DB_TMP_DIR}/.enable" || exit 1
  old_line_num=$(wc -l < ${HOST_DB_TMP_DIR}/.enable)
  # split the stored_procedure_names by ',' and remove them from .enable file
  IFS=',' read -ra stored_procedure_names_array <<< "${stored_procedure_names}"
  for stored_procedure_name in "${stored_procedure_names_array[@]}"; do
    sed -i "/${stored_procedure_name}/d" ${HOST_DB_TMP_DIR}/.enable
  done
  # copy the .enable file back to container
  docker cp "${HOST_DB_TMP_DIR}/.enable" "${GIE_DB_CONTAINER_NAME}:${docker_graph_enable_file}" || exit 1
  new_line_num=$(wc -l < ${HOST_DB_TMP_DIR}/.enable)
  info "Successfully disable stored_procedures ${stored_procedure_names} for graph [${graph_name}], ${old_line_num} -> ${new_line_num}"
}

function do_show(){
  while [[ $# -gt 0 ]]; do
    key="$1"
    case $key in
    -g | --graph)
      graph_name="$2"
      shift
      shift
      ;;
    *)
      err "unknown option $1"
      show_stored_procedure_usage
      exit 1
      ;;
    esac
  done
  if [ -f "${HOST_DB_RUNNING_FILE}" ]; then
      . ${HOST_DB_ENV_FILE}
  fi
  # check graph_name 
  if [ -z "${graph_name}" ]; then
    # let user confirm that no graph_name is specified, will use default graph.
    read -p "No graph_name is specified, will use default graph, continue? [y/n]" -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
      info "Abort compile stored_procedure"
      show_stored_procedure_usage
      exit 1
    fi
    info "Using default graph [${DATABASE_DEFAULT_GRAPH_NAME}]"
    graph_name=${DATABASE_DEFAULT_GRAPH_NAME}
  fi
  check_graph_name_valid "${graph_name}"
  if [ ! -d "${HOST_DB_HOME}/data/${graph_name}" ]; then
    err "graph [${graph_name}] can not be found, please create it first"
    exit 1
  fi
  info "graph_name = ${graph_name}"
  docker_graph_dir="${DATABASE_WORKSPACE}/data/${graph_name}"
  docker exec "${GIE_DB_CONTAINER_NAME}" bash -c "[ -d ${docker_graph_dir} ] || (echo -e \"${RED}Graph [${graph_name}] not exists, please create it first. ${NC}\" && exit 1)" || exit 1
  docker_graph_yaml="${docker_graph_dir}/graph.yaml"
  # check if docker_graph_yaml exists, if not ,exit
  docker exec "${GIE_DB_CONTAINER_NAME}" bash -c "[ -f ${docker_graph_yaml} ] || (echo -e \"${RED}Graph [${graph_name}] not exists, please create it first. ${NC}\" && exit 1)" || exit 1
  # copy to host
  docker cp "${GIE_DB_CONTAINER_NAME}:${docker_graph_yaml}" "${HOST_DB_TMP_DIR}/graph.yaml" || (echo "fail to copy" && exit 1)
  # parse /tmp/graph.yaml and get stored_procedures_enable_lists array
  eval $(parse_yaml "${HOST_DB_TMP_DIR}/graph.yaml")
  x=1
  stored_procedures_enable_lists_array=()
  while true; do
    procedure_name_key="stored_procedures_enable_lists_${x}"
    procedure_name_value_x=$(eval echo "\$${procedure_name_key}")
    if [ -z "${procedure_name_value_x}" ]; then
      break
    fi
    #append value to array
    stored_procedures_enable_lists_array+=("${procedure_name_value_x}")
    x=$((x + 1))
  done
  info "Enabled Size: ${#stored_procedures_enable_lists_array[@]}"

  # parse the .enabled file
  docker_graph_plugin_dir="${docker_graph_dir}/plugins"
  docker_graph_enable_file="${docker_graph_plugin_dir}/.enable"
  # check if docker_graph_enable_file exists, if not ,exit
  docker exec "${GIE_DB_CONTAINER_NAME}" bash -c "[ -f ${docker_graph_enable_file} ] || (echo -e \"${RED}Graph [${graph_name}] has no procedures registered. ${NC}\" && exit 1)" || exit 1
  docker cp "${GIE_DB_CONTAINER_NAME}:${docker_graph_enable_file}" "${HOST_DB_TMP_DIR}/.enable" || exit 1
  disabled_list=()
  # iterate the .enable file, for each line, check if it is in stored_procedures_enable_lists_array, if not, add it to disabled_list
  while read line; do
    if [[ ! " ${stored_procedures_enable_lists_array[@]} " =~ " ${line} " ]]; then
      disabled_list+=("${line}")
    fi
  done < ${HOST_DB_TMP_DIR}/.enable
  info "Disabled Size: ${#disabled_list[@]}"

  # print the enabled_list and disabled_list
  for procedure_name in "${stored_procedures_enable_lists_array[@]}"; do
    emph "  ${procedure_name} : [Enabled]"
  done
  for procedure_name in "${disabled_list[@]}"; do
    emph "  ${procedure_name} : [Disabled]"
  done
}

function do_database(){
  while [[ $# -gt 0 ]]; do
    key="$1"
    case $key in
    create)
      shift
      do_create "$@"
      exit 0
      ;;
    remove)
      shift
      do_remove "$@"
      exit 0
      ;;
    import)
      shift
      do_import "$@"
      exit 0
      ;;
    list)
      shift
      do_list "$@"
      exit 0
      ;;
    *)
      err "unknown option $1"
      database_usage
      exit 1
      ;;
    esac
  done
}

function do_service(){
  while [[ $# -gt 0 ]]; do
    key="$1"
    case $key in
    start)
      shift
      do_start "$@"
      exit 0
      ;;
    stop)
      shift
      do_stop "$@"
      exit 0
      ;;
    restart)
      shift
      do_restart "$@"
      exit 0
      ;;
    status)
      shift
      do_status "$@"
      exit 0
      ;;
    get_log)
      shift
      do_log "$@"
      exit 0
      ;;
    *)
      err "unknown option $1"
      services_usage
      exit 1
      ;;
    esac
  done
}

function do_procedure(){
  while [[ $# -gt 0 ]]; do
    key="$1"
    case $key in
    compile)
      shift
      do_compile "$@"
      exit 0
      ;;
    enable)
      shift
      do_enable "$@"
      exit 0
      ;;
    disable)
      shift
      do_disable "$@"
      exit 0
      ;;
    show)
      shift
      do_show "$@"
      exit 1
      ;;
    *)
      err "unknown option $1"
      procedure_usage
      exit 1
      ;;
    esac
  done
  procedure_usage
}

####################  Entry ####################
if [ $# -eq 0 ]; then
  usage
  exit 1
fi

while [[ $# -gt 0 ]]; do
  key="$1"

  case $key in
  -h | --help)
    usage
    exit
    ;;
  init)
    shift
    info "Start initiating database..."
    do_init "$@"
    exit 0
    ;;
  database)
    shift
    check_database_initialized
    do_database "$@"
    exit 0
    ;;
  service)
    shift
    check_database_initialized
    do_service "$@"
    exit 0
    ;;
  procedure)
    shift
    check_database_initialized
    do_procedure "$@"
    exit 0
    ;;
  destroy)
    shift
    do_destroy "$@"
    exit 0
    ;;
  *) # unknown option
    err "unknown option $1"
    usage
    exit 1
    ;;
  esac
done