## SubTask实验结论

**结论一：**apply性能对外层层级数m更敏感，join的性能对内层层级数n更敏感。

证明：这里我们主要通过控制内外层层数之和m+n来观察在不同m与n下apply与join的性能，从而探究它们的性能对于内外层层数的敏感性。这里我们设定m+n=5，于是发现有下表所示的规律：

|                     | Apply          | Join            |
| ------------------- | -------------- | --------------- |
| [10,10,10,10]与[10] | y=9.22x-361.51 | y=2.50x+912.92  |
| [10,10,10]与[10,10] | y=3.23x-80.87  | y=3.14x+1144.90 |
| [10,10]与[10,10,10] | y=2.43x+42.54  | y=7.22x+439.34  |
| [10]与[10,10,10,10] | y=2.38x+101.46 | y=9.85x+208.83  |

可以看见，虽然这里我们制定了m+n都是一个确定的数为5，这也意味着在图中遍历的数据量是一样的，但是对于apply和join来说不同的内外层层级数会影响到两者的查询性能，具体地说对apply来说，如果外层的层级数越大，其查询性能越差，而对join来说恰好相反，如果是外层的层级数越大，内层层级数越小越有利于其进行优化查询。因此我们认为apply对外层数较敏感，join对内层数较敏感。这个规律不仅仅在m+n=5时成立，在总数为4和6的情况下都成立，如下表所示：

|                  | Apply         | Join           |
| ---------------- | ------------- | -------------- |
| [10,10,10]与[10] | y=0.83x-1.96  | y=0.61x+145.10 |
| [10,10]与[10,10] | y=0.31x+13.08 | y=0.77x+54.06  |
| [10]与[10,10,10] | y=0.24x+15.33 | y=1.00x+16.84  |

|                        | Apply              | Join             |
| ---------------------- | ------------------ | ---------------- |
| [10,10,10,10,10]与[10] | y=178.32x-37903.19 | y=20.80x+2010.11 |
| [10,10,10,10]与[10,10] | y=34.26x-360.49    | y=4.03x+6237.84  |
| [10,10,10]与[10,10,10] | y=26.64x-25.96     | y=26.50x+9588.84 |
| [10,10]与[10,10,10,10] | y=24.58x+105.79    | y=71.28x+753.91  |

造成这种现象的原因是，我们通过分析dump出来的时间图发现，对apply而言，每次在外层数据遍历完成，继续做内层数据的时候，会做一个fork_subtask的操作，相当于需要把外层遍历的结果传入到内层的输入中，而这个过程需要消耗的时间与Dm呈正相关。因此外层越多，数据量越大，对apply而言性能损失越大。而对于Join而言，外层如果数量越大，dedup完之后的数据与dedup之前的数据差较大，因此一定程度上有利于内层的遍历。当然这里我们也不能保证外层数越大，内层数越少join性能越好，如在外层数为[10,10,10,10,10]与[10]的情况下，join的性能并没有体现出像之前那样递减的趋势，其实这也是因为虽然我们在外层有dedup，但总体上join的Dm还是在增加的，在一定量下随着源节点数目增加会导致join性能变坏，但这种趋势相较于apply会好很多，这也是得益于dedup机制。如果外层数较少的情况，这种优势并不明显，因此相较于apply开销也就越大。

**结论二：**在没有Early-stop的情况下，apply更适用于在外层层级数m较少，Dm数目较小的情况，而join更适合于外层层级数较多，Dm较大的情况。

证明：从结论一种我们得到apply对于外层数越大，性能越差，而join恰好相反，内层数越大性能越差，因此我们从这个结论中可以初步判定apply更适用于外层数较小的情况，join适合外层数较大的情况，于是我们根据以下实验结果得到：

1. 当外层数为1的时候：
    
|                       | Apply           | Join             |
|-----------------------|-----------------|------------------|
| [10]与[10,10,10,10,10] | y=27.69x+126.86 | y=86.80x+1359.47 |
| [10]与[10,10,10,10]    | y=2.38x+101.46  | y=9.85x+208.83   |
| [10]与[10,10,10]       | y=0.24x+15.33   | y=1.00x+16.84    |
| [10]与[10,10]          | y=0.03x+5.15    | y=0.10x+7.62     |
| [10]与[10]             | y=0.01x+0.50    | y=0.015x+1.11    |

由斜率发现无论内层数量为多少，无论源节点数如何增加， Join拟合的直线斜率都大于apply的斜率，且由结论一可知内层数量增大join性能越差，因此这种情况下join永远也追不上apply。

2. 当外层数为2的时候：

|                       | Apply           | Join            |
|-----------------------|-----------------|-----------------|
| [10,10]与[10,10,10,10] | y=24.58x+105.79 | y=71.28x+753.91 |
| [10,10]与[10,10,10]    | y=2.43x+42.54   | y=7.22x+439.34  |
| [10,10]与[10,10]       | y=0.31x+13.08   | y=0.77x+54.06   |
| [10,10]与[10]          | y=0.08x+4.13    | y=0.12x+9.22    |

这种情况与外层数为1的情况类似，即使在join性能表现最好的，内层数为1的情况join都无法追上apply，其他的情况则更不可能。

3. 当外层数为3的时候：

|                             | Apply             | Join                |
|-----------------------------|-------------------|---------------------|
| [10,10,10]与[10,10,10,10,10] | y=2735.32x+387.09 | y=6410.62x-3943.60  |
| [10,10,10]与[10,10,10,10]    | y=260.72x-1076.03 | y=247.31x+101611.95 |
| [10,10,10]与[10,10,10]       | y=26.64x-25.96    | y=26.50x+9588.84    |
| [10,10,10]与[10,10]          | y=3.23x-80.87     | y=3.14x+1144.90     |
| [10,10,10]与[10]             | y=0.83x-1.96      | y=0.61x+145.10      |

可以发现在这种情况下Join出现了较apply性能较优的情况，即在内层数小于5的时候join整体的效率要高于apply（虽然在源节点数较小的情况下可能会出现apply较优的情况，但这种情况总会出现一个交点，在交点之后即源节点数达到一定程度之后join的效率要优于apply），且这种优势体现在源节点越大，即Dm越大的时候，join的优势越明显。但是可以发现在内层数大于等于5的时候，join的性能明显降低。显示出类似像外层数为1和2的情况，即无论源节点数怎样变化，join的性能永远不会优于apply。

4. 当外层数为4的时候：

|                             | Apply              | Join                |
|-----------------------------|--------------------|---------------------|
| [10,10,10,10]与[10,10,10,10] | Y=2739.05x-6831.58 | Y=3297.34x+41930.76 |
| [10,10,10,10]与[10,10,10]    | y=259.32x-3.40     | y=17.72x+54375.46   |
| [10,10,10,10]与[10,10]       | y=34.26x-360.49    | y=4.03x+6237.84     |
| [10,10,10,10]与[10]          | y=9.22x-361.51     | y=2.50x+912.92      |

可以发现这种情况和外层数为3的情况一致，在内层层级数较小的时候先是join的性能会相对较好，而随着外层数增大，join的性能急剧下降，从而性能远不如apply。

**结论三：**加入Early-stop机制后，apply更适用于外层层级数少，内层层级数多的情况。

|                             | Apply              | Apply_limit       |
|-----------------------------|--------------------|-------------------|
| [10,10,10,10]与[10,10,10,10] | y=2739.05x-6831.58 | y=381.46x+7385.65 |
| [10,10,10,10]与[10,10,10]    | y=259.32x-3.40     | y=61.81x-1491.62  |
| [10,10,10,10]与[10,10]       | y=34.26x-360.49    | y=26.97x-376.82   |
| [10,10,10,10]与[10]          | y=9.22x-361.51     | y=22.67x-1087.61  |
| [10,10,10]与[10,10,10,10]    | y=2735.32x+387.09  | y=38.59x-630.37   |
| [10,10,10]与[10,10,10]       | y=260.72x-1076.03  | y=5.97x+93.01     |
| [10,10,10]与[10,10]          | y=26.64x-25.96     | y=2.55x+34.73     |
| [10,10,10]与[10]             | y=3.23x-80.87      | y=2.07x+14.34     |
| [10,10]与[10,10,10,10]       | y=24.58x+105.79    | y=3.76x+29.60     |
| [10,10]与[10,10,10]          | y=2.43x+42.54      | y=0.60x+12.90     |
| [10,10]与[10,10]             | y=0.31x+13.08      | y=0.26x+7.94      |
| [10,10]与[10]                | y=0.08x+4.13       | y=0.21x+10.19     |
| [10]与[10,10,10,10]          | y=2.38x+101.46     | y=0.38x+9.10      |
| [10]与[10,10,10]             | y=0.24x+15.33      | y=0.06x+6.33      |
| [10]与[10,10]                | y=0.03x+5.15       | y=0.03x+2.84      |
| [10]与[10]                   | y=0.01x+0.50       | y=0.02x+2.38      |

从表中可以看出，加入early-stop机制后并不一定会使apply性能更好，比如在内层数为1的时候，因为early-stop在执行limit操作时会有反馈时间导致在内层数并不太多的时候性能可能会更差。所以可以预见在加入早停机制之后，apply的性能在内层数较多的时候会更好。因此我们对比join和apply_limit如下表所示：

|                             | Join                | Apply_limit       |
|-----------------------------|---------------------|-------------------|
| [10,10,10,10]与[10,10,10,10] | Y=3297.34x+41930.76 | y=381.46x+7385.65 |
| [10,10,10,10]与[10,10,10]    | y=17.72x+54375.46   | y=61.81x-1491.62  |
| [10,10,10,10]与[10,10]       | y=4.03x+6237.84     | y=26.97x-376.82   |
| [10,10,10,10]与[10]          | y=2.50x+912.92      | y=22.67x-1087.61  |
| [10,10,10]与[10,10,10,10]    | y=247.31x+101611.95 | y=38.59x-630.37   |
| [10,10,10]与[10,10,10]       | y=26.50x+9588.84    | y=5.97x+93.01     |
| [10,10,10]与[10,10]          | y=3.14x+1144.90     | y=2.55x+34.73     |
| [10,10,10]与[10]             | y=0.61x+145.10      | y=2.07x+14.34     |
| [10,10]与[10,10,10,10]       | y=71.28x+753.91     | y=3.76x+29.60     |
| [10,10]与[10,10,10]          | y=7.22x+439.34      | y=0.60x+12.90     |
| [10,10]与[10,10]             | y=0.77x+54.06       | y=0.26x+7.94      |
| [10,10]与[10]                | y=0.12x+9.22        | y=0.21x+10.19     |
| [10]与[10,10,10,10]          | y=9.85x+208.83      | y=0.38x+9.10      |
| [10]与[10,10,10]             | y=1.00x+16.84       | y=0.06x+6.33      |
| [10]与[10,10]                | y=0.10x+7.62        | y=0.03x+2.84      |
| [10]与[10]                   | y=0.015x+1.11       | y=0.02x+2.38      |

​		显然，在外层数较少，内层数较大的时候，apply_limit性能更好，如在外层数为1的时候，apply_limit性能永远好于join，在外层数为2的时候也只有内层数为1的时候join性能才会稍微好一点，在外层数为3和为4的时候，一般是join的性能先好于apply_limit，但随着内层数增多，join性能受影响较大，导致性能不如apply_limit。

多线程与分布式情况待完善。